{"version":3,"sources":["../src/index.ts","../src/environment.ts"],"sourcesContent":["import { elizaLogger } from \"@ai16z/eliza\";\r\nimport {\r\n    Action,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Memory,\r\n    Plugin,\r\n    State,\r\n} from \"@ai16z/eliza\";\r\nimport { generateImage } from \"@ai16z/eliza\";\r\n\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport { validateImageGenConfig } from \"./environment\";\r\n\r\nexport function saveBase64Image(base64Data: string, filename: string): string {\r\n    // Create generatedImages directory if it doesn't exist\r\n    const imageDir = path.join(process.cwd(), \"generatedImages\");\r\n    if (!fs.existsSync(imageDir)) {\r\n        fs.mkdirSync(imageDir, { recursive: true });\r\n    }\r\n\r\n    // Remove the data:image/png;base64 prefix if it exists\r\n    const base64Image = base64Data.replace(/^data:image\\/\\w+;base64,/, \"\");\r\n\r\n    // Create a buffer from the base64 string\r\n    const imageBuffer = Buffer.from(base64Image, \"base64\");\r\n\r\n    // Create full file path\r\n    const filepath = path.join(imageDir, `${filename}.png`);\r\n\r\n    // Save the file\r\n    fs.writeFileSync(filepath, imageBuffer);\r\n\r\n    return filepath;\r\n}\r\n\r\nexport async function saveHeuristImage(\r\n    imageUrl: string,\r\n    filename: string\r\n): Promise<string> {\r\n    const imageDir = path.join(process.cwd(), \"generatedImages\");\r\n    if (!fs.existsSync(imageDir)) {\r\n        fs.mkdirSync(imageDir, { recursive: true });\r\n    }\r\n\r\n    // Fetch image from URL\r\n    const response = await fetch(imageUrl);\r\n    if (!response.ok) {\r\n        throw new Error(`Failed to fetch image: ${response.statusText}`);\r\n    }\r\n\r\n    const arrayBuffer = await response.arrayBuffer();\r\n    const imageBuffer = Buffer.from(arrayBuffer);\r\n\r\n    // Create full file path\r\n    const filepath = path.join(imageDir, `${filename}.png`);\r\n\r\n    // Save the file\r\n    fs.writeFileSync(filepath, imageBuffer);\r\n\r\n    return filepath;\r\n}\r\n\r\nconst imageGeneration: Action = {\r\n    name: \"GENERATE_IMAGE\",\r\n    similes: [\r\n        \"IMAGE_GENERATION\",\r\n        \"IMAGE_GEN\",\r\n        \"CREATE_IMAGE\",\r\n        \"MAKE_PICTURE\",\r\n        \"GENERATE_IMAGE\",\r\n        \"GENERATE_A\",\r\n        \"DRAW\",\r\n        \"DRAW_A\",\r\n        \"MAKE_A\",\r\n    ],\r\n    description: \"Generate an image to go along with the message.\",\r\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\r\n        await validateImageGenConfig(runtime);\r\n\r\n        const anthropicApiKeyOk = !!runtime.getSetting(\"ANTHROPIC_API_KEY\");\r\n        const togetherApiKeyOk = !!runtime.getSetting(\"TOGETHER_API_KEY\");\r\n        const heuristApiKeyOk = !!runtime.getSetting(\"HEURIST_API_KEY\");\r\n        const falApiKeyOk = !!runtime.getSetting(\"FAL_API_KEY\");\r\n        const openAiApiKeyOk = !!runtime.getSetting(\"OPENAI_API_KEY\");\r\n\r\n        return (\r\n            anthropicApiKeyOk ||\r\n            togetherApiKeyOk ||\r\n            heuristApiKeyOk ||\r\n            falApiKeyOk ||\r\n            openAiApiKeyOk\r\n        );\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        options: {\r\n            width?: number;\r\n            height?: number;\r\n            count?: number;\r\n            negativePrompt?: string;\r\n            numIterations?: number;\r\n            guidanceScale?: number;\r\n            seed?: number;\r\n            modelId?: string;\r\n            jobId?: string;\r\n        },\r\n        callback: HandlerCallback\r\n    ) => {\r\n        elizaLogger.log(\"Composing state for message:\", message);\r\n        state = (await runtime.composeState(message)) as State;\r\n        const userId = runtime.agentId;\r\n        elizaLogger.log(\"User ID:\", userId);\r\n\r\n        const imagePrompt = message.content.text;\r\n        elizaLogger.log(\"Image prompt received:\", imagePrompt);\r\n\r\n        // TODO: Generate a prompt for the image\r\n\r\n        const res: { image: string; caption: string }[] = [];\r\n\r\n        elizaLogger.log(\"Generating image with prompt:\", imagePrompt);\r\n        const images = await generateImage(\r\n            {\r\n                prompt: imagePrompt,\r\n                width: options.width || 1024,\r\n                height: options.height || 1024,\r\n                ...(options.count != null ? { count: options.count || 1 } : {}),\r\n                ...(options.negativePrompt != null\r\n                    ? { negativePrompt: options.negativePrompt }\r\n                    : {}),\r\n                ...(options.numIterations != null\r\n                    ? { numIterations: options.numIterations }\r\n                    : {}),\r\n                ...(options.guidanceScale != null\r\n                    ? { guidanceScale: options.guidanceScale }\r\n                    : {}),\r\n                ...(options.seed != null ? { seed: options.seed } : {}),\r\n                ...(options.modelId != null\r\n                    ? { modelId: options.modelId }\r\n                    : {}),\r\n                ...(options.jobId != null ? { jobId: options.jobId } : {}),\r\n            },\r\n            runtime\r\n        );\r\n\r\n        if (images.success && images.data && images.data.length > 0) {\r\n            elizaLogger.log(\r\n                \"Image generation successful, number of images:\",\r\n                images.data.length\r\n            );\r\n            for (let i = 0; i < images.data.length; i++) {\r\n                const image = images.data[i];\r\n\r\n                // Save the image and get filepath\r\n                const filename = `generated_${Date.now()}_${i}`;\r\n\r\n                // Choose save function based on image data format\r\n                const filepath = image.startsWith(\"http\")\r\n                    ? await saveHeuristImage(image, filename)\r\n                    : saveBase64Image(image, filename);\r\n\r\n                elizaLogger.log(`Processing image ${i + 1}:`, filename);\r\n\r\n                //just dont even add a caption or a description just have it generate & send\r\n                /*\r\n                try {\r\n                    const imageService = runtime.getService(ServiceType.IMAGE_DESCRIPTION);\r\n                    if (imageService && typeof imageService.describeImage === 'function') {\r\n                        const caption = await imageService.describeImage({ imageUrl: filepath });\r\n                        captionText = caption.description;\r\n                        captionTitle = caption.title;\r\n                    }\r\n                } catch (error) {\r\n                    elizaLogger.error(\"Caption generation failed, using default caption:\", error);\r\n                }*/\r\n\r\n                const _caption = \"...\";\r\n                /*= await generateCaption(\r\n                    {\r\n                        imageUrl: image,\r\n                    },\r\n                    runtime\r\n                );*/\r\n\r\n                res.push({ image: filepath, caption: \"...\" }); //caption.title });\r\n\r\n                elizaLogger.log(\r\n                    `Generated caption for image ${i + 1}:`,\r\n                    \"...\" //caption.title\r\n                );\r\n                //res.push({ image: image, caption: caption.title });\r\n\r\n                callback(\r\n                    {\r\n                        text: \"...\", //caption.description,\r\n                        attachments: [\r\n                            {\r\n                                id: crypto.randomUUID(),\r\n                                url: filepath,\r\n                                title: \"Generated image\",\r\n                                source: \"imageGeneration\",\r\n                                description: \"...\", //caption.title,\r\n                                text: \"...\", //caption.description,\r\n                            },\r\n                        ],\r\n                    },\r\n                    [\r\n                        {\r\n                            attachment: filepath,\r\n                            name: `${filename}.png`,\r\n                        },\r\n                    ]\r\n                );\r\n            }\r\n        } else {\r\n            elizaLogger.error(\"Image generation failed or returned no data.\");\r\n        }\r\n    },\r\n    examples: [\r\n        // TODO: We want to generate images in more abstract ways, not just when asked to generate an image\r\n\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: { text: \"Generate an image of a cat\" },\r\n            },\r\n            {\r\n                user: \"{{agentName}}\",\r\n                content: {\r\n                    text: \"Here's an image of a cat\",\r\n                    action: \"GENERATE_IMAGE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: { text: \"Generate an image of a dog\" },\r\n            },\r\n            {\r\n                user: \"{{agentName}}\",\r\n                content: {\r\n                    text: \"Here's an image of a dog\",\r\n                    action: \"GENERATE_IMAGE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: { text: \"Create an image of a cat with a hat\" },\r\n            },\r\n            {\r\n                user: \"{{agentName}}\",\r\n                content: {\r\n                    text: \"Here's an image of a cat with a hat\",\r\n                    action: \"GENERATE_IMAGE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: { text: \"Make an image of a dog with a hat\" },\r\n            },\r\n            {\r\n                user: \"{{agentName}}\",\r\n                content: {\r\n                    text: \"Here's an image of a dog with a hat\",\r\n                    action: \"GENERATE_IMAGE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: { text: \"Paint an image of a cat with a hat\" },\r\n            },\r\n            {\r\n                user: \"{{agentName}}\",\r\n                content: {\r\n                    text: \"Here's an image of a cat with a hat\",\r\n                    action: \"GENERATE_IMAGE\",\r\n                },\r\n            },\r\n        ],\r\n    ],\r\n} as Action;\r\n\r\nexport const imageGenerationPlugin: Plugin = {\r\n    name: \"imageGeneration\",\r\n    description: \"Generate images\",\r\n    actions: [imageGeneration],\r\n    evaluators: [],\r\n    providers: [],\r\n};\r\n","import { IAgentRuntime } from \"@ai16z/eliza\";\r\nimport { z } from \"zod\";\r\n\r\nexport const imageGenEnvSchema = z\r\n    .object({\r\n        ANTHROPIC_API_KEY: z.string().optional(),\r\n        TOGETHER_API_KEY: z.string().optional(),\r\n        HEURIST_API_KEY: z.string().optional(),\r\n        FAL_API_KEY: z.string().optional(),\r\n        OPENAI_API_KEY: z.string().optional(),\r\n    })\r\n    .refine(\r\n        (data) => {\r\n            return !!(\r\n                data.ANTHROPIC_API_KEY ||\r\n                data.TOGETHER_API_KEY ||\r\n                data.HEURIST_API_KEY ||\r\n                data.FAL_API_KEY ||\r\n                data.OPENAI_API_KEY\r\n            );\r\n        },\r\n        {\r\n            message:\r\n                \"At least one of ANTHROPIC_API_KEY, TOGETHER_API_KEY, HEURIST_API_KEY, FAL_API_KEY or OPENAI_API_KEY is required\",\r\n        }\r\n    );\r\n\r\nexport type ImageGenConfig = z.infer<typeof imageGenEnvSchema>;\r\n\r\nexport async function validateImageGenConfig(\r\n    runtime: IAgentRuntime\r\n): Promise<ImageGenConfig> {\r\n    try {\r\n        const config = {\r\n            ANTHROPIC_API_KEY:\r\n                runtime.getSetting(\"ANTHROPIC_API_KEY\") ||\r\n                process.env.ANTHROPIC_API_KEY,\r\n            TOGETHER_API_KEY:\r\n                runtime.getSetting(\"TOGETHER_API_KEY\") ||\r\n                process.env.TOGETHER_API_KEY,\r\n            HEURIST_API_KEY:\r\n                runtime.getSetting(\"HEURIST_API_KEY\") ||\r\n                process.env.HEURIST_API_KEY,\r\n            FAL_API_KEY:\r\n                runtime.getSetting(\"FAL_API_KEY\") || process.env.FAL_API_KEY,\r\n            OPENAI_API_KEY:\r\n                runtime.getSetting(\"OPENAI_API_KEY\") ||\r\n                process.env.OPENAI_API_KEY,\r\n        };\r\n\r\n        return imageGenEnvSchema.parse(config);\r\n    } catch (error) {\r\n        if (error instanceof z.ZodError) {\r\n            const errorMessages = error.errors\r\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\r\n                .join(\"\\n\");\r\n            throw new Error(\r\n                `Image generation configuration validation failed:\\n${errorMessages}`\r\n            );\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n"],"mappings":"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","names":[]}