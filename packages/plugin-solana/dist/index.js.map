{"version":3,"sources":["../src/providers/token.ts","../src/bignumber.ts","../src/providers/wallet.ts","../src/providers/trustScoreProvider.ts","../src/providers/simulationSellingService.ts","../../../node_modules/uuid/dist/esm-node/rng.js","../../../node_modules/uuid/dist/esm-node/stringify.js","../../../node_modules/uuid/dist/esm-node/native.js","../../../node_modules/uuid/dist/esm-node/v4.js","../src/evaluators/trust.ts","../src/actions/swap.ts","../src/actions/swapUtils.ts","../src/actions/takeOrder.ts","../src/actions/pumpfun.ts","../src/actions/swapDao.ts","../src/actions/transfer.ts","../src/index.ts"],"sourcesContent":["import { ICacheManager, settings } from \"@ai16z/eliza\";\r\nimport { IAgentRuntime, Memory, Provider, State } from \"@ai16z/eliza\";\r\nimport {\r\n    DexScreenerData,\r\n    DexScreenerPair,\r\n    HolderData,\r\n    ProcessedTokenData,\r\n    TokenSecurityData,\r\n    TokenTradeData,\r\n    CalculatedBuyAmounts,\r\n    Prices,\r\n    TokenCodex,\r\n} from \"../types/token.ts\";\r\nimport NodeCache from \"node-cache\";\r\nimport * as path from \"path\";\r\nimport { toBN } from \"../bignumber.ts\";\r\nimport { WalletProvider, Item } from \"./wallet.ts\";\r\nimport { Connection, PublicKey } from \"@solana/web3.js\";\r\n\r\nconst PROVIDER_CONFIG = {\r\n    BIRDEYE_API: \"https://public-api.birdeye.so\",\r\n    MAX_RETRIES: 3,\r\n    RETRY_DELAY: 2000,\r\n    DEFAULT_RPC: \"https://api.mainnet-beta.solana.com\",\r\n    TOKEN_ADDRESSES: {\r\n        SOL: \"So11111111111111111111111111111111111111112\",\r\n        BTC: \"qfnqNqs3nCAHjnyCgLRDbBtq4p2MtHZxw8YjSyYhPoL\",\r\n        ETH: \"7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs\",\r\n        Example: \"2weMjPLLybRMMva1fM3U31goWWrCpF59CHWNhnCJ9Vyh\",\r\n    },\r\n    TOKEN_SECURITY_ENDPOINT: \"/defi/token_security?address=\",\r\n    TOKEN_TRADE_DATA_ENDPOINT: \"/defi/v3/token/trade-data/single?address=\",\r\n    DEX_SCREENER_API: \"https://api.dexscreener.com/latest/dex/tokens/\",\r\n    MAIN_WALLET: \"\",\r\n};\r\n\r\nexport class TokenProvider {\r\n    private cache: NodeCache;\r\n    private cacheKey: string = \"solana/tokens\";\r\n    private NETWORK_ID = 1399811149;\r\n    private GRAPHQL_ENDPOINT = \"https://graph.codex.io/graphql\";\r\n\r\n    constructor(\r\n        //  private connection: Connection,\r\n        private tokenAddress: string,\r\n        private walletProvider: WalletProvider,\r\n        private cacheManager: ICacheManager\r\n    ) {\r\n        this.cache = new NodeCache({ stdTTL: 300 }); // 5 minutes cache\r\n    }\r\n\r\n    private async readFromCache<T>(key: string): Promise<T | null> {\r\n        const cached = await this.cacheManager.get<T>(\r\n            path.join(this.cacheKey, key)\r\n        );\r\n        return cached;\r\n    }\r\n\r\n    private async writeToCache<T>(key: string, data: T): Promise<void> {\r\n        await this.cacheManager.set(path.join(this.cacheKey, key), data, {\r\n            expires: Date.now() + 5 * 60 * 1000,\r\n        });\r\n    }\r\n\r\n    private async getCachedData<T>(key: string): Promise<T | null> {\r\n        // Check in-memory cache first\r\n        const cachedData = this.cache.get<T>(key);\r\n        if (cachedData) {\r\n            return cachedData;\r\n        }\r\n\r\n        // Check file-based cache\r\n        const fileCachedData = await this.readFromCache<T>(key);\r\n        if (fileCachedData) {\r\n            // Populate in-memory cache\r\n            this.cache.set(key, fileCachedData);\r\n            return fileCachedData;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private async setCachedData<T>(cacheKey: string, data: T): Promise<void> {\r\n        // Set in-memory cache\r\n        this.cache.set(cacheKey, data);\r\n\r\n        // Write to file-based cache\r\n        await this.writeToCache(cacheKey, data);\r\n    }\r\n\r\n    private async fetchWithRetry(\r\n        url: string,\r\n        options: RequestInit = {}\r\n    ): Promise<any> {\r\n        let lastError: Error;\r\n\r\n        for (let i = 0; i < PROVIDER_CONFIG.MAX_RETRIES; i++) {\r\n            try {\r\n                const response = await fetch(url, {\r\n                    ...options,\r\n                    headers: {\r\n                        Accept: \"application/json\",\r\n                        \"x-chain\": \"solana\",\r\n                        \"X-API-KEY\": settings.BIRDEYE_API_KEY || \"\",\r\n                        ...options.headers,\r\n                    },\r\n                });\r\n\r\n                if (!response.ok) {\r\n                    const errorText = await response.text();\r\n                    throw new Error(\r\n                        `HTTP error! status: ${response.status}, message: ${errorText}`\r\n                    );\r\n                }\r\n\r\n                const data = await response.json();\r\n                return data;\r\n            } catch (error) {\r\n                console.error(`Attempt ${i + 1} failed:`, error);\r\n                lastError = error as Error;\r\n                if (i < PROVIDER_CONFIG.MAX_RETRIES - 1) {\r\n                    const delay = PROVIDER_CONFIG.RETRY_DELAY * Math.pow(2, i);\r\n                    console.log(`Waiting ${delay}ms before retrying...`);\r\n                    await new Promise((resolve) => setTimeout(resolve, delay));\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        console.error(\r\n            \"All attempts failed. Throwing the last error:\",\r\n            lastError\r\n        );\r\n        throw lastError;\r\n    }\r\n\r\n    async getTokensInWallet(runtime: IAgentRuntime): Promise<Item[]> {\r\n        const walletInfo =\r\n            await this.walletProvider.fetchPortfolioValue(runtime);\r\n        const items = walletInfo.items;\r\n        return items;\r\n    }\r\n\r\n    // check if the token symbol is in the wallet\r\n    async getTokenFromWallet(runtime: IAgentRuntime, tokenSymbol: string) {\r\n        try {\r\n            const items = await this.getTokensInWallet(runtime);\r\n            const token = items.find((item) => item.symbol === tokenSymbol);\r\n\r\n            if (token) {\r\n                return token.address;\r\n            } else {\r\n                return null;\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Error checking token in wallet:\", error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    async fetchTokenCodex(): Promise<TokenCodex> {\r\n        try {\r\n            const cacheKey = `token_${this.tokenAddress}`;\r\n            const cachedData = this.getCachedData<TokenCodex>(cacheKey);\r\n            if (cachedData) {\r\n                console.log(\r\n                    `Returning cached token data for ${this.tokenAddress}.`\r\n                );\r\n                return cachedData;\r\n            }\r\n            const query = `\r\n            query Token($address: String!, $networkId: Int!) {\r\n              token(input: { address: $address, networkId: $networkId }) {\r\n                id\r\n                address\r\n                cmcId\r\n                decimals\r\n                name\r\n                symbol\r\n                totalSupply\r\n                isScam\r\n                info {\r\n                  circulatingSupply\r\n                  imageThumbUrl\r\n                }\r\n                explorerData {\r\n                  blueCheckmark\r\n                  description\r\n                  tokenType\r\n                }\r\n              }\r\n            }\r\n          `;\r\n\r\n            const variables = {\r\n                address: this.tokenAddress,\r\n                networkId: this.NETWORK_ID, // Replace with your network ID\r\n            };\r\n\r\n            const response = await fetch(this.GRAPHQL_ENDPOINT, {\r\n                method: \"POST\",\r\n                headers: {\r\n                    \"Content-Type\": \"application/json\",\r\n                    Authorization: settings.CODEX_API_KEY,\r\n                },\r\n                body: JSON.stringify({\r\n                    query,\r\n                    variables,\r\n                }),\r\n            }).then((res) => res.json());\r\n\r\n            const token = response.data?.data?.token;\r\n\r\n            if (!token) {\r\n                throw new Error(`No data returned for token ${tokenAddress}`);\r\n            }\r\n\r\n            this.setCachedData(cacheKey, token);\r\n\r\n            return {\r\n                id: token.id,\r\n                address: token.address,\r\n                cmcId: token.cmcId,\r\n                decimals: token.decimals,\r\n                name: token.name,\r\n                symbol: token.symbol,\r\n                totalSupply: token.totalSupply,\r\n                circulatingSupply: token.info?.circulatingSupply,\r\n                imageThumbUrl: token.info?.imageThumbUrl,\r\n                blueCheckmark: token.explorerData?.blueCheckmark,\r\n                isScam: token.isScam ? true : false,\r\n            };\r\n        } catch (error) {\r\n            console.error(\r\n                \"Error fetching token data from Codex:\",\r\n                error.message\r\n            );\r\n            return {} as TokenCodex;\r\n        }\r\n    }\r\n\r\n    async fetchPrices(): Promise<Prices> {\r\n        try {\r\n            const cacheKey = \"prices\";\r\n            const cachedData = this.getCachedData<Prices>(cacheKey);\r\n            if (cachedData) {\r\n                console.log(\"Returning cached prices.\");\r\n                return cachedData;\r\n            }\r\n            const { SOL, BTC, ETH } = PROVIDER_CONFIG.TOKEN_ADDRESSES;\r\n            const tokens = [SOL, BTC, ETH];\r\n            const prices: Prices = {\r\n                solana: { usd: \"0\" },\r\n                bitcoin: { usd: \"0\" },\r\n                ethereum: { usd: \"0\" },\r\n            };\r\n\r\n            for (const token of tokens) {\r\n                const response = await this.fetchWithRetry(\r\n                    `${PROVIDER_CONFIG.BIRDEYE_API}/defi/price?address=${token}`,\r\n                    {\r\n                        headers: {\r\n                            \"x-chain\": \"solana\",\r\n                        },\r\n                    }\r\n                );\r\n\r\n                if (response?.data?.value) {\r\n                    const price = response.data.value.toString();\r\n                    prices[\r\n                        token === SOL\r\n                            ? \"solana\"\r\n                            : token === BTC\r\n                              ? \"bitcoin\"\r\n                              : \"ethereum\"\r\n                    ].usd = price;\r\n                } else {\r\n                    console.warn(`No price data available for token: ${token}`);\r\n                }\r\n            }\r\n            this.setCachedData(cacheKey, prices);\r\n            return prices;\r\n        } catch (error) {\r\n            console.error(\"Error fetching prices:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n    async calculateBuyAmounts(): Promise<CalculatedBuyAmounts> {\r\n        const dexScreenerData = await this.fetchDexScreenerData();\r\n        const prices = await this.fetchPrices();\r\n        const solPrice = toBN(prices.solana.usd);\r\n\r\n        if (!dexScreenerData || dexScreenerData.pairs.length === 0) {\r\n            return { none: 0, low: 0, medium: 0, high: 0 };\r\n        }\r\n\r\n        // Get the first pair\r\n        const pair = dexScreenerData.pairs[0];\r\n        const { liquidity, marketCap } = pair;\r\n        if (!liquidity || !marketCap) {\r\n            return { none: 0, low: 0, medium: 0, high: 0 };\r\n        }\r\n\r\n        if (liquidity.usd === 0) {\r\n            return { none: 0, low: 0, medium: 0, high: 0 };\r\n        }\r\n        if (marketCap < 100000) {\r\n            return { none: 0, low: 0, medium: 0, high: 0 };\r\n        }\r\n\r\n        // impact percentages based on liquidity\r\n        const impactPercentages = {\r\n            LOW: 0.01, // 1% of liquidity\r\n            MEDIUM: 0.05, // 5% of liquidity\r\n            HIGH: 0.1, // 10% of liquidity\r\n        };\r\n\r\n        // Calculate buy amounts in USD\r\n        const lowBuyAmountUSD = liquidity.usd * impactPercentages.LOW;\r\n        const mediumBuyAmountUSD = liquidity.usd * impactPercentages.MEDIUM;\r\n        const highBuyAmountUSD = liquidity.usd * impactPercentages.HIGH;\r\n\r\n        // Convert each buy amount to SOL\r\n        const lowBuyAmountSOL = toBN(lowBuyAmountUSD).div(solPrice).toNumber();\r\n        const mediumBuyAmountSOL = toBN(mediumBuyAmountUSD)\r\n            .div(solPrice)\r\n            .toNumber();\r\n        const highBuyAmountSOL = toBN(highBuyAmountUSD)\r\n            .div(solPrice)\r\n            .toNumber();\r\n\r\n        return {\r\n            none: 0,\r\n            low: lowBuyAmountSOL,\r\n            medium: mediumBuyAmountSOL,\r\n            high: highBuyAmountSOL,\r\n        };\r\n    }\r\n\r\n    async fetchTokenSecurity(): Promise<TokenSecurityData> {\r\n        const cacheKey = `tokenSecurity_${this.tokenAddress}`;\r\n        const cachedData = this.getCachedData<TokenSecurityData>(cacheKey);\r\n        if (cachedData) {\r\n            console.log(\r\n                `Returning cached token security data for ${this.tokenAddress}.`\r\n            );\r\n            return cachedData;\r\n        }\r\n        const url = `${PROVIDER_CONFIG.BIRDEYE_API}${PROVIDER_CONFIG.TOKEN_SECURITY_ENDPOINT}${this.tokenAddress}`;\r\n        const data = await this.fetchWithRetry(url);\r\n\r\n        if (!data?.success || !data?.data) {\r\n            throw new Error(\"No token security data available\");\r\n        }\r\n\r\n        const security: TokenSecurityData = {\r\n            ownerBalance: data.data.ownerBalance,\r\n            creatorBalance: data.data.creatorBalance,\r\n            ownerPercentage: data.data.ownerPercentage,\r\n            creatorPercentage: data.data.creatorPercentage,\r\n            top10HolderBalance: data.data.top10HolderBalance,\r\n            top10HolderPercent: data.data.top10HolderPercent,\r\n        };\r\n        this.setCachedData(cacheKey, security);\r\n        console.log(`Token security data cached for ${this.tokenAddress}.`);\r\n\r\n        return security;\r\n    }\r\n\r\n    async fetchTokenTradeData(): Promise<TokenTradeData> {\r\n        const cacheKey = `tokenTradeData_${this.tokenAddress}`;\r\n        const cachedData = this.getCachedData<TokenTradeData>(cacheKey);\r\n        if (cachedData) {\r\n            console.log(\r\n                `Returning cached token trade data for ${this.tokenAddress}.`\r\n            );\r\n            return cachedData;\r\n        }\r\n\r\n        const url = `${PROVIDER_CONFIG.BIRDEYE_API}${PROVIDER_CONFIG.TOKEN_TRADE_DATA_ENDPOINT}${this.tokenAddress}`;\r\n        const options = {\r\n            method: \"GET\",\r\n            headers: {\r\n                accept: \"application/json\",\r\n                \"X-API-KEY\": settings.BIRDEYE_API_KEY || \"\",\r\n            },\r\n        };\r\n\r\n        const data = await fetch(url, options)\r\n            .then((res) => res.json())\r\n            .catch((err) => console.error(err));\r\n\r\n        if (!data?.success || !data?.data) {\r\n            throw new Error(\"No token trade data available\");\r\n        }\r\n\r\n        const tradeData: TokenTradeData = {\r\n            address: data.data.address,\r\n            holder: data.data.holder,\r\n            market: data.data.market,\r\n            last_trade_unix_time: data.data.last_trade_unix_time,\r\n            last_trade_human_time: data.data.last_trade_human_time,\r\n            price: data.data.price,\r\n            history_30m_price: data.data.history_30m_price,\r\n            price_change_30m_percent: data.data.price_change_30m_percent,\r\n            history_1h_price: data.data.history_1h_price,\r\n            price_change_1h_percent: data.data.price_change_1h_percent,\r\n            history_2h_price: data.data.history_2h_price,\r\n            price_change_2h_percent: data.data.price_change_2h_percent,\r\n            history_4h_price: data.data.history_4h_price,\r\n            price_change_4h_percent: data.data.price_change_4h_percent,\r\n            history_6h_price: data.data.history_6h_price,\r\n            price_change_6h_percent: data.data.price_change_6h_percent,\r\n            history_8h_price: data.data.history_8h_price,\r\n            price_change_8h_percent: data.data.price_change_8h_percent,\r\n            history_12h_price: data.data.history_12h_price,\r\n            price_change_12h_percent: data.data.price_change_12h_percent,\r\n            history_24h_price: data.data.history_24h_price,\r\n            price_change_24h_percent: data.data.price_change_24h_percent,\r\n            unique_wallet_30m: data.data.unique_wallet_30m,\r\n            unique_wallet_history_30m: data.data.unique_wallet_history_30m,\r\n            unique_wallet_30m_change_percent:\r\n                data.data.unique_wallet_30m_change_percent,\r\n            unique_wallet_1h: data.data.unique_wallet_1h,\r\n            unique_wallet_history_1h: data.data.unique_wallet_history_1h,\r\n            unique_wallet_1h_change_percent:\r\n                data.data.unique_wallet_1h_change_percent,\r\n            unique_wallet_2h: data.data.unique_wallet_2h,\r\n            unique_wallet_history_2h: data.data.unique_wallet_history_2h,\r\n            unique_wallet_2h_change_percent:\r\n                data.data.unique_wallet_2h_change_percent,\r\n            unique_wallet_4h: data.data.unique_wallet_4h,\r\n            unique_wallet_history_4h: data.data.unique_wallet_history_4h,\r\n            unique_wallet_4h_change_percent:\r\n                data.data.unique_wallet_4h_change_percent,\r\n            unique_wallet_8h: data.data.unique_wallet_8h,\r\n            unique_wallet_history_8h: data.data.unique_wallet_history_8h,\r\n            unique_wallet_8h_change_percent:\r\n                data.data.unique_wallet_8h_change_percent,\r\n            unique_wallet_24h: data.data.unique_wallet_24h,\r\n            unique_wallet_history_24h: data.data.unique_wallet_history_24h,\r\n            unique_wallet_24h_change_percent:\r\n                data.data.unique_wallet_24h_change_percent,\r\n            trade_30m: data.data.trade_30m,\r\n            trade_history_30m: data.data.trade_history_30m,\r\n            trade_30m_change_percent: data.data.trade_30m_change_percent,\r\n            sell_30m: data.data.sell_30m,\r\n            sell_history_30m: data.data.sell_history_30m,\r\n            sell_30m_change_percent: data.data.sell_30m_change_percent,\r\n            buy_30m: data.data.buy_30m,\r\n            buy_history_30m: data.data.buy_history_30m,\r\n            buy_30m_change_percent: data.data.buy_30m_change_percent,\r\n            volume_30m: data.data.volume_30m,\r\n            volume_30m_usd: data.data.volume_30m_usd,\r\n            volume_history_30m: data.data.volume_history_30m,\r\n            volume_history_30m_usd: data.data.volume_history_30m_usd,\r\n            volume_30m_change_percent: data.data.volume_30m_change_percent,\r\n            volume_buy_30m: data.data.volume_buy_30m,\r\n            volume_buy_30m_usd: data.data.volume_buy_30m_usd,\r\n            volume_buy_history_30m: data.data.volume_buy_history_30m,\r\n            volume_buy_history_30m_usd: data.data.volume_buy_history_30m_usd,\r\n            volume_buy_30m_change_percent:\r\n                data.data.volume_buy_30m_change_percent,\r\n            volume_sell_30m: data.data.volume_sell_30m,\r\n            volume_sell_30m_usd: data.data.volume_sell_30m_usd,\r\n            volume_sell_history_30m: data.data.volume_sell_history_30m,\r\n            volume_sell_history_30m_usd: data.data.volume_sell_history_30m_usd,\r\n            volume_sell_30m_change_percent:\r\n                data.data.volume_sell_30m_change_percent,\r\n            trade_1h: data.data.trade_1h,\r\n            trade_history_1h: data.data.trade_history_1h,\r\n            trade_1h_change_percent: data.data.trade_1h_change_percent,\r\n            sell_1h: data.data.sell_1h,\r\n            sell_history_1h: data.data.sell_history_1h,\r\n            sell_1h_change_percent: data.data.sell_1h_change_percent,\r\n            buy_1h: data.data.buy_1h,\r\n            buy_history_1h: data.data.buy_history_1h,\r\n            buy_1h_change_percent: data.data.buy_1h_change_percent,\r\n            volume_1h: data.data.volume_1h,\r\n            volume_1h_usd: data.data.volume_1h_usd,\r\n            volume_history_1h: data.data.volume_history_1h,\r\n            volume_history_1h_usd: data.data.volume_history_1h_usd,\r\n            volume_1h_change_percent: data.data.volume_1h_change_percent,\r\n            volume_buy_1h: data.data.volume_buy_1h,\r\n            volume_buy_1h_usd: data.data.volume_buy_1h_usd,\r\n            volume_buy_history_1h: data.data.volume_buy_history_1h,\r\n            volume_buy_history_1h_usd: data.data.volume_buy_history_1h_usd,\r\n            volume_buy_1h_change_percent:\r\n                data.data.volume_buy_1h_change_percent,\r\n            volume_sell_1h: data.data.volume_sell_1h,\r\n            volume_sell_1h_usd: data.data.volume_sell_1h_usd,\r\n            volume_sell_history_1h: data.data.volume_sell_history_1h,\r\n            volume_sell_history_1h_usd: data.data.volume_sell_history_1h_usd,\r\n            volume_sell_1h_change_percent:\r\n                data.data.volume_sell_1h_change_percent,\r\n            trade_2h: data.data.trade_2h,\r\n            trade_history_2h: data.data.trade_history_2h,\r\n            trade_2h_change_percent: data.data.trade_2h_change_percent,\r\n            sell_2h: data.data.sell_2h,\r\n            sell_history_2h: data.data.sell_history_2h,\r\n            sell_2h_change_percent: data.data.sell_2h_change_percent,\r\n            buy_2h: data.data.buy_2h,\r\n            buy_history_2h: data.data.buy_history_2h,\r\n            buy_2h_change_percent: data.data.buy_2h_change_percent,\r\n            volume_2h: data.data.volume_2h,\r\n            volume_2h_usd: data.data.volume_2h_usd,\r\n            volume_history_2h: data.data.volume_history_2h,\r\n            volume_history_2h_usd: data.data.volume_history_2h_usd,\r\n            volume_2h_change_percent: data.data.volume_2h_change_percent,\r\n            volume_buy_2h: data.data.volume_buy_2h,\r\n            volume_buy_2h_usd: data.data.volume_buy_2h_usd,\r\n            volume_buy_history_2h: data.data.volume_buy_history_2h,\r\n            volume_buy_history_2h_usd: data.data.volume_buy_history_2h_usd,\r\n            volume_buy_2h_change_percent:\r\n                data.data.volume_buy_2h_change_percent,\r\n            volume_sell_2h: data.data.volume_sell_2h,\r\n            volume_sell_2h_usd: data.data.volume_sell_2h_usd,\r\n            volume_sell_history_2h: data.data.volume_sell_history_2h,\r\n            volume_sell_history_2h_usd: data.data.volume_sell_history_2h_usd,\r\n            volume_sell_2h_change_percent:\r\n                data.data.volume_sell_2h_change_percent,\r\n            trade_4h: data.data.trade_4h,\r\n            trade_history_4h: data.data.trade_history_4h,\r\n            trade_4h_change_percent: data.data.trade_4h_change_percent,\r\n            sell_4h: data.data.sell_4h,\r\n            sell_history_4h: data.data.sell_history_4h,\r\n            sell_4h_change_percent: data.data.sell_4h_change_percent,\r\n            buy_4h: data.data.buy_4h,\r\n            buy_history_4h: data.data.buy_history_4h,\r\n            buy_4h_change_percent: data.data.buy_4h_change_percent,\r\n            volume_4h: data.data.volume_4h,\r\n            volume_4h_usd: data.data.volume_4h_usd,\r\n            volume_history_4h: data.data.volume_history_4h,\r\n            volume_history_4h_usd: data.data.volume_history_4h_usd,\r\n            volume_4h_change_percent: data.data.volume_4h_change_percent,\r\n            volume_buy_4h: data.data.volume_buy_4h,\r\n            volume_buy_4h_usd: data.data.volume_buy_4h_usd,\r\n            volume_buy_history_4h: data.data.volume_buy_history_4h,\r\n            volume_buy_history_4h_usd: data.data.volume_buy_history_4h_usd,\r\n            volume_buy_4h_change_percent:\r\n                data.data.volume_buy_4h_change_percent,\r\n            volume_sell_4h: data.data.volume_sell_4h,\r\n            volume_sell_4h_usd: data.data.volume_sell_4h_usd,\r\n            volume_sell_history_4h: data.data.volume_sell_history_4h,\r\n            volume_sell_history_4h_usd: data.data.volume_sell_history_4h_usd,\r\n            volume_sell_4h_change_percent:\r\n                data.data.volume_sell_4h_change_percent,\r\n            trade_8h: data.data.trade_8h,\r\n            trade_history_8h: data.data.trade_history_8h,\r\n            trade_8h_change_percent: data.data.trade_8h_change_percent,\r\n            sell_8h: data.data.sell_8h,\r\n            sell_history_8h: data.data.sell_history_8h,\r\n            sell_8h_change_percent: data.data.sell_8h_change_percent,\r\n            buy_8h: data.data.buy_8h,\r\n            buy_history_8h: data.data.buy_history_8h,\r\n            buy_8h_change_percent: data.data.buy_8h_change_percent,\r\n            volume_8h: data.data.volume_8h,\r\n            volume_8h_usd: data.data.volume_8h_usd,\r\n            volume_history_8h: data.data.volume_history_8h,\r\n            volume_history_8h_usd: data.data.volume_history_8h_usd,\r\n            volume_8h_change_percent: data.data.volume_8h_change_percent,\r\n            volume_buy_8h: data.data.volume_buy_8h,\r\n            volume_buy_8h_usd: data.data.volume_buy_8h_usd,\r\n            volume_buy_history_8h: data.data.volume_buy_history_8h,\r\n            volume_buy_history_8h_usd: data.data.volume_buy_history_8h_usd,\r\n            volume_buy_8h_change_percent:\r\n                data.data.volume_buy_8h_change_percent,\r\n            volume_sell_8h: data.data.volume_sell_8h,\r\n            volume_sell_8h_usd: data.data.volume_sell_8h_usd,\r\n            volume_sell_history_8h: data.data.volume_sell_history_8h,\r\n            volume_sell_history_8h_usd: data.data.volume_sell_history_8h_usd,\r\n            volume_sell_8h_change_percent:\r\n                data.data.volume_sell_8h_change_percent,\r\n            trade_24h: data.data.trade_24h,\r\n            trade_history_24h: data.data.trade_history_24h,\r\n            trade_24h_change_percent: data.data.trade_24h_change_percent,\r\n            sell_24h: data.data.sell_24h,\r\n            sell_history_24h: data.data.sell_history_24h,\r\n            sell_24h_change_percent: data.data.sell_24h_change_percent,\r\n            buy_24h: data.data.buy_24h,\r\n            buy_history_24h: data.data.buy_history_24h,\r\n            buy_24h_change_percent: data.data.buy_24h_change_percent,\r\n            volume_24h: data.data.volume_24h,\r\n            volume_24h_usd: data.data.volume_24h_usd,\r\n            volume_history_24h: data.data.volume_history_24h,\r\n            volume_history_24h_usd: data.data.volume_history_24h_usd,\r\n            volume_24h_change_percent: data.data.volume_24h_change_percent,\r\n            volume_buy_24h: data.data.volume_buy_24h,\r\n            volume_buy_24h_usd: data.data.volume_buy_24h_usd,\r\n            volume_buy_history_24h: data.data.volume_buy_history_24h,\r\n            volume_buy_history_24h_usd: data.data.volume_buy_history_24h_usd,\r\n            volume_buy_24h_change_percent:\r\n                data.data.volume_buy_24h_change_percent,\r\n            volume_sell_24h: data.data.volume_sell_24h,\r\n            volume_sell_24h_usd: data.data.volume_sell_24h_usd,\r\n            volume_sell_history_24h: data.data.volume_sell_history_24h,\r\n            volume_sell_history_24h_usd: data.data.volume_sell_history_24h_usd,\r\n            volume_sell_24h_change_percent:\r\n                data.data.volume_sell_24h_change_percent,\r\n        };\r\n        this.setCachedData(cacheKey, tradeData);\r\n        return tradeData;\r\n    }\r\n\r\n    async fetchDexScreenerData(): Promise<DexScreenerData> {\r\n        const cacheKey = `dexScreenerData_${this.tokenAddress}`;\r\n        const cachedData = this.getCachedData<DexScreenerData>(cacheKey);\r\n        if (cachedData) {\r\n            console.log(\"Returning cached DexScreener data.\");\r\n            return cachedData;\r\n        }\r\n\r\n        const url = `https://api.dexscreener.com/latest/dex/search?q=${this.tokenAddress}`;\r\n        try {\r\n            console.log(\r\n                `Fetching DexScreener data for token: ${this.tokenAddress}`\r\n            );\r\n            const data = await fetch(url)\r\n                .then((res) => res.json())\r\n                .catch((err) => {\r\n                    console.error(err);\r\n                });\r\n\r\n            if (!data || !data.pairs) {\r\n                throw new Error(\"No DexScreener data available\");\r\n            }\r\n\r\n            const dexData: DexScreenerData = {\r\n                schemaVersion: data.schemaVersion,\r\n                pairs: data.pairs,\r\n            };\r\n\r\n            // Cache the result\r\n            this.setCachedData(cacheKey, dexData);\r\n\r\n            return dexData;\r\n        } catch (error) {\r\n            console.error(`Error fetching DexScreener data:`, error);\r\n            return {\r\n                schemaVersion: \"1.0.0\",\r\n                pairs: [],\r\n            };\r\n        }\r\n    }\r\n\r\n    async searchDexScreenerData(\r\n        symbol: string\r\n    ): Promise<DexScreenerPair | null> {\r\n        const cacheKey = `dexScreenerData_search_${symbol}`;\r\n        const cachedData = await this.getCachedData<DexScreenerData>(cacheKey);\r\n        if (cachedData) {\r\n            console.log(\"Returning cached search DexScreener data.\");\r\n            return this.getHighestLiquidityPair(cachedData);\r\n        }\r\n\r\n        const url = `https://api.dexscreener.com/latest/dex/search?q=${symbol}`;\r\n        try {\r\n            console.log(`Fetching DexScreener data for symbol: ${symbol}`);\r\n            const data = await fetch(url)\r\n                .then((res) => res.json())\r\n                .catch((err) => {\r\n                    console.error(err);\r\n                    return null;\r\n                });\r\n\r\n            if (!data || !data.pairs || data.pairs.length === 0) {\r\n                throw new Error(\"No DexScreener data available\");\r\n            }\r\n\r\n            const dexData: DexScreenerData = {\r\n                schemaVersion: data.schemaVersion,\r\n                pairs: data.pairs,\r\n            };\r\n\r\n            // Cache the result\r\n            this.setCachedData(cacheKey, dexData);\r\n\r\n            // Return the pair with the highest liquidity and market cap\r\n            return this.getHighestLiquidityPair(dexData);\r\n        } catch (error) {\r\n            console.error(`Error fetching DexScreener data:`, error);\r\n            return null;\r\n        }\r\n    }\r\n    getHighestLiquidityPair(dexData: DexScreenerData): DexScreenerPair | null {\r\n        if (dexData.pairs.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        // Sort pairs by both liquidity and market cap to get the highest one\r\n        return dexData.pairs.sort((a, b) => {\r\n            const liquidityDiff = b.liquidity.usd - a.liquidity.usd;\r\n            if (liquidityDiff !== 0) {\r\n                return liquidityDiff; // Higher liquidity comes first\r\n            }\r\n            return b.marketCap - a.marketCap; // If liquidity is equal, higher market cap comes first\r\n        })[0];\r\n    }\r\n\r\n    async analyzeHolderDistribution(\r\n        tradeData: TokenTradeData\r\n    ): Promise<string> {\r\n        // Define the time intervals to consider (e.g., 30m, 1h, 2h)\r\n        const intervals = [\r\n            {\r\n                period: \"30m\",\r\n                change: tradeData.unique_wallet_30m_change_percent,\r\n            },\r\n            { period: \"1h\", change: tradeData.unique_wallet_1h_change_percent },\r\n            { period: \"2h\", change: tradeData.unique_wallet_2h_change_percent },\r\n            { period: \"4h\", change: tradeData.unique_wallet_4h_change_percent },\r\n            { period: \"8h\", change: tradeData.unique_wallet_8h_change_percent },\r\n            {\r\n                period: \"24h\",\r\n                change: tradeData.unique_wallet_24h_change_percent,\r\n            },\r\n        ];\r\n\r\n        // Calculate the average change percentage\r\n        const validChanges = intervals\r\n            .map((interval) => interval.change)\r\n            .filter(\r\n                (change) => change !== null && change !== undefined\r\n            ) as number[];\r\n\r\n        if (validChanges.length === 0) {\r\n            return \"stable\";\r\n        }\r\n\r\n        const averageChange =\r\n            validChanges.reduce((acc, curr) => acc + curr, 0) /\r\n            validChanges.length;\r\n\r\n        const increaseThreshold = 10; // e.g., average change > 10%\r\n        const decreaseThreshold = -10; // e.g., average change < -10%\r\n\r\n        if (averageChange > increaseThreshold) {\r\n            return \"increasing\";\r\n        } else if (averageChange < decreaseThreshold) {\r\n            return \"decreasing\";\r\n        } else {\r\n            return \"stable\";\r\n        }\r\n    }\r\n\r\n    async fetchHolderList(): Promise<HolderData[]> {\r\n        const cacheKey = `holderList_${this.tokenAddress}`;\r\n        const cachedData = this.getCachedData<HolderData[]>(cacheKey);\r\n        if (cachedData) {\r\n            console.log(\"Returning cached holder list.\");\r\n            return cachedData;\r\n        }\r\n\r\n        const allHoldersMap = new Map<string, number>();\r\n        let page = 1;\r\n        const limit = 1000;\r\n        let cursor;\r\n        //HELIOUS_API_KEY needs to be added\r\n        const url = `https://mainnet.helius-rpc.com/?api-key=${settings.HELIUS_API_KEY || \"\"}`;\r\n        console.log({ url });\r\n\r\n        try {\r\n            while (true) {\r\n                const params = {\r\n                    limit: limit,\r\n                    displayOptions: {},\r\n                    mint: this.tokenAddress,\r\n                    cursor: cursor,\r\n                };\r\n                if (cursor != undefined) {\r\n                    params.cursor = cursor;\r\n                }\r\n                console.log(`Fetching holders - Page ${page}`);\r\n                if (page > 2) {\r\n                    break;\r\n                }\r\n                const response = await fetch(url, {\r\n                    method: \"POST\",\r\n                    headers: {\r\n                        \"Content-Type\": \"application/json\",\r\n                    },\r\n                    body: JSON.stringify({\r\n                        jsonrpc: \"2.0\",\r\n                        id: \"helius-test\",\r\n                        method: \"getTokenAccounts\",\r\n                        params: params,\r\n                    }),\r\n                });\r\n\r\n                const data = await response.json();\r\n\r\n                if (\r\n                    !data ||\r\n                    !data.result ||\r\n                    !data.result.token_accounts ||\r\n                    data.result.token_accounts.length === 0\r\n                ) {\r\n                    console.log(\r\n                        `No more holders found. Total pages fetched: ${page - 1}`\r\n                    );\r\n                    break;\r\n                }\r\n\r\n                console.log(\r\n                    `Processing ${data.result.token_accounts.length} holders from page ${page}`\r\n                );\r\n\r\n                data.result.token_accounts.forEach((account: any) => {\r\n                    const owner = account.owner;\r\n                    const balance = parseFloat(account.amount);\r\n\r\n                    if (allHoldersMap.has(owner)) {\r\n                        allHoldersMap.set(\r\n                            owner,\r\n                            allHoldersMap.get(owner)! + balance\r\n                        );\r\n                    } else {\r\n                        allHoldersMap.set(owner, balance);\r\n                    }\r\n                });\r\n                cursor = data.result.cursor;\r\n                page++;\r\n            }\r\n\r\n            const holders: HolderData[] = Array.from(\r\n                allHoldersMap.entries()\r\n            ).map(([address, balance]) => ({\r\n                address,\r\n                balance: balance.toString(),\r\n            }));\r\n\r\n            console.log(`Total unique holders fetched: ${holders.length}`);\r\n\r\n            // Cache the result\r\n            this.setCachedData(cacheKey, holders);\r\n\r\n            return holders;\r\n        } catch (error) {\r\n            console.error(\"Error fetching holder list from Helius:\", error);\r\n            throw new Error(\"Failed to fetch holder list from Helius.\");\r\n        }\r\n    }\r\n\r\n    async filterHighValueHolders(\r\n        tradeData: TokenTradeData\r\n    ): Promise<Array<{ holderAddress: string; balanceUsd: string }>> {\r\n        const holdersData = await this.fetchHolderList();\r\n\r\n        const tokenPriceUsd = toBN(tradeData.price);\r\n\r\n        const highValueHolders = holdersData\r\n            .filter((holder) => {\r\n                const balanceUsd = toBN(holder.balance).multipliedBy(\r\n                    tokenPriceUsd\r\n                );\r\n                return balanceUsd.isGreaterThan(5);\r\n            })\r\n            .map((holder) => ({\r\n                holderAddress: holder.address,\r\n                balanceUsd: toBN(holder.balance)\r\n                    .multipliedBy(tokenPriceUsd)\r\n                    .toFixed(2),\r\n            }));\r\n\r\n        return highValueHolders;\r\n    }\r\n\r\n    async checkRecentTrades(tradeData: TokenTradeData): Promise<boolean> {\r\n        return toBN(tradeData.volume_24h_usd).isGreaterThan(0);\r\n    }\r\n\r\n    async countHighSupplyHolders(\r\n        securityData: TokenSecurityData\r\n    ): Promise<number> {\r\n        try {\r\n            const ownerBalance = toBN(securityData.ownerBalance);\r\n            const totalSupply = ownerBalance.plus(securityData.creatorBalance);\r\n\r\n            const highSupplyHolders = await this.fetchHolderList();\r\n            const highSupplyHoldersCount = highSupplyHolders.filter(\r\n                (holder) => {\r\n                    const balance = toBN(holder.balance);\r\n                    return balance.dividedBy(totalSupply).isGreaterThan(0.02);\r\n                }\r\n            ).length;\r\n            return highSupplyHoldersCount;\r\n        } catch (error) {\r\n            console.error(\"Error counting high supply holders:\", error);\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    async getProcessedTokenData(): Promise<ProcessedTokenData> {\r\n        try {\r\n            console.log(\r\n                `Fetching security data for token: ${this.tokenAddress}`\r\n            );\r\n            const security = await this.fetchTokenSecurity();\r\n\r\n            const tokenCodex = await this.fetchTokenCodex();\r\n\r\n            console.log(`Fetching trade data for token: ${this.tokenAddress}`);\r\n            const tradeData = await this.fetchTokenTradeData();\r\n\r\n            console.log(\r\n                `Fetching DexScreener data for token: ${this.tokenAddress}`\r\n            );\r\n            const dexData = await this.fetchDexScreenerData();\r\n\r\n            console.log(\r\n                `Analyzing holder distribution for token: ${this.tokenAddress}`\r\n            );\r\n            const holderDistributionTrend =\r\n                await this.analyzeHolderDistribution(tradeData);\r\n\r\n            console.log(\r\n                `Filtering high-value holders for token: ${this.tokenAddress}`\r\n            );\r\n            const highValueHolders =\r\n                await this.filterHighValueHolders(tradeData);\r\n\r\n            console.log(\r\n                `Checking recent trades for token: ${this.tokenAddress}`\r\n            );\r\n            const recentTrades = await this.checkRecentTrades(tradeData);\r\n\r\n            console.log(\r\n                `Counting high-supply holders for token: ${this.tokenAddress}`\r\n            );\r\n            const highSupplyHoldersCount =\r\n                await this.countHighSupplyHolders(security);\r\n\r\n            console.log(\r\n                `Determining DexScreener listing status for token: ${this.tokenAddress}`\r\n            );\r\n            const isDexScreenerListed = dexData.pairs.length > 0;\r\n            const isDexScreenerPaid = dexData.pairs.some(\r\n                (pair) => pair.boosts && pair.boosts.active > 0\r\n            );\r\n\r\n            const processedData: ProcessedTokenData = {\r\n                security,\r\n                tradeData,\r\n                holderDistributionTrend,\r\n                highValueHolders,\r\n                recentTrades,\r\n                highSupplyHoldersCount,\r\n                dexScreenerData: dexData,\r\n                isDexScreenerListed,\r\n                isDexScreenerPaid,\r\n                tokenCodex,\r\n            };\r\n\r\n            // console.log(\"Processed token data:\", processedData);\r\n            return processedData;\r\n        } catch (error) {\r\n            console.error(\"Error processing token data:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async shouldTradeToken(): Promise<boolean> {\r\n        try {\r\n            const tokenData = await this.getProcessedTokenData();\r\n            const { tradeData, security, dexScreenerData } = tokenData;\r\n            const { ownerBalance, creatorBalance } = security;\r\n            const { liquidity, marketCap } = dexScreenerData.pairs[0];\r\n            const liquidityUsd = toBN(liquidity.usd);\r\n            const marketCapUsd = toBN(marketCap);\r\n            const totalSupply = toBN(ownerBalance).plus(creatorBalance);\r\n            const _ownerPercentage = toBN(ownerBalance).dividedBy(totalSupply);\r\n            const _creatorPercentage =\r\n                toBN(creatorBalance).dividedBy(totalSupply);\r\n            const top10HolderPercent = toBN(tradeData.volume_24h_usd).dividedBy(\r\n                totalSupply\r\n            );\r\n            const priceChange24hPercent = toBN(\r\n                tradeData.price_change_24h_percent\r\n            );\r\n            const priceChange12hPercent = toBN(\r\n                tradeData.price_change_12h_percent\r\n            );\r\n            const uniqueWallet24h = tradeData.unique_wallet_24h;\r\n            const volume24hUsd = toBN(tradeData.volume_24h_usd);\r\n            const volume24hUsdThreshold = 1000;\r\n            const priceChange24hPercentThreshold = 10;\r\n            const priceChange12hPercentThreshold = 5;\r\n            const top10HolderPercentThreshold = 0.05;\r\n            const uniqueWallet24hThreshold = 100;\r\n            const isTop10Holder = top10HolderPercent.gte(\r\n                top10HolderPercentThreshold\r\n            );\r\n            const isVolume24h = volume24hUsd.gte(volume24hUsdThreshold);\r\n            const isPriceChange24h = priceChange24hPercent.gte(\r\n                priceChange24hPercentThreshold\r\n            );\r\n            const isPriceChange12h = priceChange12hPercent.gte(\r\n                priceChange12hPercentThreshold\r\n            );\r\n            const isUniqueWallet24h =\r\n                uniqueWallet24h >= uniqueWallet24hThreshold;\r\n            const isLiquidityTooLow = liquidityUsd.lt(1000);\r\n            const isMarketCapTooLow = marketCapUsd.lt(100000);\r\n            return (\r\n                isTop10Holder ||\r\n                isVolume24h ||\r\n                isPriceChange24h ||\r\n                isPriceChange12h ||\r\n                isUniqueWallet24h ||\r\n                isLiquidityTooLow ||\r\n                isMarketCapTooLow\r\n            );\r\n        } catch (error) {\r\n            console.error(\"Error processing token data:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    formatTokenData(data: ProcessedTokenData): string {\r\n        let output = `**Token Security and Trade Report**\\n`;\r\n        output += `Token Address: ${this.tokenAddress}\\n\\n`;\r\n\r\n        // Security Data\r\n        output += `**Ownership Distribution:**\\n`;\r\n        output += `- Owner Balance: ${data.security.ownerBalance}\\n`;\r\n        output += `- Creator Balance: ${data.security.creatorBalance}\\n`;\r\n        output += `- Owner Percentage: ${data.security.ownerPercentage}%\\n`;\r\n        output += `- Creator Percentage: ${data.security.creatorPercentage}%\\n`;\r\n        output += `- Top 10 Holders Balance: ${data.security.top10HolderBalance}\\n`;\r\n        output += `- Top 10 Holders Percentage: ${data.security.top10HolderPercent}%\\n\\n`;\r\n\r\n        // Trade Data\r\n        output += `**Trade Data:**\\n`;\r\n        output += `- Holders: ${data.tradeData.holder}\\n`;\r\n        output += `- Unique Wallets (24h): ${data.tradeData.unique_wallet_24h}\\n`;\r\n        output += `- Price Change (24h): ${data.tradeData.price_change_24h_percent}%\\n`;\r\n        output += `- Price Change (12h): ${data.tradeData.price_change_12h_percent}%\\n`;\r\n        output += `- Volume (24h USD): $${toBN(data.tradeData.volume_24h_usd).toFixed(2)}\\n`;\r\n        output += `- Current Price: $${toBN(data.tradeData.price).toFixed(2)}\\n\\n`;\r\n\r\n        // Holder Distribution Trend\r\n        output += `**Holder Distribution Trend:** ${data.holderDistributionTrend}\\n\\n`;\r\n\r\n        // High-Value Holders\r\n        output += `**High-Value Holders (>$5 USD):**\\n`;\r\n        if (data.highValueHolders.length === 0) {\r\n            output += `- No high-value holders found or data not available.\\n`;\r\n        } else {\r\n            data.highValueHolders.forEach((holder) => {\r\n                output += `- ${holder.holderAddress}: $${holder.balanceUsd}\\n`;\r\n            });\r\n        }\r\n        output += `\\n`;\r\n\r\n        // Recent Trades\r\n        output += `**Recent Trades (Last 24h):** ${data.recentTrades ? \"Yes\" : \"No\"}\\n\\n`;\r\n\r\n        // High-Supply Holders\r\n        output += `**Holders with >2% Supply:** ${data.highSupplyHoldersCount}\\n\\n`;\r\n\r\n        // DexScreener Status\r\n        output += `**DexScreener Listing:** ${data.isDexScreenerListed ? \"Yes\" : \"No\"}\\n`;\r\n        if (data.isDexScreenerListed) {\r\n            output += `- Listing Type: ${data.isDexScreenerPaid ? \"Paid\" : \"Free\"}\\n`;\r\n            output += `- Number of DexPairs: ${data.dexScreenerData.pairs.length}\\n\\n`;\r\n            output += `**DexScreener Pairs:**\\n`;\r\n            data.dexScreenerData.pairs.forEach((pair, index) => {\r\n                output += `\\n**Pair ${index + 1}:**\\n`;\r\n                output += `- DEX: ${pair.dexId}\\n`;\r\n                output += `- URL: ${pair.url}\\n`;\r\n                output += `- Price USD: $${toBN(pair.priceUsd).toFixed(6)}\\n`;\r\n                output += `- Volume (24h USD): $${toBN(pair.volume.h24).toFixed(2)}\\n`;\r\n                output += `- Boosts Active: ${pair.boosts && pair.boosts.active}\\n`;\r\n                output += `- Liquidity USD: $${toBN(pair.liquidity.usd).toFixed(2)}\\n`;\r\n            });\r\n        }\r\n        output += `\\n`;\r\n\r\n        console.log(\"Formatted token data:\", output);\r\n        return output;\r\n    }\r\n\r\n    async getFormattedTokenReport(): Promise<string> {\r\n        try {\r\n            console.log(\"Generating formatted token report...\");\r\n            const processedData = await this.getProcessedTokenData();\r\n            return this.formatTokenData(processedData);\r\n        } catch (error) {\r\n            console.error(\"Error generating token report:\", error);\r\n            return \"Unable to fetch token information. Please try again later.\";\r\n        }\r\n    }\r\n}\r\n\r\nconst tokenAddress = PROVIDER_CONFIG.TOKEN_ADDRESSES.Example;\r\n\r\nconst connection = new Connection(PROVIDER_CONFIG.DEFAULT_RPC);\r\nconst tokenProvider: Provider = {\r\n    get: async (\r\n        runtime: IAgentRuntime,\r\n        _message: Memory,\r\n        _state?: State\r\n    ): Promise<string> => {\r\n        try {\r\n            const walletProvider = new WalletProvider(\r\n                connection,\r\n                new PublicKey(PROVIDER_CONFIG.MAIN_WALLET)\r\n            );\r\n\r\n            const provider = new TokenProvider(\r\n                tokenAddress,\r\n                walletProvider,\r\n                runtime.cacheManager\r\n            );\r\n\r\n            return provider.getFormattedTokenReport();\r\n        } catch (error) {\r\n            console.error(\"Error fetching token data:\", error);\r\n            return \"Unable to fetch token information. Please try again later.\";\r\n        }\r\n    },\r\n};\r\n\r\nexport { tokenProvider };\r\n","import BigNumber from \"bignumber.js\";\r\n\r\n// Re-export BigNumber constructor\r\nexport const BN = BigNumber;\r\n\r\n// Helper function to create new BigNumber instances\r\nexport function toBN(value: string | number | BigNumber): BigNumber {\r\n    return new BigNumber(value);\r\n}\r\n","import { IAgentRuntime, Memory, Provider, State } from \"@ai16z/eliza\";\r\nimport { Connection, PublicKey } from \"@solana/web3.js\";\r\nimport BigNumber from \"bignumber.js\";\r\nimport NodeCache from \"node-cache\";\r\n\r\n// Provider configuration\r\nconst PROVIDER_CONFIG = {\r\n    BIRDEYE_API: \"https://public-api.birdeye.so\",\r\n    MAX_RETRIES: 3,\r\n    RETRY_DELAY: 2000,\r\n    DEFAULT_RPC: \"https://api.mainnet-beta.solana.com\",\r\n    GRAPHQL_ENDPOINT: \"https://graph.codex.io/graphql\",\r\n    TOKEN_ADDRESSES: {\r\n        SOL: \"So11111111111111111111111111111111111111112\",\r\n        BTC: \"3NZ9JMVBmGAqocybic2c7LQCJScmgsAZ6vQqTDzcqmJh\",\r\n        ETH: \"7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs\",\r\n    },\r\n};\r\n\r\nexport interface Item {\r\n    name: string;\r\n    address: string;\r\n    symbol: string;\r\n    decimals: number;\r\n    balance: string;\r\n    uiAmount: string;\r\n    priceUsd: string;\r\n    valueUsd: string;\r\n    valueSol?: string;\r\n}\r\n\r\ninterface WalletPortfolio {\r\n    totalUsd: string;\r\n    totalSol?: string;\r\n    items: Array<Item>;\r\n}\r\n\r\ninterface _BirdEyePriceData {\r\n    data: {\r\n        [key: string]: {\r\n            price: number;\r\n            priceChange24h: number;\r\n        };\r\n    };\r\n}\r\n\r\ninterface Prices {\r\n    solana: { usd: string };\r\n    bitcoin: { usd: string };\r\n    ethereum: { usd: string };\r\n}\r\n\r\nexport class WalletProvider {\r\n    private cache: NodeCache;\r\n\r\n    constructor(\r\n        private connection: Connection,\r\n        private walletPublicKey: PublicKey\r\n    ) {\r\n        this.cache = new NodeCache({ stdTTL: 300 }); // Cache TTL set to 5 minutes\r\n    }\r\n\r\n    private async fetchWithRetry(\r\n        runtime,\r\n        url: string,\r\n        options: RequestInit = {}\r\n    ): Promise<any> {\r\n        let lastError: Error;\r\n\r\n        for (let i = 0; i < PROVIDER_CONFIG.MAX_RETRIES; i++) {\r\n            try {\r\n                const response = await fetch(url, {\r\n                    ...options,\r\n                    headers: {\r\n                        Accept: \"application/json\",\r\n                        \"x-chain\": \"solana\",\r\n                        \"X-API-KEY\":\r\n                            runtime.getSetting(\"BIRDEYE_API_KEY\", \"\") || \"\",\r\n                        ...options.headers,\r\n                    },\r\n                });\r\n\r\n                if (!response.ok) {\r\n                    const errorText = await response.text();\r\n                    throw new Error(\r\n                        `HTTP error! status: ${response.status}, message: ${errorText}`\r\n                    );\r\n                }\r\n\r\n                const data = await response.json();\r\n                return data;\r\n            } catch (error) {\r\n                console.error(`Attempt ${i + 1} failed:`, error);\r\n                lastError = error;\r\n                if (i < PROVIDER_CONFIG.MAX_RETRIES - 1) {\r\n                    const delay = PROVIDER_CONFIG.RETRY_DELAY * Math.pow(2, i);\r\n                    await new Promise((resolve) => setTimeout(resolve, delay));\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        console.error(\r\n            \"All attempts failed. Throwing the last error:\",\r\n            lastError\r\n        );\r\n        throw lastError;\r\n    }\r\n\r\n    async fetchPortfolioValue(runtime): Promise<WalletPortfolio> {\r\n        try {\r\n            const cacheKey = `portfolio-${this.walletPublicKey.toBase58()}`;\r\n            const cachedValue = this.cache.get<WalletPortfolio>(cacheKey);\r\n\r\n            if (cachedValue) {\r\n                console.log(\"Cache hit for fetchPortfolioValue\");\r\n                return cachedValue;\r\n            }\r\n            console.log(\"Cache miss for fetchPortfolioValue\");\r\n\r\n            const walletData = await this.fetchWithRetry(\r\n                runtime,\r\n                `${PROVIDER_CONFIG.BIRDEYE_API}/v1/wallet/token_list?wallet=${this.walletPublicKey.toBase58()}`\r\n            );\r\n\r\n            if (!walletData?.success || !walletData?.data) {\r\n                console.error(\"No portfolio data available\", walletData);\r\n                throw new Error(\"No portfolio data available\");\r\n            }\r\n\r\n            const data = walletData.data;\r\n            const totalUsd = new BigNumber(data.totalUsd.toString());\r\n            const prices = await this.fetchPrices(runtime);\r\n            const solPriceInUSD = new BigNumber(prices.solana.usd.toString());\r\n\r\n            const items = data.items.map((item: any) => ({\r\n                ...item,\r\n                valueSol: new BigNumber(item.valueUsd || 0)\r\n                    .div(solPriceInUSD)\r\n                    .toFixed(6),\r\n                name: item.name || \"Unknown\",\r\n                symbol: item.symbol || \"Unknown\",\r\n                priceUsd: item.priceUsd || \"0\",\r\n                valueUsd: item.valueUsd || \"0\",\r\n            }));\r\n\r\n            const totalSol = totalUsd.div(solPriceInUSD);\r\n            const portfolio = {\r\n                totalUsd: totalUsd.toString(),\r\n                totalSol: totalSol.toFixed(6),\r\n                items: items.sort((a, b) =>\r\n                    new BigNumber(b.valueUsd)\r\n                        .minus(new BigNumber(a.valueUsd))\r\n                        .toNumber()\r\n                ),\r\n            };\r\n            this.cache.set(cacheKey, portfolio);\r\n            return portfolio;\r\n        } catch (error) {\r\n            console.error(\"Error fetching portfolio:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async fetchPortfolioValueCodex(runtime): Promise<WalletPortfolio> {\r\n        try {\r\n            const cacheKey = `portfolio-${this.walletPublicKey.toBase58()}`;\r\n            const cachedValue = await this.cache.get<WalletPortfolio>(cacheKey);\r\n\r\n            if (cachedValue) {\r\n                console.log(\"Cache hit for fetchPortfolioValue\");\r\n                return cachedValue;\r\n            }\r\n            console.log(\"Cache miss for fetchPortfolioValue\");\r\n\r\n            const query = `\r\n              query Balances($walletId: String!, $cursor: String) {\r\n                balances(input: { walletId: $walletId, cursor: $cursor }) {\r\n                  cursor\r\n                  items {\r\n                    walletId\r\n                    tokenId\r\n                    balance\r\n                    shiftedBalance\r\n                  }\r\n                }\r\n              }\r\n            `;\r\n\r\n            const variables = {\r\n                walletId: `${this.walletPublicKey.toBase58()}:${1399811149}`,\r\n                cursor: null,\r\n            };\r\n\r\n            const response = await fetch(PROVIDER_CONFIG.GRAPHQL_ENDPOINT, {\r\n                method: \"POST\",\r\n                headers: {\r\n                    \"Content-Type\": \"application/json\",\r\n                    Authorization:\r\n                        runtime.getSetting(\"CODEX_API_KEY\", \"\") || \"\",\r\n                },\r\n                body: JSON.stringify({\r\n                    query,\r\n                    variables,\r\n                }),\r\n            }).then((res) => res.json());\r\n\r\n            const data = response.data?.data?.balances?.items;\r\n\r\n            if (!data || data.length === 0) {\r\n                console.error(\"No portfolio data available\", data);\r\n                throw new Error(\"No portfolio data available\");\r\n            }\r\n\r\n            // Fetch token prices\r\n            const prices = await this.fetchPrices(runtime);\r\n            const solPriceInUSD = new BigNumber(prices.solana.usd.toString());\r\n\r\n            // Reformat items\r\n            const items: Item[] = data.map((item: any) => {\r\n                return {\r\n                    name: \"Unknown\",\r\n                    address: item.tokenId.split(\":\")[0],\r\n                    symbol: item.tokenId.split(\":\")[0],\r\n                    decimals: 6,\r\n                    balance: item.balance,\r\n                    uiAmount: item.shiftedBalance.toString(),\r\n                    priceUsd: \"\",\r\n                    valueUsd: \"\",\r\n                    valueSol: \"\",\r\n                };\r\n            });\r\n\r\n            // Calculate total portfolio value\r\n            const totalUsd = items.reduce(\r\n                (sum, item) => sum.plus(new BigNumber(item.valueUsd)),\r\n                new BigNumber(0)\r\n            );\r\n\r\n            const totalSol = totalUsd.div(solPriceInUSD);\r\n\r\n            const portfolio: WalletPortfolio = {\r\n                totalUsd: totalUsd.toFixed(6),\r\n                totalSol: totalSol.toFixed(6),\r\n                items: items.sort((a, b) =>\r\n                    new BigNumber(b.valueUsd)\r\n                        .minus(new BigNumber(a.valueUsd))\r\n                        .toNumber()\r\n                ),\r\n            };\r\n\r\n            // Cache the portfolio for future requests\r\n            await this.cache.set(cacheKey, portfolio, 60 * 1000); // Cache for 1 minute\r\n\r\n            return portfolio;\r\n        } catch (error) {\r\n            console.error(\"Error fetching portfolio:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async fetchPrices(runtime): Promise<Prices> {\r\n        try {\r\n            const cacheKey = \"prices\";\r\n            const cachedValue = this.cache.get<Prices>(cacheKey);\r\n\r\n            if (cachedValue) {\r\n                console.log(\"Cache hit for fetchPrices\");\r\n                return cachedValue;\r\n            }\r\n            console.log(\"Cache miss for fetchPrices\");\r\n\r\n            const { SOL, BTC, ETH } = PROVIDER_CONFIG.TOKEN_ADDRESSES;\r\n            const tokens = [SOL, BTC, ETH];\r\n            const prices: Prices = {\r\n                solana: { usd: \"0\" },\r\n                bitcoin: { usd: \"0\" },\r\n                ethereum: { usd: \"0\" },\r\n            };\r\n\r\n            for (const token of tokens) {\r\n                const response = await this.fetchWithRetry(\r\n                    runtime,\r\n                    `${PROVIDER_CONFIG.BIRDEYE_API}/defi/price?address=${token}`,\r\n                    {\r\n                        headers: {\r\n                            \"x-chain\": \"solana\",\r\n                        },\r\n                    }\r\n                );\r\n\r\n                if (response?.data?.value) {\r\n                    const price = response.data.value.toString();\r\n                    prices[\r\n                        token === SOL\r\n                            ? \"solana\"\r\n                            : token === BTC\r\n                              ? \"bitcoin\"\r\n                              : \"ethereum\"\r\n                    ].usd = price;\r\n                } else {\r\n                    console.warn(`No price data available for token: ${token}`);\r\n                }\r\n            }\r\n\r\n            this.cache.set(cacheKey, prices);\r\n            return prices;\r\n        } catch (error) {\r\n            console.error(\"Error fetching prices:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    formatPortfolio(\r\n        runtime,\r\n        portfolio: WalletPortfolio,\r\n        prices: Prices\r\n    ): string {\r\n        let output = `${runtime.character.description}\\n`;\r\n        output += `Wallet Address: ${this.walletPublicKey.toBase58()}\\n\\n`;\r\n\r\n        const totalUsdFormatted = new BigNumber(portfolio.totalUsd).toFixed(2);\r\n        const totalSolFormatted = portfolio.totalSol;\r\n\r\n        output += `Total Value: $${totalUsdFormatted} (${totalSolFormatted} SOL)\\n\\n`;\r\n        output += \"Token Balances:\\n\";\r\n\r\n        const nonZeroItems = portfolio.items.filter((item) =>\r\n            new BigNumber(item.uiAmount).isGreaterThan(0)\r\n        );\r\n\r\n        if (nonZeroItems.length === 0) {\r\n            output += \"No tokens found with non-zero balance\\n\";\r\n        } else {\r\n            for (const item of nonZeroItems) {\r\n                const valueUsd = new BigNumber(item.valueUsd).toFixed(2);\r\n                output += `${item.name} (${item.symbol}): ${new BigNumber(\r\n                    item.uiAmount\r\n                ).toFixed(6)} ($${valueUsd} | ${item.valueSol} SOL)\\n`;\r\n            }\r\n        }\r\n\r\n        output += \"\\nMarket Prices:\\n\";\r\n        output += `SOL: $${new BigNumber(prices.solana.usd).toFixed(2)}\\n`;\r\n        output += `BTC: $${new BigNumber(prices.bitcoin.usd).toFixed(2)}\\n`;\r\n        output += `ETH: $${new BigNumber(prices.ethereum.usd).toFixed(2)}\\n`;\r\n\r\n        return output;\r\n    }\r\n\r\n    async getFormattedPortfolio(runtime): Promise<string> {\r\n        try {\r\n            const [portfolio, prices] = await Promise.all([\r\n                this.fetchPortfolioValue(runtime),\r\n                this.fetchPrices(runtime),\r\n            ]);\r\n\r\n            return this.formatPortfolio(runtime, portfolio, prices);\r\n        } catch (error) {\r\n            console.error(\"Error generating portfolio report:\", error);\r\n            return \"Unable to fetch wallet information. Please try again later.\";\r\n        }\r\n    }\r\n}\r\n\r\nconst walletProvider: Provider = {\r\n    get: async (\r\n        runtime: IAgentRuntime,\r\n        _message: Memory,\r\n        _state?: State\r\n    ): Promise<string | null> => {\r\n        try {\r\n            const publicKey = runtime.getSetting(\"SOLANA_PUBLIC_KEY\");\r\n            if (!publicKey) {\r\n                console.error(\r\n                    \"SOLANA_PUBLIC_KEY not configured, skipping wallet injection\"\r\n                );\r\n                return \"\";\r\n            }\r\n\r\n            const connection = new Connection(\r\n                runtime.getSetting(\"RPC_URL\") || PROVIDER_CONFIG.DEFAULT_RPC\r\n            );\r\n\r\n            const provider = new WalletProvider(\r\n                connection,\r\n                new PublicKey(publicKey)\r\n            );\r\n\r\n            return await provider.getFormattedPortfolio(runtime);\r\n        } catch (error) {\r\n            console.error(\"Error in wallet provider:\", error);\r\n            return null;\r\n        }\r\n    },\r\n};\r\n\r\n// Module exports\r\nexport { walletProvider };\r\n","import {\r\n    ProcessedTokenData,\r\n    TokenSecurityData,\r\n    // TokenTradeData,\r\n    // DexScreenerData,\r\n    // DexScreenerPair,\r\n    // HolderData,\r\n} from \"../types/token.ts\";\r\nimport { Connection, PublicKey } from \"@solana/web3.js\";\r\nimport { getAssociatedTokenAddress } from \"@solana/spl-token\";\r\nimport { TokenProvider } from \"./token.ts\";\r\nimport { WalletProvider } from \"./wallet.ts\";\r\nimport { SimulationSellingService } from \"./simulationSellingService.ts\";\r\nimport {\r\n    TrustScoreDatabase,\r\n    RecommenderMetrics,\r\n    TokenPerformance,\r\n    TradePerformance,\r\n    TokenRecommendation,\r\n} from \"@ai16z/plugin-trustdb\";\r\nimport { settings } from \"@ai16z/eliza\";\r\nimport { IAgentRuntime, Memory, Provider, State } from \"@ai16z/eliza\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\n\r\nconst Wallet = settings.MAIN_WALLET_ADDRESS;\r\ninterface TradeData {\r\n    buy_amount: number;\r\n    is_simulation: boolean;\r\n}\r\ninterface sellDetails {\r\n    sell_amount: number;\r\n    sell_recommender_id: string | null;\r\n}\r\ninterface _RecommendationGroup {\r\n    recommendation: any;\r\n    trustScore: number;\r\n}\r\n\r\ninterface RecommenderData {\r\n    recommenderId: string;\r\n    trustScore: number;\r\n    riskScore: number;\r\n    consistencyScore: number;\r\n    recommenderMetrics: RecommenderMetrics;\r\n}\r\n\r\ninterface TokenRecommendationSummary {\r\n    tokenAddress: string;\r\n    averageTrustScore: number;\r\n    averageRiskScore: number;\r\n    averageConsistencyScore: number;\r\n    recommenders: RecommenderData[];\r\n}\r\nexport class TrustScoreManager {\r\n    private tokenProvider: TokenProvider;\r\n    private trustScoreDb: TrustScoreDatabase;\r\n    private simulationSellingService: SimulationSellingService;\r\n    private connection: Connection;\r\n    private baseMint: PublicKey;\r\n    private DECAY_RATE = 0.95;\r\n    private MAX_DECAY_DAYS = 30;\r\n    private backend;\r\n    private backendToken;\r\n    constructor(\r\n        runtime: IAgentRuntime,\r\n        tokenProvider: TokenProvider,\r\n        trustScoreDb: TrustScoreDatabase\r\n    ) {\r\n        this.tokenProvider = tokenProvider;\r\n        this.trustScoreDb = trustScoreDb;\r\n        this.connection = new Connection(runtime.getSetting(\"RPC_URL\"));\r\n        this.baseMint = new PublicKey(\r\n            runtime.getSetting(\"BASE_MINT\") ||\r\n                \"So11111111111111111111111111111111111111112\"\r\n        );\r\n        this.backend = runtime.getSetting(\"BACKEND_URL\");\r\n        this.backendToken = runtime.getSetting(\"BACKEND_TOKEN\");\r\n        this.simulationSellingService = new SimulationSellingService(\r\n            runtime,\r\n            this.trustScoreDb\r\n        );\r\n    }\r\n\r\n    //getRecommenederBalance\r\n    async getRecommenederBalance(recommenderWallet: string): Promise<number> {\r\n        try {\r\n            const tokenAta = await getAssociatedTokenAddress(\r\n                new PublicKey(recommenderWallet),\r\n                this.baseMint\r\n            );\r\n            const tokenBalInfo =\r\n                await this.connection.getTokenAccountBalance(tokenAta);\r\n            const tokenBalance = tokenBalInfo.value.amount;\r\n            const balance = parseFloat(tokenBalance);\r\n            return balance;\r\n        } catch (error) {\r\n            console.error(\"Error fetching balance\", error);\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates and saves trust score based on processed token data and user recommendations.\r\n     * @param tokenAddress The address of the token to analyze.\r\n     * @param recommenderId The UUID of the recommender.\r\n     * @returns An object containing TokenPerformance and RecommenderMetrics.\r\n     */\r\n    async generateTrustScore(\r\n        tokenAddress: string,\r\n        recommenderId: string,\r\n        recommenderWallet: string\r\n    ): Promise<{\r\n        tokenPerformance: TokenPerformance;\r\n        recommenderMetrics: RecommenderMetrics;\r\n    }> {\r\n        const processedData: ProcessedTokenData =\r\n            await this.tokenProvider.getProcessedTokenData();\r\n        console.log(`Fetched processed token data for token: ${tokenAddress}`);\r\n\r\n        const recommenderMetrics =\r\n            await this.trustScoreDb.getRecommenderMetrics(recommenderId);\r\n\r\n        const isRapidDump = await this.isRapidDump(tokenAddress);\r\n        const sustainedGrowth = await this.sustainedGrowth(tokenAddress);\r\n        const suspiciousVolume = await this.suspiciousVolume(tokenAddress);\r\n        const balance = await this.getRecommenederBalance(recommenderWallet);\r\n        const virtualConfidence = balance / 1000000; // TODO: create formula to calculate virtual confidence based on user balance\r\n        const lastActive = recommenderMetrics.lastActiveDate;\r\n        const now = new Date();\r\n        const inactiveDays = Math.floor(\r\n            (now.getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24)\r\n        );\r\n        const decayFactor = Math.pow(\r\n            this.DECAY_RATE,\r\n            Math.min(inactiveDays, this.MAX_DECAY_DAYS)\r\n        );\r\n        const decayedScore = recommenderMetrics.trustScore * decayFactor;\r\n        const validationTrustScore =\r\n            this.trustScoreDb.calculateValidationTrust(tokenAddress);\r\n\r\n        return {\r\n            tokenPerformance: {\r\n                tokenAddress:\r\n                    processedData.dexScreenerData.pairs[0]?.baseToken.address ||\r\n                    \"\",\r\n                priceChange24h:\r\n                    processedData.tradeData.price_change_24h_percent,\r\n                volumeChange24h: processedData.tradeData.volume_24h,\r\n                trade_24h_change:\r\n                    processedData.tradeData.trade_24h_change_percent,\r\n                liquidity:\r\n                    processedData.dexScreenerData.pairs[0]?.liquidity.usd || 0,\r\n                liquidityChange24h: 0,\r\n                holderChange24h:\r\n                    processedData.tradeData.unique_wallet_24h_change_percent,\r\n                rugPull: false,\r\n                isScam: processedData.tokenCodex.isScam,\r\n                marketCapChange24h: 0,\r\n                sustainedGrowth: sustainedGrowth,\r\n                rapidDump: isRapidDump,\r\n                suspiciousVolume: suspiciousVolume,\r\n                validationTrust: validationTrustScore,\r\n                balance: balance,\r\n                initialMarketCap:\r\n                    processedData.dexScreenerData.pairs[0]?.marketCap || 0,\r\n                lastUpdated: new Date(),\r\n                symbol: \"\",\r\n            },\r\n            recommenderMetrics: {\r\n                recommenderId: recommenderId,\r\n                trustScore: recommenderMetrics.trustScore,\r\n                totalRecommendations: recommenderMetrics.totalRecommendations,\r\n                successfulRecs: recommenderMetrics.successfulRecs,\r\n                avgTokenPerformance: recommenderMetrics.avgTokenPerformance,\r\n                riskScore: recommenderMetrics.riskScore,\r\n                consistencyScore: recommenderMetrics.consistencyScore,\r\n                virtualConfidence: virtualConfidence,\r\n                lastActiveDate: now,\r\n                trustDecay: decayedScore,\r\n                lastUpdated: new Date(),\r\n            },\r\n        };\r\n    }\r\n\r\n    async updateRecommenderMetrics(\r\n        recommenderId: string,\r\n        tokenPerformance: TokenPerformance,\r\n        recommenderWallet: string\r\n    ): Promise<void> {\r\n        const recommenderMetrics =\r\n            await this.trustScoreDb.getRecommenderMetrics(recommenderId);\r\n\r\n        const totalRecommendations =\r\n            recommenderMetrics.totalRecommendations + 1;\r\n        const successfulRecs = tokenPerformance.rugPull\r\n            ? recommenderMetrics.successfulRecs\r\n            : recommenderMetrics.successfulRecs + 1;\r\n        const avgTokenPerformance =\r\n            (recommenderMetrics.avgTokenPerformance *\r\n                recommenderMetrics.totalRecommendations +\r\n                tokenPerformance.priceChange24h) /\r\n            totalRecommendations;\r\n\r\n        const overallTrustScore = this.calculateTrustScore(\r\n            tokenPerformance,\r\n            recommenderMetrics\r\n        );\r\n        const riskScore = this.calculateOverallRiskScore(\r\n            tokenPerformance,\r\n            recommenderMetrics\r\n        );\r\n        const consistencyScore = this.calculateConsistencyScore(\r\n            tokenPerformance,\r\n            recommenderMetrics\r\n        );\r\n\r\n        const balance = await this.getRecommenederBalance(recommenderWallet);\r\n        const virtualConfidence = balance / 1000000; // TODO: create formula to calculate virtual confidence based on user balance\r\n        const lastActive = recommenderMetrics.lastActiveDate;\r\n        const now = new Date();\r\n        const inactiveDays = Math.floor(\r\n            (now.getTime() - lastActive.getTime()) / (1000 * 60 * 60 * 24)\r\n        );\r\n        const decayFactor = Math.pow(\r\n            this.DECAY_RATE,\r\n            Math.min(inactiveDays, this.MAX_DECAY_DAYS)\r\n        );\r\n        const decayedScore = recommenderMetrics.trustScore * decayFactor;\r\n\r\n        const newRecommenderMetrics: RecommenderMetrics = {\r\n            recommenderId: recommenderId,\r\n            trustScore: overallTrustScore,\r\n            totalRecommendations: totalRecommendations,\r\n            successfulRecs: successfulRecs,\r\n            avgTokenPerformance: avgTokenPerformance,\r\n            riskScore: riskScore,\r\n            consistencyScore: consistencyScore,\r\n            virtualConfidence: virtualConfidence,\r\n            lastActiveDate: new Date(),\r\n            trustDecay: decayedScore,\r\n            lastUpdated: new Date(),\r\n        };\r\n\r\n        await this.trustScoreDb.updateRecommenderMetrics(newRecommenderMetrics);\r\n    }\r\n\r\n    calculateTrustScore(\r\n        tokenPerformance: TokenPerformance,\r\n        recommenderMetrics: RecommenderMetrics\r\n    ): number {\r\n        const riskScore = this.calculateRiskScore(tokenPerformance);\r\n        const consistencyScore = this.calculateConsistencyScore(\r\n            tokenPerformance,\r\n            recommenderMetrics\r\n        );\r\n\r\n        return (riskScore + consistencyScore) / 2;\r\n    }\r\n\r\n    calculateOverallRiskScore(\r\n        tokenPerformance: TokenPerformance,\r\n        recommenderMetrics: RecommenderMetrics\r\n    ) {\r\n        const riskScore = this.calculateRiskScore(tokenPerformance);\r\n        const consistencyScore = this.calculateConsistencyScore(\r\n            tokenPerformance,\r\n            recommenderMetrics\r\n        );\r\n\r\n        return (riskScore + consistencyScore) / 2;\r\n    }\r\n\r\n    calculateRiskScore(tokenPerformance: TokenPerformance): number {\r\n        let riskScore = 0;\r\n        if (tokenPerformance.rugPull) {\r\n            riskScore += 10;\r\n        }\r\n        if (tokenPerformance.isScam) {\r\n            riskScore += 10;\r\n        }\r\n        if (tokenPerformance.rapidDump) {\r\n            riskScore += 5;\r\n        }\r\n        if (tokenPerformance.suspiciousVolume) {\r\n            riskScore += 5;\r\n        }\r\n        return riskScore;\r\n    }\r\n\r\n    calculateConsistencyScore(\r\n        tokenPerformance: TokenPerformance,\r\n        recommenderMetrics: RecommenderMetrics\r\n    ): number {\r\n        const avgTokenPerformance = recommenderMetrics.avgTokenPerformance;\r\n        const priceChange24h = tokenPerformance.priceChange24h;\r\n\r\n        return Math.abs(priceChange24h - avgTokenPerformance);\r\n    }\r\n\r\n    async suspiciousVolume(tokenAddress: string): Promise<boolean> {\r\n        const processedData: ProcessedTokenData =\r\n            await this.tokenProvider.getProcessedTokenData();\r\n        const unique_wallet_24h = processedData.tradeData.unique_wallet_24h;\r\n        const volume_24h = processedData.tradeData.volume_24h;\r\n        const suspiciousVolume = unique_wallet_24h / volume_24h > 0.5;\r\n        console.log(`Fetched processed token data for token: ${tokenAddress}`);\r\n        return suspiciousVolume;\r\n    }\r\n\r\n    async sustainedGrowth(tokenAddress: string): Promise<boolean> {\r\n        const processedData: ProcessedTokenData =\r\n            await this.tokenProvider.getProcessedTokenData();\r\n        console.log(`Fetched processed token data for token: ${tokenAddress}`);\r\n\r\n        return processedData.tradeData.volume_24h_change_percent > 50;\r\n    }\r\n\r\n    async isRapidDump(tokenAddress: string): Promise<boolean> {\r\n        const processedData: ProcessedTokenData =\r\n            await this.tokenProvider.getProcessedTokenData();\r\n        console.log(`Fetched processed token data for token: ${tokenAddress}`);\r\n\r\n        return processedData.tradeData.trade_24h_change_percent < -50;\r\n    }\r\n\r\n    async checkTrustScore(tokenAddress: string): Promise<TokenSecurityData> {\r\n        const processedData: ProcessedTokenData =\r\n            await this.tokenProvider.getProcessedTokenData();\r\n        console.log(`Fetched processed token data for token: ${tokenAddress}`);\r\n\r\n        return {\r\n            ownerBalance: processedData.security.ownerBalance,\r\n            creatorBalance: processedData.security.creatorBalance,\r\n            ownerPercentage: processedData.security.ownerPercentage,\r\n            creatorPercentage: processedData.security.creatorPercentage,\r\n            top10HolderBalance: processedData.security.top10HolderBalance,\r\n            top10HolderPercent: processedData.security.top10HolderPercent,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates a TradePerformance object based on token data and recommender.\r\n     * @param tokenAddress The address of the token.\r\n     * @param recommenderId The UUID of the recommender.\r\n     * @param data ProcessedTokenData.\r\n     * @returns TradePerformance object.\r\n     */\r\n    async createTradePerformance(\r\n        runtime: IAgentRuntime,\r\n        tokenAddress: string,\r\n        recommenderId: string,\r\n        data: TradeData\r\n    ): Promise<TradePerformance> {\r\n        const recommender =\r\n            await this.trustScoreDb.getOrCreateRecommenderWithTelegramId(\r\n                recommenderId\r\n            );\r\n        const processedData: ProcessedTokenData =\r\n            await this.tokenProvider.getProcessedTokenData();\r\n        const wallet = new WalletProvider(\r\n            this.connection,\r\n            new PublicKey(Wallet!)\r\n        );\r\n\r\n        let tokensBalance = 0;\r\n        const prices = await wallet.fetchPrices(runtime);\r\n        const solPrice = prices.solana.usd;\r\n        const buySol = data.buy_amount / parseFloat(solPrice);\r\n        const buy_value_usd = data.buy_amount * processedData.tradeData.price;\r\n        const token = await this.tokenProvider.fetchTokenTradeData();\r\n        const tokenCodex = await this.tokenProvider.fetchTokenCodex();\r\n        const tokenPrice = token.price;\r\n        tokensBalance = buy_value_usd / tokenPrice;\r\n\r\n        const creationData = {\r\n            token_address: tokenAddress,\r\n            recommender_id: recommender.id,\r\n            buy_price: processedData.tradeData.price,\r\n            sell_price: 0,\r\n            buy_timeStamp: new Date().toISOString(),\r\n            sell_timeStamp: \"\",\r\n            buy_amount: data.buy_amount,\r\n            sell_amount: 0,\r\n            buy_sol: buySol,\r\n            received_sol: 0,\r\n            buy_value_usd: buy_value_usd,\r\n            sell_value_usd: 0,\r\n            profit_usd: 0,\r\n            profit_percent: 0,\r\n            buy_market_cap:\r\n                processedData.dexScreenerData.pairs[0]?.marketCap || 0,\r\n            sell_market_cap: 0,\r\n            market_cap_change: 0,\r\n            buy_liquidity:\r\n                processedData.dexScreenerData.pairs[0]?.liquidity.usd || 0,\r\n            sell_liquidity: 0,\r\n            liquidity_change: 0,\r\n            last_updated: new Date().toISOString(),\r\n            rapidDump: false,\r\n        };\r\n        this.trustScoreDb.addTradePerformance(creationData, data.is_simulation);\r\n        // generate unique uuid for each TokenRecommendation\r\n        const tokenUUId = uuidv4();\r\n        const tokenRecommendation: TokenRecommendation = {\r\n            id: tokenUUId,\r\n            recommenderId: recommenderId,\r\n            tokenAddress: tokenAddress,\r\n            timestamp: new Date(),\r\n            initialMarketCap:\r\n                processedData.dexScreenerData.pairs[0]?.marketCap || 0,\r\n            initialLiquidity:\r\n                processedData.dexScreenerData.pairs[0]?.liquidity?.usd || 0,\r\n            initialPrice: processedData.tradeData.price,\r\n        };\r\n        this.trustScoreDb.addTokenRecommendation(tokenRecommendation);\r\n\r\n        this.trustScoreDb.upsertTokenPerformance({\r\n            tokenAddress: tokenAddress,\r\n            symbol: processedData.tokenCodex.symbol,\r\n            priceChange24h: processedData.tradeData.price_change_24h_percent,\r\n            volumeChange24h: processedData.tradeData.volume_24h,\r\n            trade_24h_change: processedData.tradeData.trade_24h_change_percent,\r\n            liquidity:\r\n                processedData.dexScreenerData.pairs[0]?.liquidity.usd || 0,\r\n            liquidityChange24h: 0,\r\n            holderChange24h:\r\n                processedData.tradeData.unique_wallet_24h_change_percent,\r\n            rugPull: false,\r\n            isScam: tokenCodex.isScam,\r\n            marketCapChange24h: 0,\r\n            sustainedGrowth: false,\r\n            rapidDump: false,\r\n            suspiciousVolume: false,\r\n            validationTrust: 0,\r\n            balance: tokensBalance,\r\n            initialMarketCap:\r\n                processedData.dexScreenerData.pairs[0]?.marketCap || 0,\r\n            lastUpdated: new Date(),\r\n        });\r\n\r\n        if (data.is_simulation) {\r\n            // If the trade is a simulation update the balance\r\n            this.trustScoreDb.updateTokenBalance(tokenAddress, tokensBalance);\r\n            // generate some random hash for simulations\r\n            const hash = Math.random().toString(36).substring(7);\r\n            const transaction = {\r\n                tokenAddress: tokenAddress,\r\n                type: \"buy\" as \"buy\" | \"sell\",\r\n                transactionHash: hash,\r\n                amount: data.buy_amount,\r\n                price: processedData.tradeData.price,\r\n                isSimulation: true,\r\n                timestamp: new Date().toISOString(),\r\n            };\r\n            this.trustScoreDb.addTransaction(transaction);\r\n        }\r\n        this.simulationSellingService.processTokenPerformance(\r\n            tokenAddress,\r\n            recommenderId\r\n        );\r\n        // api call to update trade performance\r\n        this.createTradeInBe(tokenAddress, recommenderId, data);\r\n        return creationData;\r\n    }\r\n\r\n    async delay(ms: number) {\r\n        return new Promise((resolve) => setTimeout(resolve, ms));\r\n    }\r\n\r\n    async createTradeInBe(\r\n        tokenAddress: string,\r\n        recommenderId: string,\r\n        data: TradeData,\r\n        retries = 3,\r\n        delayMs = 2000\r\n    ) {\r\n        for (let attempt = 1; attempt <= retries; attempt++) {\r\n            try {\r\n                await fetch(\r\n                    `${this.backend}/api/updaters/createTradePerformance`,\r\n                    {\r\n                        method: \"POST\",\r\n                        headers: {\r\n                            \"Content-Type\": \"application/json\",\r\n                            Authorization: `Bearer ${this.backendToken}`,\r\n                        },\r\n                        body: JSON.stringify({\r\n                            tokenAddress: tokenAddress,\r\n                            tradeData: data,\r\n                            recommenderId: recommenderId,\r\n                        }),\r\n                    }\r\n                );\r\n                // If the request is successful, exit the loop\r\n                return;\r\n            } catch (error) {\r\n                console.error(\r\n                    `Attempt ${attempt} failed: Error creating trade in backend`,\r\n                    error\r\n                );\r\n                if (attempt < retries) {\r\n                    console.log(`Retrying in ${delayMs} ms...`);\r\n                    await this.delay(delayMs); // Wait for the specified delay before retrying\r\n                } else {\r\n                    console.error(\"All attempts failed.\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates a trade with sell details.\r\n     * @param tokenAddress The address of the token.\r\n     * @param recommenderId The UUID of the recommender.\r\n     * @param buyTimeStamp The timestamp when the buy occurred.\r\n     * @param sellDetails An object containing sell-related details.\r\n     * @param isSimulation Whether the trade is a simulation. If true, updates in simulation_trade; otherwise, in trade.\r\n     * @returns boolean indicating success.\r\n     */\r\n\r\n    async updateSellDetails(\r\n        runtime: IAgentRuntime,\r\n        tokenAddress: string,\r\n        recommenderId: string,\r\n        sellTimeStamp: string,\r\n        sellDetails: sellDetails,\r\n        isSimulation: boolean\r\n    ) {\r\n        const recommender =\r\n            await this.trustScoreDb.getOrCreateRecommenderWithTelegramId(\r\n                recommenderId\r\n            );\r\n        const processedData: ProcessedTokenData =\r\n            await this.tokenProvider.getProcessedTokenData();\r\n        const wallet = new WalletProvider(\r\n            this.connection,\r\n            new PublicKey(Wallet!)\r\n        );\r\n        const prices = await wallet.fetchPrices(runtime);\r\n        const solPrice = prices.solana.usd;\r\n        const sellSol = sellDetails.sell_amount / parseFloat(solPrice);\r\n        const sell_value_usd =\r\n            sellDetails.sell_amount * processedData.tradeData.price;\r\n        const trade = await this.trustScoreDb.getLatestTradePerformance(\r\n            tokenAddress,\r\n            recommender.id,\r\n            isSimulation\r\n        );\r\n        const buyTimeStamp = trade.buy_timeStamp;\r\n        const marketCap =\r\n            processedData.dexScreenerData.pairs[0]?.marketCap || 0;\r\n        const liquidity =\r\n            processedData.dexScreenerData.pairs[0]?.liquidity.usd || 0;\r\n        const sell_price = processedData.tradeData.price;\r\n        const profit_usd = sell_value_usd - trade.buy_value_usd;\r\n        const profit_percent = (profit_usd / trade.buy_value_usd) * 100;\r\n\r\n        const market_cap_change = marketCap - trade.buy_market_cap;\r\n        const liquidity_change = liquidity - trade.buy_liquidity;\r\n\r\n        const isRapidDump = await this.isRapidDump(tokenAddress);\r\n\r\n        const sellDetailsData = {\r\n            sell_price: sell_price,\r\n            sell_timeStamp: sellTimeStamp,\r\n            sell_amount: sellDetails.sell_amount,\r\n            received_sol: sellSol,\r\n            sell_value_usd: sell_value_usd,\r\n            profit_usd: profit_usd,\r\n            profit_percent: profit_percent,\r\n            sell_market_cap: marketCap,\r\n            market_cap_change: market_cap_change,\r\n            sell_liquidity: liquidity,\r\n            liquidity_change: liquidity_change,\r\n            rapidDump: isRapidDump,\r\n            sell_recommender_id: sellDetails.sell_recommender_id || null,\r\n        };\r\n        this.trustScoreDb.updateTradePerformanceOnSell(\r\n            tokenAddress,\r\n            recommender.id,\r\n            buyTimeStamp,\r\n            sellDetailsData,\r\n            isSimulation\r\n        );\r\n        if (isSimulation) {\r\n            // If the trade is a simulation update the balance\r\n            const oldBalance = this.trustScoreDb.getTokenBalance(tokenAddress);\r\n            const tokenBalance = oldBalance - sellDetails.sell_amount;\r\n            this.trustScoreDb.updateTokenBalance(tokenAddress, tokenBalance);\r\n            // generate some random hash for simulations\r\n            const hash = Math.random().toString(36).substring(7);\r\n            const transaction = {\r\n                tokenAddress: tokenAddress,\r\n                type: \"sell\" as \"buy\" | \"sell\",\r\n                transactionHash: hash,\r\n                amount: sellDetails.sell_amount,\r\n                price: processedData.tradeData.price,\r\n                isSimulation: true,\r\n                timestamp: new Date().toISOString(),\r\n            };\r\n            this.trustScoreDb.addTransaction(transaction);\r\n        }\r\n\r\n        return sellDetailsData;\r\n    }\r\n\r\n    // get all recommendations\r\n    async getRecommendations(\r\n        startDate: Date,\r\n        endDate: Date\r\n    ): Promise<Array<TokenRecommendationSummary>> {\r\n        const recommendations = this.trustScoreDb.getRecommendationsByDateRange(\r\n            startDate,\r\n            endDate\r\n        );\r\n\r\n        // Group recommendations by tokenAddress\r\n        const groupedRecommendations = recommendations.reduce(\r\n            (acc, recommendation) => {\r\n                const { tokenAddress } = recommendation;\r\n                if (!acc[tokenAddress]) acc[tokenAddress] = [];\r\n                acc[tokenAddress].push(recommendation);\r\n                return acc;\r\n            },\r\n            {} as Record<string, Array<TokenRecommendation>>\r\n        );\r\n\r\n        const result = Object.keys(groupedRecommendations).map(\r\n            (tokenAddress) => {\r\n                const tokenRecommendations =\r\n                    groupedRecommendations[tokenAddress];\r\n\r\n                // Initialize variables to compute averages\r\n                let totalTrustScore = 0;\r\n                let totalRiskScore = 0;\r\n                let totalConsistencyScore = 0;\r\n                const recommenderData = [];\r\n\r\n                tokenRecommendations.forEach((recommendation) => {\r\n                    const tokenPerformance =\r\n                        this.trustScoreDb.getTokenPerformance(\r\n                            recommendation.tokenAddress\r\n                        );\r\n                    const recommenderMetrics =\r\n                        this.trustScoreDb.getRecommenderMetrics(\r\n                            recommendation.recommenderId\r\n                        );\r\n\r\n                    const trustScore = this.calculateTrustScore(\r\n                        tokenPerformance,\r\n                        recommenderMetrics\r\n                    );\r\n                    const consistencyScore = this.calculateConsistencyScore(\r\n                        tokenPerformance,\r\n                        recommenderMetrics\r\n                    );\r\n                    const riskScore = this.calculateRiskScore(tokenPerformance);\r\n\r\n                    // Accumulate scores for averaging\r\n                    totalTrustScore += trustScore;\r\n                    totalRiskScore += riskScore;\r\n                    totalConsistencyScore += consistencyScore;\r\n\r\n                    recommenderData.push({\r\n                        recommenderId: recommendation.recommenderId,\r\n                        trustScore,\r\n                        riskScore,\r\n                        consistencyScore,\r\n                        recommenderMetrics,\r\n                    });\r\n                });\r\n\r\n                // Calculate averages for this token\r\n                const averageTrustScore =\r\n                    totalTrustScore / tokenRecommendations.length;\r\n                const averageRiskScore =\r\n                    totalRiskScore / tokenRecommendations.length;\r\n                const averageConsistencyScore =\r\n                    totalConsistencyScore / tokenRecommendations.length;\r\n\r\n                return {\r\n                    tokenAddress,\r\n                    averageTrustScore,\r\n                    averageRiskScore,\r\n                    averageConsistencyScore,\r\n                    recommenders: recommenderData,\r\n                };\r\n            }\r\n        );\r\n\r\n        // Sort recommendations by the highest average trust score\r\n        result.sort((a, b) => b.averageTrustScore - a.averageTrustScore);\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nexport const trustScoreProvider: Provider = {\r\n    async get(\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        _state?: State\r\n    ): Promise<string> {\r\n        try {\r\n            const trustScoreDb = new TrustScoreDatabase(\r\n                runtime.databaseAdapter.db\r\n            );\r\n\r\n            // Get the user ID from the message\r\n            const userId = message.userId;\r\n\r\n            if (!userId) {\r\n                console.error(\"User ID is missing from the message\");\r\n                return \"\";\r\n            }\r\n\r\n            // Get the recommender metrics for the user\r\n            const recommenderMetrics =\r\n                await trustScoreDb.getRecommenderMetrics(userId);\r\n\r\n            if (!recommenderMetrics) {\r\n                console.error(\"No recommender metrics found for user:\", userId);\r\n                return \"\";\r\n            }\r\n\r\n            // Compute the trust score\r\n            const trustScore = recommenderMetrics.trustScore;\r\n\r\n            const user = await runtime.databaseAdapter.getAccountById(userId);\r\n\r\n            // Format the trust score string\r\n            const trustScoreString = `${user.name}'s trust score: ${trustScore.toFixed(2)}`;\r\n\r\n            return trustScoreString;\r\n        } catch (error) {\r\n            console.error(\"Error in trust score provider:\", error.message);\r\n            return `Failed to fetch trust score: ${error instanceof Error ? error.message : \"Unknown error\"}`;\r\n        }\r\n    },\r\n};\r\n","import {\r\n    TrustScoreDatabase,\r\n    TokenPerformance,\r\n    // TradePerformance,\r\n    TokenRecommendation,\r\n} from \"@ai16z/plugin-trustdb\";\r\nimport { Connection, PublicKey } from \"@solana/web3.js\";\r\n// Assuming TokenProvider and IAgentRuntime are available\r\nimport { TokenProvider } from \"./token.ts\";\r\n// import { settings } from \"@ai16z/eliza\";\r\nimport { IAgentRuntime } from \"@ai16z/eliza\";\r\nimport { WalletProvider } from \"./wallet.ts\";\r\nimport * as amqp from \"amqplib\";\r\nimport { ProcessedTokenData } from \"../types/token.ts\";\r\n\r\ninterface SellDetails {\r\n    sell_amount: number;\r\n    sell_recommender_id: string | null;\r\n}\r\n\r\nexport class SimulationSellingService {\r\n    private trustScoreDb: TrustScoreDatabase;\r\n    private walletProvider: WalletProvider;\r\n    private connection: Connection;\r\n    private baseMint: PublicKey;\r\n    private DECAY_RATE = 0.95;\r\n    private MAX_DECAY_DAYS = 30;\r\n    private backend: string;\r\n    private backendToken: string;\r\n    private amqpConnection: amqp.Connection;\r\n    private amqpChannel: amqp.Channel;\r\n    private sonarBe: string;\r\n    private sonarBeToken: string;\r\n    private runtime: IAgentRuntime;\r\n\r\n    private runningProcesses: Set<string> = new Set();\r\n\r\n    constructor(runtime: IAgentRuntime, trustScoreDb: TrustScoreDatabase) {\r\n        this.trustScoreDb = trustScoreDb;\r\n\r\n        this.connection = new Connection(runtime.getSetting(\"RPC_URL\"));\r\n        this.walletProvider = new WalletProvider(\r\n            this.connection,\r\n            new PublicKey(\r\n                runtime.getSetting(\"SOLANA_PUBLIC_KEY\") ??\r\n                    runtime.getSetting(\"WALLET_PUBLIC_KEY\")\r\n            )\r\n        );\r\n        this.baseMint = new PublicKey(\r\n            runtime.getSetting(\"BASE_MINT\") ||\r\n                \"So11111111111111111111111111111111111111112\"\r\n        );\r\n        this.backend = runtime.getSetting(\"BACKEND_URL\");\r\n        this.backendToken = runtime.getSetting(\"BACKEND_TOKEN\");\r\n        this.initializeRabbitMQ(runtime.getSetting(\"AMQP_URL\"));\r\n        this.sonarBe = runtime.getSetting(\"SONAR_BE\");\r\n        this.sonarBeToken = runtime.getSetting(\"SONAR_BE_TOKEN\");\r\n        this.runtime = runtime;\r\n    }\r\n    /**\r\n     * Initializes the RabbitMQ connection and starts consuming messages.\r\n     * @param amqpUrl The RabbitMQ server URL.\r\n     */\r\n    private async initializeRabbitMQ(amqpUrl: string) {\r\n        try {\r\n            this.amqpConnection = await amqp.connect(amqpUrl);\r\n            this.amqpChannel = await this.amqpConnection.createChannel();\r\n            console.log(\"Connected to RabbitMQ\");\r\n            // Start consuming messages\r\n            this.consumeMessages();\r\n        } catch (error) {\r\n            console.error(\"Failed to connect to RabbitMQ:\", error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets up the consumer for the specified RabbitMQ queue.\r\n     */\r\n    private async consumeMessages() {\r\n        const queue = \"process_eliza_simulation\";\r\n        await this.amqpChannel.assertQueue(queue, { durable: true });\r\n        this.amqpChannel.consume(\r\n            queue,\r\n            (msg) => {\r\n                if (msg !== null) {\r\n                    const content = msg.content.toString();\r\n                    this.processMessage(content);\r\n                    this.amqpChannel.ack(msg);\r\n                }\r\n            },\r\n            { noAck: false }\r\n        );\r\n        console.log(`Listening for messages on queue: ${queue}`);\r\n    }\r\n\r\n    /**\r\n     * Processes incoming messages from RabbitMQ.\r\n     * @param message The message content as a string.\r\n     */\r\n    private async processMessage(message: string) {\r\n        try {\r\n            const { tokenAddress, amount, sell_recommender_id } =\r\n                JSON.parse(message);\r\n            console.log(\r\n                `Received message for token ${tokenAddress} to sell ${amount}`\r\n            );\r\n\r\n            const decision: SellDecision = {\r\n                tokenPerformance:\r\n                    await this.trustScoreDb.getTokenPerformance(tokenAddress),\r\n                amountToSell: amount,\r\n                sell_recommender_id: sell_recommender_id,\r\n            };\r\n\r\n            // Execute the sell\r\n            await this.executeSellDecision(decision);\r\n\r\n            // Remove from running processes after completion\r\n            this.runningProcesses.delete(tokenAddress);\r\n        } catch (error) {\r\n            console.error(\"Error processing message:\", error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Executes a single sell decision.\r\n     * @param decision The sell decision containing token performance and amount to sell.\r\n     */\r\n    private async executeSellDecision(decision: SellDecision) {\r\n        const { tokenPerformance, amountToSell, sell_recommender_id } =\r\n            decision;\r\n        const tokenAddress = tokenPerformance.tokenAddress;\r\n\r\n        try {\r\n            console.log(\r\n                `Executing sell for token ${tokenPerformance.symbol}: ${amountToSell}`\r\n            );\r\n\r\n            // Update the sell details\r\n            const sellDetails: SellDetails = {\r\n                sell_amount: amountToSell,\r\n                sell_recommender_id: sell_recommender_id, // Adjust if necessary\r\n            };\r\n            const sellTimeStamp = new Date().toISOString();\r\n            const tokenProvider = new TokenProvider(\r\n                tokenAddress,\r\n                this.walletProvider,\r\n                this.runtime.cacheManager\r\n            );\r\n\r\n            // Update sell details in the database\r\n            const sellDetailsData = await this.updateSellDetails(\r\n                tokenAddress,\r\n                sell_recommender_id,\r\n                sellTimeStamp,\r\n                sellDetails,\r\n                true, // isSimulation\r\n                tokenProvider\r\n            );\r\n\r\n            console.log(\"Sell order executed successfully\", sellDetailsData);\r\n\r\n            // check if balance is zero and remove token from running processes\r\n            const balance = this.trustScoreDb.getTokenBalance(tokenAddress);\r\n            if (balance === 0) {\r\n                this.runningProcesses.delete(tokenAddress);\r\n            }\r\n            // stop the process in the sonar backend\r\n            await this.stopProcessInTheSonarBackend(tokenAddress);\r\n        } catch (error) {\r\n            console.error(\r\n                `Error executing sell for token ${tokenAddress}:`,\r\n                error\r\n            );\r\n        }\r\n    }\r\n\r\n    public async startService() {\r\n        // starting the service\r\n        console.log(\"Starting SellingService...\");\r\n        await this.startListeners();\r\n    }\r\n\r\n    public async startListeners() {\r\n        // scanning recommendations and selling\r\n        console.log(\"Scanning for token performances...\");\r\n        const tokenPerformances =\r\n            await this.trustScoreDb.getAllTokenPerformancesWithBalance();\r\n\r\n        await this.processTokenPerformances(tokenPerformances);\r\n    }\r\n\r\n    private processTokenPerformances(tokenPerformances: TokenPerformance[]) {\r\n        //  To Do: logic when to sell and how much\r\n        console.log(\"Deciding when to sell and how much...\");\r\n        const runningProcesses = this.runningProcesses;\r\n        // remove running processes from tokenPerformances\r\n        tokenPerformances = tokenPerformances.filter(\r\n            (tp) => !runningProcesses.has(tp.tokenAddress)\r\n        );\r\n\r\n        // start the process in the sonar backend\r\n        tokenPerformances.forEach(async (tokenPerformance) => {\r\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n            const tokenProvider = new TokenProvider(\r\n                tokenPerformance.tokenAddress,\r\n                this.walletProvider,\r\n                this.runtime.cacheManager\r\n            );\r\n            // const shouldTrade = await tokenProvider.shouldTradeToken();\r\n            // if (shouldTrade) {\r\n            const tokenRecommendations: TokenRecommendation[] =\r\n                this.trustScoreDb.getRecommendationsByToken(\r\n                    tokenPerformance.tokenAddress\r\n                );\r\n            const tokenRecommendation: TokenRecommendation =\r\n                tokenRecommendations[0];\r\n            const balance = tokenPerformance.balance;\r\n            const sell_recommender_id = tokenRecommendation.recommenderId;\r\n            const tokenAddress = tokenPerformance.tokenAddress;\r\n            const process = await this.startProcessInTheSonarBackend(\r\n                tokenAddress,\r\n                balance,\r\n                true,\r\n                sell_recommender_id,\r\n                tokenPerformance.initialMarketCap\r\n            );\r\n            if (process) {\r\n                this.runningProcesses.add(tokenAddress);\r\n            }\r\n            // }\r\n        });\r\n    }\r\n\r\n    public processTokenPerformance(\r\n        tokenAddress: string,\r\n        recommenderId: string\r\n    ) {\r\n        try {\r\n            const runningProcesses = this.runningProcesses;\r\n            // check if token is already being processed\r\n            if (runningProcesses.has(tokenAddress)) {\r\n                console.log(`Token ${tokenAddress} is already being processed`);\r\n                return;\r\n            }\r\n            const tokenPerformance =\r\n                this.trustScoreDb.getTokenPerformance(tokenAddress);\r\n\r\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n            const tokenProvider = new TokenProvider(\r\n                tokenPerformance.tokenAddress,\r\n                this.walletProvider,\r\n                this.runtime.cacheManager\r\n            );\r\n            const balance = tokenPerformance.balance;\r\n            const sell_recommender_id = recommenderId;\r\n            const process = this.startProcessInTheSonarBackend(\r\n                tokenAddress,\r\n                balance,\r\n                true,\r\n                sell_recommender_id,\r\n                tokenPerformance.initialMarketCap\r\n            );\r\n            if (process) {\r\n                this.runningProcesses.add(tokenAddress);\r\n            }\r\n        } catch (error) {\r\n            console.error(\r\n                `Error getting token performance for token ${tokenAddress}:`,\r\n                error\r\n            );\r\n        }\r\n    }\r\n\r\n    private async startProcessInTheSonarBackend(\r\n        tokenAddress: string,\r\n        balance: number,\r\n        isSimulation: boolean,\r\n        sell_recommender_id: string,\r\n        initial_mc: number\r\n    ) {\r\n        try {\r\n            const message = JSON.stringify({\r\n                tokenAddress,\r\n                balance,\r\n                isSimulation,\r\n                initial_mc,\r\n                sell_recommender_id,\r\n            });\r\n            const response = await fetch(\r\n                `${this.sonarBe}/ai16z-sol/startProcess`,\r\n                {\r\n                    method: \"POST\",\r\n                    headers: {\r\n                        \"Content-Type\": \"application/json\",\r\n                        \"x-api-key\": `${this.sonarBeToken}`,\r\n                    },\r\n                    body: message,\r\n                }\r\n            );\r\n\r\n            if (!response.ok) {\r\n                console.error(\r\n                    `Failed to send message to process token ${tokenAddress}`\r\n                );\r\n                return;\r\n            }\r\n\r\n            const result = await response.json();\r\n            console.log(\"Received response:\", result);\r\n            console.log(`Sent message to process token ${tokenAddress}`);\r\n\r\n            return result;\r\n        } catch (error) {\r\n            console.error(\r\n                `Error sending message to process token ${tokenAddress}:`,\r\n                error\r\n            );\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private stopProcessInTheSonarBackend(tokenAddress: string) {\r\n        try {\r\n            return fetch(`${this.sonarBe}/ai16z-sol/stopProcess`, {\r\n                method: \"POST\",\r\n                headers: {\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"x-api-key\": `${this.sonarBeToken}`,\r\n                },\r\n                body: JSON.stringify({ tokenAddress }),\r\n            });\r\n        } catch (error) {\r\n            console.error(\r\n                `Error stopping process for token ${tokenAddress}:`,\r\n                error\r\n            );\r\n        }\r\n    }\r\n\r\n    async updateSellDetails(\r\n        tokenAddress: string,\r\n        recommenderId: string,\r\n        sellTimeStamp: string,\r\n        sellDetails: SellDetails,\r\n        isSimulation: boolean,\r\n        tokenProvider: TokenProvider\r\n    ) {\r\n        const recommender =\r\n            await this.trustScoreDb.getOrCreateRecommenderWithTelegramId(\r\n                recommenderId\r\n            );\r\n        const processedData: ProcessedTokenData =\r\n            await tokenProvider.getProcessedTokenData();\r\n        const prices = await this.walletProvider.fetchPrices(null);\r\n        const solPrice = prices.solana.usd;\r\n        const sellSol = sellDetails.sell_amount / parseFloat(solPrice);\r\n        const sell_value_usd =\r\n            sellDetails.sell_amount * processedData.tradeData.price;\r\n        const trade = await this.trustScoreDb.getLatestTradePerformance(\r\n            tokenAddress,\r\n            recommender.id,\r\n            isSimulation\r\n        );\r\n        const buyTimeStamp = trade.buy_timeStamp;\r\n        const marketCap =\r\n            processedData.dexScreenerData.pairs[0]?.marketCap || 0;\r\n        const liquidity =\r\n            processedData.dexScreenerData.pairs[0]?.liquidity.usd || 0;\r\n        const sell_price = processedData.tradeData.price;\r\n        const profit_usd = sell_value_usd - trade.buy_value_usd;\r\n        const profit_percent = (profit_usd / trade.buy_value_usd) * 100;\r\n\r\n        const market_cap_change = marketCap - trade.buy_market_cap;\r\n        const liquidity_change = liquidity - trade.buy_liquidity;\r\n\r\n        const isRapidDump = await this.isRapidDump(tokenAddress, tokenProvider);\r\n\r\n        const sellDetailsData = {\r\n            sell_price: sell_price,\r\n            sell_timeStamp: sellTimeStamp,\r\n            sell_amount: sellDetails.sell_amount,\r\n            received_sol: sellSol,\r\n            sell_value_usd: sell_value_usd,\r\n            profit_usd: profit_usd,\r\n            profit_percent: profit_percent,\r\n            sell_market_cap: marketCap,\r\n            market_cap_change: market_cap_change,\r\n            sell_liquidity: liquidity,\r\n            liquidity_change: liquidity_change,\r\n            rapidDump: isRapidDump,\r\n            sell_recommender_id: sellDetails.sell_recommender_id || null,\r\n        };\r\n        this.trustScoreDb.updateTradePerformanceOnSell(\r\n            tokenAddress,\r\n            recommender.id,\r\n            buyTimeStamp,\r\n            sellDetailsData,\r\n            isSimulation\r\n        );\r\n\r\n        // If the trade is a simulation update the balance\r\n        const oldBalance = this.trustScoreDb.getTokenBalance(tokenAddress);\r\n        const tokenBalance = oldBalance - sellDetails.sell_amount;\r\n        this.trustScoreDb.updateTokenBalance(tokenAddress, tokenBalance);\r\n        // generate some random hash for simulations\r\n        const hash = Math.random().toString(36).substring(7);\r\n        const transaction = {\r\n            tokenAddress: tokenAddress,\r\n            type: \"sell\" as \"buy\" | \"sell\",\r\n            transactionHash: hash,\r\n            amount: sellDetails.sell_amount,\r\n            price: processedData.tradeData.price,\r\n            isSimulation: true,\r\n            timestamp: new Date().toISOString(),\r\n        };\r\n        this.trustScoreDb.addTransaction(transaction);\r\n        this.updateTradeInBe(\r\n            tokenAddress,\r\n            recommender.id,\r\n            recommender.telegramId,\r\n            sellDetailsData,\r\n            tokenBalance\r\n        );\r\n\r\n        return sellDetailsData;\r\n    }\r\n    async isRapidDump(\r\n        tokenAddress: string,\r\n        tokenProvider: TokenProvider\r\n    ): Promise<boolean> {\r\n        const processedData: ProcessedTokenData =\r\n            await tokenProvider.getProcessedTokenData();\r\n        console.log(`Fetched processed token data for token: ${tokenAddress}`);\r\n\r\n        return processedData.tradeData.trade_24h_change_percent < -50;\r\n    }\r\n\r\n    async delay(ms: number) {\r\n        return new Promise((resolve) => setTimeout(resolve, ms));\r\n    }\r\n\r\n    async updateTradeInBe(\r\n        tokenAddress: string,\r\n        recommenderId: string,\r\n        username: string,\r\n        data: SellDetails,\r\n        balanceLeft: number,\r\n        retries = 3,\r\n        delayMs = 2000\r\n    ) {\r\n        for (let attempt = 1; attempt <= retries; attempt++) {\r\n            try {\r\n                await fetch(\r\n                    `${this.backend}/api/updaters/updateTradePerformance`,\r\n                    {\r\n                        method: \"POST\",\r\n                        headers: {\r\n                            \"Content-Type\": \"application/json\",\r\n                            Authorization: `Bearer ${this.backendToken}`,\r\n                        },\r\n                        body: JSON.stringify({\r\n                            tokenAddress: tokenAddress,\r\n                            tradeData: data,\r\n                            recommenderId: recommenderId,\r\n                            username: username,\r\n                            isSimulation: true,\r\n                            balanceLeft: balanceLeft,\r\n                        }),\r\n                    }\r\n                );\r\n                // If the request is successful, exit the loop\r\n                return;\r\n            } catch (error) {\r\n                console.error(\r\n                    `Attempt ${attempt} failed: Error creating trade in backend`,\r\n                    error\r\n                );\r\n                if (attempt < retries) {\r\n                    console.log(`Retrying in ${delayMs} ms...`);\r\n                    await this.delay(delayMs); // Wait for the specified delay before retrying\r\n                } else {\r\n                    console.error(\"All attempts failed.\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// SellDecision interface\r\ninterface SellDecision {\r\n    tokenPerformance: TokenPerformance;\r\n    amountToSell: number;\r\n    sell_recommender_id: string | null;\r\n}\r\n","import crypto from 'crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import crypto from 'crypto';\nexport default {\n  randomUUID: crypto.randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import {\r\n    composeContext,\r\n    generateObjectArray,\r\n    generateTrueOrFalse,\r\n    MemoryManager,\r\n    booleanFooter,\r\n    ActionExample,\r\n    Content,\r\n    IAgentRuntime,\r\n    Memory,\r\n    ModelClass,\r\n    Evaluator,\r\n} from \"@ai16z/eliza\";\r\nimport { TrustScoreManager } from \"../providers/trustScoreProvider.ts\";\r\nimport { TokenProvider } from \"../providers/token.ts\";\r\nimport { WalletProvider } from \"../providers/wallet.ts\";\r\nimport { TrustScoreDatabase } from \"@ai16z/plugin-trustdb\";\r\nimport { Connection, PublicKey } from \"@solana/web3.js\";\r\n\r\nconst shouldProcessTemplate =\r\n    `# Task: Decide if the recent messages should be processed for token recommendations.\r\n\r\n    Look for messages that:\r\n    - Mention specific token tickers or contract addresses\r\n    - Contain words related to buying, selling, or trading tokens\r\n    - Express opinions or convictions about tokens\r\n\r\n    Based on the following conversation, should the messages be processed for recommendations? YES or NO\r\n\r\n    {{recentMessages}}\r\n\r\n    Should the messages be processed for recommendations? ` + booleanFooter;\r\n\r\nexport const formatRecommendations = (recommendations: Memory[]) => {\r\n    const messageStrings = recommendations\r\n        .reverse()\r\n        .map((rec: Memory) => `${(rec.content as Content)?.content}`);\r\n    const finalMessageStrings = messageStrings.join(\"\\n\");\r\n    return finalMessageStrings;\r\n};\r\n\r\nconst recommendationTemplate = `TASK: Extract recommendations to buy or sell memecoins from the conversation as an array of objects in JSON format.\r\n\r\n    Memecoins usually have a ticker and a contract address. Additionally, recommenders may make recommendations with some amount of conviction. The amount of conviction in their recommendation can be none, low, medium, or high. Recommenders can make recommendations to buy, not buy, sell and not sell.\r\n\r\n# START OF EXAMPLES\r\nThese are an examples of the expected output of this task:\r\n{{evaluationExamples}}\r\n# END OF EXAMPLES\r\n\r\n# INSTRUCTIONS\r\n\r\nExtract any new recommendations from the conversation that are not already present in the list of known recommendations below:\r\n{{recentRecommendations}}\r\n\r\n- Include the recommender's username\r\n- Try not to include already-known recommendations. If you think a recommendation is already known, but you're not sure, respond with alreadyKnown: true.\r\n- Set the conviction to 'none', 'low', 'medium' or 'high'\r\n- Set the recommendation type to 'buy', 'dont_buy', 'sell', or 'dont_sell'\r\n- Include the contract address and/or ticker if available\r\n\r\nRecent Messages:\r\n{{recentMessages}}\r\n\r\nResponse should be a JSON object array inside a JSON markdown block. Correct response format:\r\n\\`\\`\\`json\r\n[\r\n  {\r\n    \"recommender\": string,\r\n    \"ticker\": string | null,\r\n    \"contractAddress\": string | null,\r\n    \"type\": enum<buy|dont_buy|sell|dont_sell>,\r\n    \"conviction\": enum<none|low|medium|high>,\r\n    \"alreadyKnown\": boolean\r\n  },\r\n  ...\r\n]\r\n\\`\\`\\``;\r\n\r\nasync function handler(runtime: IAgentRuntime, message: Memory) {\r\n    console.log(\"Evaluating for trust\");\r\n    const state = await runtime.composeState(message);\r\n\r\n    const { agentId, roomId } = state;\r\n\r\n    // Check if we should process the messages\r\n    const shouldProcessContext = composeContext({\r\n        state,\r\n        template: shouldProcessTemplate,\r\n    });\r\n\r\n    const shouldProcess = await generateTrueOrFalse({\r\n        context: shouldProcessContext,\r\n        modelClass: ModelClass.SMALL,\r\n        runtime,\r\n    });\r\n\r\n    if (!shouldProcess) {\r\n        console.log(\"Skipping process\");\r\n        return [];\r\n    }\r\n\r\n    console.log(\"Processing recommendations\");\r\n\r\n    // Get recent recommendations\r\n    const recommendationsManager = new MemoryManager({\r\n        runtime,\r\n        tableName: \"recommendations\",\r\n    });\r\n\r\n    const recentRecommendations = await recommendationsManager.getMemories({\r\n        roomId,\r\n        count: 20,\r\n    });\r\n\r\n    const context = composeContext({\r\n        state: {\r\n            ...state,\r\n            recentRecommendations: formatRecommendations(recentRecommendations),\r\n        },\r\n        template: recommendationTemplate,\r\n    });\r\n\r\n    const recommendations = await generateObjectArray({\r\n        runtime,\r\n        context,\r\n        modelClass: ModelClass.LARGE,\r\n    });\r\n\r\n    console.log(\"recommendations\", recommendations);\r\n\r\n    if (!recommendations) {\r\n        return [];\r\n    }\r\n\r\n    // If the recommendation is already known or corrupted, remove it\r\n    const filteredRecommendations = recommendations.filter((rec) => {\r\n        return (\r\n            !rec.alreadyKnown &&\r\n            (rec.ticker || rec.contractAddress) &&\r\n            rec.recommender &&\r\n            rec.conviction &&\r\n            rec.recommender.trim() !== \"\"\r\n        );\r\n    });\r\n\r\n    for (const rec of filteredRecommendations) {\r\n        // create the wallet provider and token provider\r\n        const walletProvider = new WalletProvider(\r\n            new Connection(\r\n                runtime.getSetting(\"RPC_URL\") ||\r\n                    \"https://api.mainnet-beta.solana.com\"\r\n            ),\r\n            new PublicKey(\r\n                runtime.getSetting(\"SOLANA_PUBLIC_KEY\") ??\r\n                    runtime.getSetting(\"WALLET_PUBLIC_KEY\")\r\n            )\r\n        );\r\n        const tokenProvider = new TokenProvider(\r\n            rec.contractAddress,\r\n            walletProvider,\r\n            runtime.cacheManager\r\n        );\r\n\r\n        // TODO: Check to make sure the contract address is valid, it's the right one, etc\r\n\r\n        //\r\n        if (!rec.contractAddress) {\r\n            const tokenAddress = await tokenProvider.getTokenFromWallet(\r\n                runtime,\r\n                rec.ticker\r\n            );\r\n            rec.contractAddress = tokenAddress;\r\n            if (!tokenAddress) {\r\n                // try to search for the symbol and return the contract address with they highest liquidity and market cap\r\n                const result = await tokenProvider.searchDexScreenerData(\r\n                    rec.ticker\r\n                );\r\n                const tokenAddress = result?.baseToken?.address;\r\n                rec.contractAddress = tokenAddress;\r\n                if (!tokenAddress) {\r\n                    console.warn(\"Could not find contract address for token\");\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        // create the trust score manager\r\n\r\n        const trustScoreDb = new TrustScoreDatabase(runtime.databaseAdapter.db);\r\n        const trustScoreManager = new TrustScoreManager(\r\n            runtime,\r\n            tokenProvider,\r\n            trustScoreDb\r\n        );\r\n\r\n        // get actors from the database\r\n        const participants =\r\n            await runtime.databaseAdapter.getParticipantsForRoom(\r\n                message.roomId\r\n            );\r\n\r\n        // find the first user Id from a user with the username that we extracted\r\n        const user = participants.find(async (actor) => {\r\n            const user = await runtime.databaseAdapter.getAccountById(actor);\r\n            return (\r\n                user.name.toLowerCase().trim() ===\r\n                rec.recommender.toLowerCase().trim()\r\n            );\r\n        });\r\n\r\n        if (!user) {\r\n            console.warn(\"Could not find user: \", rec.recommender);\r\n            continue;\r\n        }\r\n\r\n        const account = await runtime.databaseAdapter.getAccountById(user);\r\n        const userId = account.id;\r\n\r\n        const recMemory = {\r\n            userId,\r\n            agentId,\r\n            content: { text: JSON.stringify(rec) },\r\n            roomId,\r\n            createdAt: Date.now(),\r\n        };\r\n\r\n        await recommendationsManager.createMemory(recMemory, true);\r\n\r\n        console.log(\"recommendationsManager\", rec);\r\n\r\n        // - from here we just need to make sure code is right\r\n\r\n        // buy, dont buy, sell, dont sell\r\n\r\n        const buyAmounts = await tokenProvider.calculateBuyAmounts();\r\n\r\n        let buyAmount = buyAmounts[rec.conviction.toLowerCase().trim()];\r\n        if (!buyAmount) {\r\n            // handle annoying cases\r\n            // for now just put in 10 sol\r\n            buyAmount = 10;\r\n        }\r\n\r\n        // TODO: is this is a buy, sell, dont buy, or dont sell?\r\n        const shouldTrade = await tokenProvider.shouldTradeToken();\r\n\r\n        if (!shouldTrade) {\r\n            console.warn(\r\n                \"There might be a problem with the token, not trading\"\r\n            );\r\n            continue;\r\n        }\r\n\r\n        switch (rec.type) {\r\n            case \"buy\":\r\n                // for now, lets just assume buy only, but we should implement\r\n                await trustScoreManager.createTradePerformance(\r\n                    runtime,\r\n                    rec.contractAddress,\r\n                    userId,\r\n                    {\r\n                        buy_amount: rec.buyAmount,\r\n                        is_simulation: true,\r\n                    }\r\n                );\r\n                break;\r\n            case \"sell\":\r\n            case \"dont_sell\":\r\n            case \"dont_buy\":\r\n                console.warn(\"Not implemented\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    return filteredRecommendations;\r\n}\r\n\r\nexport const trustEvaluator: Evaluator = {\r\n    name: \"EXTRACT_RECOMMENDATIONS\",\r\n    similes: [\r\n        \"GET_RECOMMENDATIONS\",\r\n        \"EXTRACT_TOKEN_RECS\",\r\n        \"EXTRACT_MEMECOIN_RECS\",\r\n    ],\r\n    alwaysRun: true,\r\n    validate: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory\r\n    ): Promise<boolean> => {\r\n        if (message.content.text.length < 5) {\r\n            return false;\r\n        }\r\n\r\n        return message.userId !== message.agentId;\r\n    },\r\n    description:\r\n        \"Extract recommendations to buy or sell memecoins/tokens from the conversation, including details like ticker, contract address, conviction level, and recommender username.\",\r\n    handler,\r\n    examples: [\r\n        {\r\n            context: `Actors in the scene:\r\n{{user1}}: Experienced DeFi degen. Constantly chasing high yield farms.\r\n{{user2}}: New to DeFi, learning the ropes.\r\n\r\nRecommendations about the actors:\r\nNone`,\r\n            messages: [\r\n                {\r\n                    user: \"{{user1}}\",\r\n                    content: {\r\n                        text: \"Yo, have you checked out $SOLARUG? Dope new yield aggregator on Solana.\",\r\n                    },\r\n                },\r\n                {\r\n                    user: \"{{user2}}\",\r\n                    content: {\r\n                        text: \"Nah, I'm still trying to wrap my head around how yield farming even works haha. Is it risky?\",\r\n                    },\r\n                },\r\n                {\r\n                    user: \"{{user1}}\",\r\n                    content: {\r\n                        text: \"I mean, there's always risk in DeFi, but the $SOLARUG devs seem legit. Threw a few sol into the FCweoTfJ128jGgNEXgdfTXdEZVk58Bz9trCemr6sXNx9 vault, farming's been smooth so far.\",\r\n                    },\r\n                },\r\n            ] as ActionExample[],\r\n            outcome: `\\`\\`\\`json\r\n[\r\n  {\r\n    \"recommender\": \"{{user1}}\",\r\n    \"ticker\": \"SOLARUG\",\r\n    \"contractAddress\": \"FCweoTfJ128jGgNEXgdfTXdEZVk58Bz9trCemr6sXNx9\",\r\n    \"type\": \"buy\",\r\n    \"conviction\": \"medium\",\r\n    \"alreadyKnown\": false\r\n  }\r\n]\r\n\\`\\`\\``,\r\n        },\r\n\r\n        {\r\n            context: `Actors in the scene:\r\n{{user1}}: Solana maximalist. Believes Solana will flip Ethereum.\r\n{{user2}}: Multichain proponent. Holds both SOL and ETH.\r\n\r\nRecommendations about the actors:\r\n{{user1}} has previously promoted $COPETOKEN and $SOYLENT.`,\r\n            messages: [\r\n                {\r\n                    user: \"{{user1}}\",\r\n                    content: {\r\n                        text: \"If you're not long $SOLVAULT at 7tRzKud6FBVFEhYqZS3CuQ2orLRM21bdisGykL5Sr4Dx, you're missing out. This will be the blackhole of Solana liquidity.\",\r\n                    },\r\n                },\r\n                {\r\n                    user: \"{{user2}}\",\r\n                    content: {\r\n                        text: \"Idk man, feels like there's a new 'vault' or 'reserve' token every week on Sol. What happened to $COPETOKEN and $SOYLENT that you were shilling before?\",\r\n                    },\r\n                },\r\n                {\r\n                    user: \"{{user1}}\",\r\n                    content: {\r\n                        text: \"$COPETOKEN and $SOYLENT had their time, I took profits near the top. But $SOLVAULT is different, it has actual utility. Do what you want, but don't say I didn't warn you when this 50x's and you're left holding your $ETH bags.\",\r\n                    },\r\n                },\r\n            ] as ActionExample[],\r\n            outcome: `\\`\\`\\`json\r\n[\r\n  {\r\n    \"recommender\": \"{{user1}}\",\r\n    \"ticker\": \"COPETOKEN\",\r\n    \"contractAddress\": null,\r\n    \"type\": \"sell\",\r\n    \"conviction\": \"low\",\r\n    \"alreadyKnown\": true\r\n  },\r\n  {\r\n    \"recommender\": \"{{user1}}\",\r\n    \"ticker\": \"SOYLENT\",\r\n    \"contractAddress\": null,\r\n    \"type\": \"sell\",\r\n    \"conviction\": \"low\",\r\n    \"alreadyKnown\": true\r\n  },\r\n  {\r\n    \"recommender\": \"{{user1}}\",\r\n    \"ticker\": \"SOLVAULT\",\r\n    \"contractAddress\": \"7tRzKud6FBVFEhYqZS3CuQ2orLRM21bdisGykL5Sr4Dx\",\r\n    \"type\": \"buy\",\r\n    \"conviction\": \"high\",\r\n    \"alreadyKnown\": false\r\n  }\r\n]\r\n\\`\\`\\``,\r\n        },\r\n\r\n        {\r\n            context: `Actors in the scene:\r\n{{user1}}: Self-proclaimed Solana alpha caller. Allegedly has insider info.\r\n{{user2}}: Degen gambler. Will ape into any hyped token.\r\n\r\nRecommendations about the actors:\r\nNone`,\r\n            messages: [\r\n                {\r\n                    user: \"{{user1}}\",\r\n                    content: {\r\n                        text: \"I normally don't do this, but I like you anon, so I'll let you in on some alpha. $ROULETTE at 48vV5y4DRH1Adr1bpvSgFWYCjLLPtHYBqUSwNc2cmCK2 is going to absolutely send it soon. You didn't hear it from me \",\r\n                    },\r\n                },\r\n                {\r\n                    user: \"{{user2}}\",\r\n                    content: {\r\n                        text: \"Oh shit, insider info from the alpha god himself? Say no more, I'm aping in hard.\",\r\n                    },\r\n                },\r\n            ] as ActionExample[],\r\n            outcome: `\\`\\`\\`json\r\n[\r\n  {\r\n    \"recommender\": \"{{user1}}\",\r\n    \"ticker\": \"ROULETTE\",\r\n    \"contractAddress\": \"48vV5y4DRH1Adr1bpvSgFWYCjLLPtHYBqUSwNc2cmCK2\",\r\n    \"type\": \"buy\",\r\n    \"conviction\": \"high\",\r\n    \"alreadyKnown\": false\r\n  }\r\n]\r\n\\`\\`\\``,\r\n        },\r\n\r\n        {\r\n            context: `Actors in the scene:\r\n{{user1}}: NFT collector and trader. Bullish on Solana NFTs.\r\n{{user2}}: Only invests based on fundamentals. Sees all NFTs as worthless JPEGs.\r\n\r\nRecommendations about the actors:\r\nNone\r\n`,\r\n            messages: [\r\n                {\r\n                    user: \"{{user1}}\",\r\n                    content: {\r\n                        text: \"GM. I'm heavily accumulating $PIXELAPE, the token for the Pixel Ape Yacht Club NFT collection. 10x is inevitable.\",\r\n                    },\r\n                },\r\n                {\r\n                    user: \"{{user2}}\",\r\n                    content: {\r\n                        text: \"NFTs are a scam bro. There's no underlying value. You're essentially trading worthless JPEGs.\",\r\n                    },\r\n                },\r\n                {\r\n                    user: \"{{user1}}\",\r\n                    content: {\r\n                        text: \"Fun staying poor  $PIXELAPE is about to moon and you'll be left behind.\",\r\n                    },\r\n                },\r\n                {\r\n                    user: \"{{user2}}\",\r\n                    content: {\r\n                        text: \"Whatever man, I'm not touching that shit with a ten foot pole. Have fun holding your bags.\",\r\n                    },\r\n                },\r\n                {\r\n                    user: \"{{user1}}\",\r\n                    content: {\r\n                        text: \"Don't need luck where I'm going  Once $PIXELAPE at 3hAKKmR6XyBooQBPezCbUMhrmcyTkt38sRJm2thKytWc takes off, you'll change your tune.\",\r\n                    },\r\n                },\r\n            ],\r\n            outcome: `\\`\\`\\`json\r\n[\r\n  {\r\n    \"recommender\": \"{{user1}}\",\r\n    \"ticker\": \"PIXELAPE\",\r\n    \"contractAddress\": \"3hAKKmR6XyBooQBPezCbUMhrmcyTkt38sRJm2thKytWc\",\r\n    \"type\": \"buy\",\r\n    \"conviction\": \"high\",\r\n    \"alreadyKnown\": false\r\n  }\r\n]\r\n\\`\\`\\``,\r\n        },\r\n\r\n        {\r\n            context: `Actors in the scene:\r\n{{user1}}: Contrarian investor. Bets against hyped projects.\r\n{{user2}}: Trend follower. Buys tokens that are currently popular.\r\n\r\nRecommendations about the actors:\r\nNone`,\r\n            messages: [\r\n                {\r\n                    user: \"{{user2}}\",\r\n                    content: {\r\n                        text: \"$SAMOYED is the talk of CT right now. Making serious moves. Might have to get a bag.\",\r\n                    },\r\n                },\r\n                {\r\n                    user: \"{{user1}}\",\r\n                    content: {\r\n                        text: \"Whenever a token is the 'talk of CT', that's my cue to short it. $SAMOYED is going to dump hard, mark my words.\",\r\n                    },\r\n                },\r\n                {\r\n                    user: \"{{user2}}\",\r\n                    content: {\r\n                        text: \"Idk man, the hype seems real this time. 5TQwHyZbedaH4Pcthj1Hxf5GqcigL6qWuB7YEsBtqvhr chart looks bullish af.\",\r\n                    },\r\n                },\r\n                {\r\n                    user: \"{{user1}}\",\r\n                    content: {\r\n                        text: \"Hype is always real until it isn't. I'm taking out a fat short position here. Don't say I didn't warn you when this crashes 90% and you're left holding the flaming bags.\",\r\n                    },\r\n                },\r\n            ],\r\n            outcome: `\\`\\`\\`json\r\n[\r\n  {\r\n    \"recommender\": \"{{user2}}\",\r\n    \"ticker\": \"SAMOYED\",\r\n    \"contractAddress\": \"5TQwHyZbedaH4Pcthj1Hxf5GqcigL6qWuB7YEsBtqvhr\",\r\n    \"type\": \"buy\",\r\n    \"conviction\": \"medium\",\r\n    \"alreadyKnown\": false\r\n  },\r\n  {\r\n    \"recommender\": \"{{user1}}\",\r\n    \"ticker\": \"SAMOYED\",\r\n    \"contractAddress\": \"5TQwHyZbedaH4Pcthj1Hxf5GqcigL6qWuB7YEsBtqvhr\",\r\n    \"type\": \"dont_buy\",\r\n    \"conviction\": \"high\",\r\n    \"alreadyKnown\": false\r\n  }\r\n]\r\n\\`\\`\\``,\r\n        },\r\n    ],\r\n};\r\n","import bs58 from \"bs58\";\r\nimport {\r\n    Connection,\r\n    Keypair,\r\n    PublicKey,\r\n    VersionedTransaction,\r\n} from \"@solana/web3.js\";\r\nimport BigNumber from \"bignumber.js\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport { TrustScoreDatabase } from \"@ai16z/plugin-trustdb\";\r\nimport {\r\n    ActionExample,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Memory,\r\n    ModelClass,\r\n    State,\r\n    type Action,\r\n    composeContext,\r\n    generateObject,\r\n    settings,\r\n} from \"@ai16z/eliza\";\r\nimport { TokenProvider } from \"../providers/token.ts\";\r\nimport { TrustScoreManager } from \"../providers/trustScoreProvider.ts\";\r\nimport { walletProvider, WalletProvider } from \"../providers/wallet.ts\";\r\nimport { getTokenDecimals } from \"./swapUtils.ts\";\r\n\r\nasync function swapToken(\r\n    connection: Connection,\r\n    walletPublicKey: PublicKey,\r\n    inputTokenCA: string,\r\n    outputTokenCA: string,\r\n    amount: number\r\n): Promise<any> {\r\n    try {\r\n        // Get the decimals for the input token\r\n        const decimals =\r\n            inputTokenCA === settings.SOL_ADDRESS\r\n                ? new BigNumber(9)\r\n                : new BigNumber(\r\n                      await getTokenDecimals(connection, inputTokenCA)\r\n                  );\r\n\r\n        console.log(\"Decimals:\", decimals.toString());\r\n\r\n        // Use BigNumber for adjustedAmount: amount * (10 ** decimals)\r\n        const amountBN = new BigNumber(amount);\r\n        const adjustedAmount = amountBN.multipliedBy(\r\n            new BigNumber(10).pow(decimals)\r\n        );\r\n\r\n        console.log(\"Fetching quote with params:\", {\r\n            inputMint: inputTokenCA,\r\n            outputMint: outputTokenCA,\r\n            amount: adjustedAmount,\r\n        });\r\n\r\n        const quoteResponse = await fetch(\r\n            `https://quote-api.jup.ag/v6/quote?inputMint=${inputTokenCA}&outputMint=${outputTokenCA}&amount=${adjustedAmount}&slippageBps=50`\r\n        );\r\n        const quoteData = await quoteResponse.json();\r\n\r\n        if (!quoteData || quoteData.error) {\r\n            console.error(\"Quote error:\", quoteData);\r\n            throw new Error(\r\n                `Failed to get quote: ${quoteData?.error || \"Unknown error\"}`\r\n            );\r\n        }\r\n\r\n        console.log(\"Quote received:\", quoteData);\r\n\r\n        const swapRequestBody = {\r\n            quoteResponse: quoteData,\r\n            userPublicKey: walletPublicKey.toString(),\r\n            wrapAndUnwrapSol: true,\r\n            computeUnitPriceMicroLamports: 2000000,\r\n            dynamicComputeUnitLimit: true,\r\n        };\r\n\r\n        console.log(\"Requesting swap with body:\", swapRequestBody);\r\n\r\n        const swapResponse = await fetch(\"https://quote-api.jup.ag/v6/swap\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application/json\",\r\n            },\r\n            body: JSON.stringify(swapRequestBody),\r\n        });\r\n\r\n        const swapData = await swapResponse.json();\r\n\r\n        if (!swapData || !swapData.swapTransaction) {\r\n            console.error(\"Swap error:\", swapData);\r\n            throw new Error(\r\n                `Failed to get swap transaction: ${swapData?.error || \"No swap transaction returned\"}`\r\n            );\r\n        }\r\n\r\n        console.log(\"Swap transaction received\");\r\n        return swapData;\r\n    } catch (error) {\r\n        console.error(\"Error in swapToken:\", error);\r\n        throw error;\r\n    }\r\n}\r\n\r\nconst swapTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\r\n\r\nExample response:\r\n\\`\\`\\`json\r\n{\r\n    \"inputTokenSymbol\": \"SOL\",\r\n    \"outputTokenSymbol\": \"USDC\", \r\n    \"inputTokenCA\": \"So11111111111111111111111111111111111111112\",\r\n    \"outputTokenCA\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\r\n    \"amount\": 1.5\r\n}\r\n\\`\\`\\`\r\n\r\n{{recentMessages}}\r\n\r\nGiven the recent messages and wallet information below:\r\n\r\n{{walletInfo}}\r\n\r\nExtract the following information about the requested token swap:\r\n- Input token symbol (the token being sold)\r\n- Output token symbol (the token being bought) \r\n- Input token contract address if provided\r\n- Output token contract address if provided\r\n- Amount to swap\r\n\r\nRespond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined. The result should be a valid JSON object with the following schema:\r\n\\`\\`\\`json\r\n{\r\n    \"inputTokenSymbol\": string | null,\r\n    \"outputTokenSymbol\": string | null, \r\n    \"inputTokenCA\": string | null,\r\n    \"outputTokenCA\": string | null,\r\n    \"amount\": number | string | null\r\n}\r\n\\`\\`\\``;\r\n\r\n// if we get the token symbol but not the CA, check walet for matching token, and if we have, get the CA for it\r\n\r\n// get all the tokens in the wallet using the wallet provider\r\nasync function getTokensInWallet(runtime: IAgentRuntime) {\r\n    const walletProvider = new WalletProvider(\r\n        new Connection(\"https://api.mainnet-beta.solana.com\"),\r\n        new PublicKey(\r\n            runtime.getSetting(\"SOLANA_PUBLIC_KEY\") ??\r\n                runtime.getSetting(\"WALLET_PUBLIC_KEY\")\r\n        )\r\n    );\r\n\r\n    const walletInfo = await walletProvider.fetchPortfolioValue(runtime);\r\n    const items = walletInfo.items;\r\n    return items;\r\n}\r\n\r\n// check if the token symbol is in the wallet\r\nasync function getTokenFromWallet(runtime: IAgentRuntime, tokenSymbol: string) {\r\n    try {\r\n        const items = await getTokensInWallet(runtime);\r\n        const token = items.find((item) => item.symbol === tokenSymbol);\r\n\r\n        if (token) {\r\n            return token.address;\r\n        } else {\r\n            return null;\r\n        }\r\n    } catch (error) {\r\n        console.error(\"Error checking token in wallet:\", error);\r\n        return null;\r\n    }\r\n}\r\n\r\n// swapToken should took CA, not symbol\r\n\r\nexport const executeSwap: Action = {\r\n    name: \"EXECUTE_SWAP\",\r\n    similes: [\"SWAP_TOKENS\", \"TOKEN_SWAP\", \"TRADE_TOKENS\", \"EXCHANGE_TOKENS\"],\r\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\r\n        // Check if the necessary parameters are provided in the message\r\n        console.log(\"Message:\", message);\r\n        return true;\r\n    },\r\n    description: \"Perform a token swap.\",\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        _options: { [key: string]: unknown },\r\n        callback?: HandlerCallback\r\n    ): Promise<boolean> => {\r\n        // composeState\r\n        if (!state) {\r\n            state = (await runtime.composeState(message)) as State;\r\n        } else {\r\n            state = await runtime.updateRecentMessageState(state);\r\n        }\r\n\r\n        const walletInfo = await walletProvider.get(runtime, message, state);\r\n\r\n        state.walletInfo = walletInfo;\r\n\r\n        const swapContext = composeContext({\r\n            state,\r\n            template: swapTemplate,\r\n        });\r\n\r\n        const response = await generateObject({\r\n            runtime,\r\n            context: swapContext,\r\n            modelClass: ModelClass.LARGE,\r\n        });\r\n\r\n        console.log(\"Response:\", response);\r\n        const type =\r\n            response.inputTokenSymbol?.toUpperCase() === \"SOL\" ? \"buy\" : \"sell\";\r\n\r\n        // Add SOL handling logic\r\n        if (response.inputTokenSymbol?.toUpperCase() === \"SOL\") {\r\n            response.inputTokenCA = settings.SOL_ADDRESS;\r\n        }\r\n        if (response.outputTokenSymbol?.toUpperCase() === \"SOL\") {\r\n            response.outputTokenCA = settings.SOL_ADDRESS;\r\n        }\r\n\r\n        // if both contract addresses are set, lets execute the swap\r\n        // TODO: try to resolve CA from symbol based on existing symbol in wallet\r\n        if (!response.inputTokenCA && response.inputTokenSymbol) {\r\n            console.log(\r\n                `Attempting to resolve CA for input token symbol: ${response.inputTokenSymbol}`\r\n            );\r\n            response.inputTokenCA = await getTokenFromWallet(\r\n                runtime,\r\n                response.inputTokenSymbol\r\n            );\r\n            if (response.inputTokenCA) {\r\n                console.log(`Resolved inputTokenCA: ${response.inputTokenCA}`);\r\n            } else {\r\n                console.log(\"No contract addresses provided, skipping swap\");\r\n                const responseMsg = {\r\n                    text: \"I need the contract addresses to perform the swap\",\r\n                };\r\n                callback?.(responseMsg);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!response.outputTokenCA && response.outputTokenSymbol) {\r\n            console.log(\r\n                `Attempting to resolve CA for output token symbol: ${response.outputTokenSymbol}`\r\n            );\r\n            response.outputTokenCA = await getTokenFromWallet(\r\n                runtime,\r\n                response.outputTokenSymbol\r\n            );\r\n            if (response.outputTokenCA) {\r\n                console.log(\r\n                    `Resolved outputTokenCA: ${response.outputTokenCA}`\r\n                );\r\n            } else {\r\n                console.log(\"No contract addresses provided, skipping swap\");\r\n                const responseMsg = {\r\n                    text: \"I need the contract addresses to perform the swap\",\r\n                };\r\n                callback?.(responseMsg);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!response.amount) {\r\n            console.log(\"No amount provided, skipping swap\");\r\n            const responseMsg = {\r\n                text: \"I need the amount to perform the swap\",\r\n            };\r\n            callback?.(responseMsg);\r\n            return true;\r\n        }\r\n\r\n        // TODO: if response amount is half, all, etc, semantically retrieve amount and return as number\r\n        if (!response.amount) {\r\n            console.log(\"Amount is not a number, skipping swap\");\r\n            const responseMsg = {\r\n                text: \"The amount must be a number\",\r\n            };\r\n            callback?.(responseMsg);\r\n            return true;\r\n        }\r\n        try {\r\n            const connection = new Connection(\r\n                \"https://api.mainnet-beta.solana.com\"\r\n            );\r\n            const walletPublicKey = new PublicKey(\r\n                runtime.getSetting(\"SOLANA_PUBLIC_KEY\") ??\r\n                    runtime.getSetting(\"WALLET_PUBLIC_KEY\")\r\n            );\r\n\r\n            const provider = new WalletProvider(connection, walletPublicKey);\r\n\r\n            console.log(\"Wallet Public Key:\", walletPublicKey);\r\n            console.log(\"inputTokenSymbol:\", response.inputTokenCA);\r\n            console.log(\"outputTokenSymbol:\", response.outputTokenCA);\r\n            console.log(\"amount:\", response.amount);\r\n\r\n            const swapResult = await swapToken(\r\n                connection,\r\n                walletPublicKey,\r\n                response.inputTokenCA as string,\r\n                response.outputTokenCA as string,\r\n                response.amount as number\r\n            );\r\n\r\n            console.log(\"Deserializing transaction...\");\r\n            const transactionBuf = Buffer.from(\r\n                swapResult.swapTransaction,\r\n                \"base64\"\r\n            );\r\n            const transaction =\r\n                VersionedTransaction.deserialize(transactionBuf);\r\n\r\n            console.log(\"Preparing to sign transaction...\");\r\n            const privateKeyString =\r\n                runtime.getSetting(\"SOLANA_PRIVATE_KEY\") ??\r\n                runtime.getSetting(\"WALLET_PRIVATE_KEY\");\r\n\r\n            // Handle different private key formats\r\n            let secretKey: Uint8Array;\r\n            try {\r\n                // First try to decode as base58\r\n                secretKey = bs58.decode(privateKeyString);\r\n                // eslint-disable-next-line\r\n            } catch (e) {\r\n                try {\r\n                    // If that fails, try base64\r\n                    secretKey = Uint8Array.from(\r\n                        Buffer.from(privateKeyString, \"base64\")\r\n                    );\r\n                    // eslint-disable-next-line\r\n                } catch (e2) {\r\n                    throw new Error(\"Invalid private key format\");\r\n                }\r\n            }\r\n\r\n            // Verify the key length\r\n            if (secretKey.length !== 64) {\r\n                console.error(\"Invalid key length:\", secretKey.length);\r\n                throw new Error(\r\n                    `Invalid private key length: ${secretKey.length}. Expected 64 bytes.`\r\n                );\r\n            }\r\n\r\n            console.log(\"Creating keypair...\");\r\n            const keypair = Keypair.fromSecretKey(secretKey);\r\n\r\n            // Verify the public key matches what we expect\r\n            const expectedPublicKey =\r\n                runtime.getSetting(\"SOLANA_PUBLIC_KEY\") ??\r\n                runtime.getSetting(\"WALLET_PUBLIC_KEY\");\r\n            if (keypair.publicKey.toBase58() !== expectedPublicKey) {\r\n                throw new Error(\r\n                    \"Generated public key doesn't match expected public key\"\r\n                );\r\n            }\r\n\r\n            console.log(\"Signing transaction...\");\r\n            transaction.sign([keypair]);\r\n\r\n            console.log(\"Sending transaction...\");\r\n\r\n            const latestBlockhash = await connection.getLatestBlockhash();\r\n\r\n            const txid = await connection.sendTransaction(transaction, {\r\n                skipPreflight: false,\r\n                maxRetries: 3,\r\n                preflightCommitment: \"confirmed\",\r\n            });\r\n\r\n            console.log(\"Transaction sent:\", txid);\r\n\r\n            // Confirm transaction using the blockhash\r\n            const confirmation = await connection.confirmTransaction(\r\n                {\r\n                    signature: txid,\r\n                    blockhash: latestBlockhash.blockhash,\r\n                    lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,\r\n                },\r\n                \"confirmed\"\r\n            );\r\n\r\n            if (confirmation.value.err) {\r\n                throw new Error(\r\n                    `Transaction failed: ${confirmation.value.err}`\r\n                );\r\n            }\r\n\r\n            if (confirmation.value.err) {\r\n                throw new Error(\r\n                    `Transaction failed: ${confirmation.value.err}`\r\n                );\r\n            }\r\n\r\n            if (type === \"buy\") {\r\n                const tokenProvider = new TokenProvider(\r\n                    response.outputTokenCA,\r\n                    provider,\r\n                    runtime.cacheManager\r\n                );\r\n                const module = await import(\"better-sqlite3\");\r\n                const Database = module.default;\r\n                const trustScoreDb = new TrustScoreDatabase(\r\n                    new Database(\":memory:\")\r\n                );\r\n                // add or get recommender\r\n                const uuid = uuidv4();\r\n                const recommender = await trustScoreDb.getOrCreateRecommender({\r\n                    id: uuid,\r\n                    address: walletPublicKey.toString(),\r\n                    solanaPubkey: walletPublicKey.toString(),\r\n                });\r\n\r\n                const trustScoreDatabase = new TrustScoreManager(\r\n                    runtime,\r\n                    tokenProvider,\r\n                    trustScoreDb\r\n                );\r\n                // save the trade\r\n                const tradeData = {\r\n                    buy_amount: response.amount,\r\n                    is_simulation: false,\r\n                };\r\n                await trustScoreDatabase.createTradePerformance(\r\n                    runtime,\r\n                    response.outputTokenCA,\r\n                    recommender.id,\r\n                    tradeData\r\n                );\r\n            } else if (type === \"sell\") {\r\n                const tokenProvider = new TokenProvider(\r\n                    response.inputTokenCA,\r\n                    provider,\r\n                    runtime.cacheManager\r\n                );\r\n                const module = await import(\"better-sqlite3\");\r\n                const Database = module.default;\r\n                const trustScoreDb = new TrustScoreDatabase(\r\n                    new Database(\":memory:\")\r\n                );\r\n                // add or get recommender\r\n                const uuid = uuidv4();\r\n                const recommender = await trustScoreDb.getOrCreateRecommender({\r\n                    id: uuid,\r\n                    address: walletPublicKey.toString(),\r\n                    solanaPubkey: walletPublicKey.toString(),\r\n                });\r\n\r\n                const trustScoreDatabase = new TrustScoreManager(\r\n                    runtime,\r\n                    tokenProvider,\r\n                    trustScoreDb\r\n                );\r\n                // save the trade\r\n                const sellDetails = {\r\n                    sell_amount: response.amount,\r\n                    sell_recommender_id: recommender.id,\r\n                };\r\n                const sellTimeStamp = new Date().getTime().toString();\r\n                await trustScoreDatabase.updateSellDetails(\r\n                    runtime,\r\n                    response.inputTokenCA,\r\n                    recommender.id,\r\n                    sellTimeStamp,\r\n                    sellDetails,\r\n                    false\r\n                );\r\n            }\r\n\r\n            console.log(\"Swap completed successfully!\");\r\n            console.log(`Transaction ID: ${txid}`);\r\n\r\n            const responseMsg = {\r\n                text: `Swap completed successfully! Transaction ID: ${txid}`,\r\n            };\r\n\r\n            callback?.(responseMsg);\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error(\"Error during token swap:\", error);\r\n            return false;\r\n        }\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    inputTokenSymbol: \"SOL\",\r\n                    outputTokenSymbol: \"USDC\",\r\n                    amount: 0.1,\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Swapping 0.1 SOL for USDC...\",\r\n                    action: \"TOKEN_SWAP\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Swap completed successfully! Transaction ID: ...\",\r\n                },\r\n            },\r\n        ],\r\n        // Add more examples as needed\r\n    ] as ActionExample[][],\r\n} as Action;\r\n","import { getAssociatedTokenAddress } from \"@solana/spl-token\";\r\nimport {\r\n    BlockhashWithExpiryBlockHeight,\r\n    Connection,\r\n    Keypair,\r\n    PublicKey,\r\n    RpcResponseAndContext,\r\n    SimulatedTransactionResponse,\r\n    TokenAmount,\r\n    VersionedTransaction,\r\n} from \"@solana/web3.js\";\r\nimport { settings } from \"@ai16z/eliza\";\r\n\r\nconst solAddress = settings.SOL_ADDRESS;\r\nconst SLIPPAGE = settings.SLIPPAGE;\r\nconst connection = new Connection(\r\n    settings.RPC_URL || \"https://api.mainnet-beta.solana.com\"\r\n);\r\nconst delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\r\n\r\nexport async function delayedCall<T>(\r\n    method: (...args: any[]) => Promise<T>,\r\n    ...args: any[]\r\n): Promise<T> {\r\n    await delay(150);\r\n    return method(...args);\r\n}\r\n\r\nexport async function getTokenDecimals(\r\n    connection: Connection,\r\n    mintAddress: string\r\n): Promise<number> {\r\n    const mintPublicKey = new PublicKey(mintAddress);\r\n    const tokenAccountInfo =\r\n        await connection.getParsedAccountInfo(mintPublicKey);\r\n\r\n    // Check if the data is parsed and contains the expected structure\r\n    if (\r\n        tokenAccountInfo.value &&\r\n        typeof tokenAccountInfo.value.data === \"object\" &&\r\n        \"parsed\" in tokenAccountInfo.value.data\r\n    ) {\r\n        const parsedInfo = tokenAccountInfo.value.data.parsed?.info;\r\n        if (parsedInfo && typeof parsedInfo.decimals === \"number\") {\r\n            return parsedInfo.decimals;\r\n        }\r\n    }\r\n\r\n    throw new Error(\"Unable to fetch token decimals\");\r\n}\r\n\r\nexport async function getQuote(\r\n    connection: Connection,\r\n    baseToken: string,\r\n    outputToken: string,\r\n    amount: number\r\n): Promise<any> {\r\n    const decimals = await getTokenDecimals(connection, baseToken);\r\n    const adjustedAmount = amount * 10 ** decimals;\r\n\r\n    const quoteResponse = await fetch(\r\n        `https://quote-api.jup.ag/v6/quote?inputMint=${baseToken}&outputMint=${outputToken}&amount=${adjustedAmount}&slippageBps=50`\r\n    );\r\n    const swapTransaction = await quoteResponse.json();\r\n    const swapTransactionBuf = Buffer.from(swapTransaction, \"base64\");\r\n    return new Uint8Array(swapTransactionBuf);\r\n}\r\n\r\nexport const executeSwap = async (\r\n    transaction: VersionedTransaction,\r\n    type: \"buy\" | \"sell\"\r\n) => {\r\n    try {\r\n        const latestBlockhash: BlockhashWithExpiryBlockHeight =\r\n            await delayedCall(connection.getLatestBlockhash.bind(connection));\r\n        const signature = await connection.sendTransaction(transaction, {\r\n            skipPreflight: false,\r\n        });\r\n        const confirmation = await connection.confirmTransaction(\r\n            {\r\n                signature,\r\n                lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,\r\n                blockhash: latestBlockhash.blockhash,\r\n            },\r\n            \"finalized\"\r\n        );\r\n        if (confirmation.value.err) {\r\n            console.log(\"Confirmation error\", confirmation.value.err);\r\n\r\n            throw new Error(\"Confirmation error\");\r\n        } else {\r\n            if (type === \"buy\") {\r\n                console.log(\r\n                    \"Buy successful: https://solscan.io/tx/${signature}\"\r\n                );\r\n            } else {\r\n                console.log(\r\n                    \"Sell successful: https://solscan.io/tx/${signature}\"\r\n                );\r\n            }\r\n        }\r\n\r\n        return signature;\r\n    } catch (error) {\r\n        console.log(error);\r\n    }\r\n};\r\n\r\nexport const Sell = async (baseMint: PublicKey, wallet: Keypair) => {\r\n    try {\r\n        const tokenAta = await delayedCall(\r\n            getAssociatedTokenAddress,\r\n            baseMint,\r\n            wallet.publicKey\r\n        );\r\n        const tokenBalInfo: RpcResponseAndContext<TokenAmount> =\r\n            await delayedCall(\r\n                connection.getTokenAccountBalance.bind(connection),\r\n                tokenAta\r\n            );\r\n\r\n        if (!tokenBalInfo) {\r\n            console.log(\"Balance incorrect\");\r\n            return null;\r\n        }\r\n\r\n        const tokenBalance = tokenBalInfo.value.amount;\r\n        if (tokenBalance === \"0\") {\r\n            console.warn(\r\n                `No token balance to sell with wallet ${wallet.publicKey}`\r\n            );\r\n        }\r\n\r\n        const sellTransaction = await getSwapTxWithWithJupiter(\r\n            wallet,\r\n            baseMint,\r\n            tokenBalance,\r\n            \"sell\"\r\n        );\r\n        // simulate the transaction\r\n        if (!sellTransaction) {\r\n            console.log(\"Failed to get sell transaction\");\r\n            return null;\r\n        }\r\n\r\n        const simulateResult: RpcResponseAndContext<SimulatedTransactionResponse> =\r\n            await delayedCall(\r\n                connection.simulateTransaction.bind(connection),\r\n                sellTransaction\r\n            );\r\n        if (simulateResult.value.err) {\r\n            console.log(\"Sell Simulation failed\", simulateResult.value.err);\r\n            return null;\r\n        }\r\n\r\n        // execute the transaction\r\n        return executeSwap(sellTransaction, \"sell\");\r\n    } catch (error) {\r\n        console.log(error);\r\n    }\r\n};\r\n\r\nexport const Buy = async (baseMint: PublicKey, wallet: Keypair) => {\r\n    try {\r\n        const tokenAta = await delayedCall(\r\n            getAssociatedTokenAddress,\r\n            baseMint,\r\n            wallet.publicKey\r\n        );\r\n        const tokenBalInfo: RpcResponseAndContext<TokenAmount> =\r\n            await delayedCall(\r\n                connection.getTokenAccountBalance.bind(connection),\r\n                tokenAta\r\n            );\r\n\r\n        if (!tokenBalInfo) {\r\n            console.log(\"Balance incorrect\");\r\n            return null;\r\n        }\r\n\r\n        const tokenBalance = tokenBalInfo.value.amount;\r\n        if (tokenBalance === \"0\") {\r\n            console.warn(\r\n                `No token balance to sell with wallet ${wallet.publicKey}`\r\n            );\r\n        }\r\n\r\n        const buyTransaction = await getSwapTxWithWithJupiter(\r\n            wallet,\r\n            baseMint,\r\n            tokenBalance,\r\n            \"buy\"\r\n        );\r\n        // simulate the transaction\r\n        if (!buyTransaction) {\r\n            console.log(\"Failed to get buy transaction\");\r\n            return null;\r\n        }\r\n\r\n        const simulateResult: RpcResponseAndContext<SimulatedTransactionResponse> =\r\n            await delayedCall(\r\n                connection.simulateTransaction.bind(connection),\r\n                buyTransaction\r\n            );\r\n        if (simulateResult.value.err) {\r\n            console.log(\"Buy Simulation failed\", simulateResult.value.err);\r\n            return null;\r\n        }\r\n\r\n        // execute the transaction\r\n        return executeSwap(buyTransaction, \"buy\");\r\n    } catch (error) {\r\n        console.log(error);\r\n    }\r\n};\r\n\r\nexport const getSwapTxWithWithJupiter = async (\r\n    wallet: Keypair,\r\n    baseMint: PublicKey,\r\n    amount: string,\r\n    type: \"buy\" | \"sell\"\r\n) => {\r\n    try {\r\n        switch (type) {\r\n            case \"buy\":\r\n                return fetchBuyTransaction(wallet, baseMint, amount);\r\n            case \"sell\":\r\n                return fetchSellTransaction(wallet, baseMint, amount);\r\n            default:\r\n                return fetchSellTransaction(wallet, baseMint, amount);\r\n        }\r\n    } catch (error) {\r\n        console.log(error);\r\n    }\r\n};\r\n\r\nexport const fetchBuyTransaction = async (\r\n    wallet: Keypair,\r\n    baseMint: PublicKey,\r\n    amount: string\r\n) => {\r\n    try {\r\n        const quoteResponse = await (\r\n            await fetch(\r\n                `https://quote-api.jup.ag/v6/quote?inputMint=${solAddress}&outputMint=${baseMint.toBase58()}&amount=${amount}&slippageBps=${SLIPPAGE}`\r\n            )\r\n        ).json();\r\n        const { swapTransaction } = await (\r\n            await fetch(\"https://quote-api.jup.ag/v6/swap\", {\r\n                method: \"POST\",\r\n                headers: {\r\n                    \"Content-Type\": \"application/json\",\r\n                },\r\n                body: JSON.stringify({\r\n                    quoteResponse,\r\n                    userPublicKey: wallet.publicKey.toString(),\r\n                    wrapAndUnwrapSol: true,\r\n                    dynamicComputeUnitLimit: true,\r\n                    prioritizationFeeLamports: 100000,\r\n                }),\r\n            })\r\n        ).json();\r\n        if (!swapTransaction) {\r\n            console.log(\"Failed to get buy transaction\");\r\n            return null;\r\n        }\r\n\r\n        // deserialize the transaction\r\n        const swapTransactionBuf = Buffer.from(swapTransaction, \"base64\");\r\n        const transaction =\r\n            VersionedTransaction.deserialize(swapTransactionBuf);\r\n\r\n        // sign the transaction\r\n        transaction.sign([wallet]);\r\n        return transaction;\r\n    } catch (error) {\r\n        console.log(\"Failed to get buy transaction\", error);\r\n        return null;\r\n    }\r\n};\r\n\r\nexport const fetchSellTransaction = async (\r\n    wallet: Keypair,\r\n    baseMint: PublicKey,\r\n    amount: string\r\n) => {\r\n    try {\r\n        const quoteResponse = await (\r\n            await fetch(\r\n                `https://quote-api.jup.ag/v6/quote?inputMint=${baseMint.toBase58()}&outputMint=${solAddress}&amount=${amount}&slippageBps=${SLIPPAGE}`\r\n            )\r\n        ).json();\r\n\r\n        // get serialized transactions for the swap\r\n        const { swapTransaction } = await (\r\n            await fetch(\"https://quote-api.jup.ag/v6/swap\", {\r\n                method: \"POST\",\r\n                headers: {\r\n                    \"Content-Type\": \"application/json\",\r\n                },\r\n                body: JSON.stringify({\r\n                    quoteResponse,\r\n                    userPublicKey: wallet.publicKey.toString(),\r\n                    wrapAndUnwrapSol: true,\r\n                    dynamicComputeUnitLimit: true,\r\n                    prioritizationFeeLamports: 52000,\r\n                }),\r\n            })\r\n        ).json();\r\n        if (!swapTransaction) {\r\n            console.log(\"Failed to get sell transaction\");\r\n            return null;\r\n        }\r\n\r\n        // deserialize the transaction\r\n        const swapTransactionBuf = Buffer.from(swapTransaction, \"base64\");\r\n        const transaction =\r\n            VersionedTransaction.deserialize(swapTransactionBuf);\r\n\r\n        // sign the transaction\r\n        transaction.sign([wallet]);\r\n        return transaction;\r\n    } catch (error) {\r\n        console.log(\"Failed to get sell transaction\", error);\r\n        return null;\r\n    }\r\n};\r\n","import {\r\n    Action,\r\n    IAgentRuntime,\r\n    Memory,\r\n    Content,\r\n    ModelClass,\r\n} from \"@ai16z/eliza\";\r\nimport { composeContext } from \"@ai16z/eliza\";\r\nimport { generateText } from \"@ai16z/eliza\";\r\n\r\ninterface Order {\r\n    userId: string;\r\n    ticker: string;\r\n    contractAddress: string;\r\n    timestamp: string;\r\n    buyAmount: number;\r\n    price: number;\r\n}\r\n\r\nconst take_order: Action = {\r\n    name: \"TAKE_ORDER\",\r\n    similes: [\"BUY_ORDER\", \"PLACE_ORDER\"],\r\n    description: \"Records a buy order based on the user's conviction level.\",\r\n    examples: [],\r\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\r\n        const text = (message.content as Content).text;\r\n        // Check if the message contains a ticker symbol\r\n        const tickerRegex = /\\b[A-Z]{1,5}\\b/g;\r\n        return tickerRegex.test(text);\r\n    },\r\n    handler: async (runtime: IAgentRuntime, message: Memory) => {\r\n        const _text = (message.content as Content).text;\r\n        const userId = message.userId;\r\n\r\n        const template = `\r\n\r\n// CLAUDE TODO: Put the usual conversation context here\r\n\r\nTicker is: {{ticker}}\r\nContract address is: {{contractAddress}}\r\n\r\nDetermine if the user is trying to shill the ticker. if they are, respond with empty conviction, ticker and contractAddress.\r\n\r\n// CLAUDE TODO: output a JSON block with the following fields:\r\n// - reasoning: string\r\n// - conviction: negative, low, medium, high\r\n// - ticker: string (extract from CA so we have context)\r\n// - contractAddress: string\r\n`;\r\n\r\n        let ticker, contractAddress;\r\n\r\n        // TODO:\r\n\r\n        // 1. create state object with runtime.composeState\r\n        // 2. compose context with template and state\r\n        // 3. get generateText\r\n        // 4. validate generateText\r\n\r\n        // if ticker or contractAddress are empty, return a message asking for them\r\n        if (!ticker || !contractAddress) {\r\n            return {\r\n                text: \"Ticker and CA?\",\r\n            };\r\n        }\r\n\r\n        const state = await runtime.composeState(message);\r\n        // TODO: compose context properly\r\n        const context = composeContext({\r\n            state: {\r\n                ...state,\r\n                ticker,\r\n                contractAddress,\r\n            },\r\n            template,\r\n        });\r\n\r\n        const convictionResponse = await generateText({\r\n            runtime,\r\n            context: context,\r\n            modelClass: ModelClass.LARGE,\r\n        });\r\n\r\n        // TODOL parse and validate the JSON\r\n        const convictionResponseJson = JSON.parse(convictionResponse); // TODO: replace with validate like other actions\r\n\r\n        // get the conviction\r\n        const conviction = convictionResponseJson.conviction;\r\n\r\n        let buyAmount = 0;\r\n        if (conviction === \"low\") {\r\n            buyAmount = 20;\r\n        } else if (conviction === \"medium\") {\r\n            buyAmount = 50;\r\n        } else if (conviction === \"high\") {\r\n            buyAmount = 100;\r\n        }\r\n\r\n        // Get the current price of the asset (replace with actual price fetching logic)\r\n        const currentPrice = 100;\r\n\r\n        const order: Order = {\r\n            userId,\r\n            ticker: ticker || \"\",\r\n            contractAddress,\r\n            timestamp: new Date().toISOString(),\r\n            buyAmount,\r\n            price: currentPrice,\r\n        };\r\n\r\n        // Read the existing order book from the JSON file\r\n        const orderBookPath =\r\n            runtime.getSetting(\"orderBookPath\") ?? \"solana/orderBook.json\";\r\n\r\n        const orderBook: Order[] = [];\r\n\r\n        const cachedOrderBook =\r\n            await runtime.cacheManager.get<Order[]>(orderBookPath);\r\n\r\n        if (cachedOrderBook) {\r\n            orderBook.push(...cachedOrderBook);\r\n        }\r\n\r\n        // Add the new order to the order book\r\n        orderBook.push(order);\r\n\r\n        // Write the updated order book back to the JSON file\r\n        await runtime.cacheManager.set(orderBookPath, orderBook);\r\n\r\n        return {\r\n            text: `Recorded a ${conviction} conviction buy order for ${ticker} (${contractAddress}) with an amount of ${buyAmount} at the price of ${currentPrice}.`,\r\n        };\r\n    },\r\n};\r\n\r\nexport default take_order;\r\n","import { AnchorProvider } from \"@coral-xyz/anchor\";\r\nimport { Wallet } from \"@coral-xyz/anchor\";\r\nimport { generateImage } from \"@ai16z/eliza\";\r\nimport { Connection, Keypair, PublicKey } from \"@solana/web3.js\";\r\nimport { CreateTokenMetadata, PriorityFee, PumpFunSDK } from \"pumpdotfun-sdk\";\r\n\r\nimport { getAssociatedTokenAddressSync } from \"@solana/spl-token\";\r\nimport bs58 from \"bs58\";\r\nimport {\r\n    settings,\r\n    ActionExample,\r\n    Content,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Memory,\r\n    ModelClass,\r\n    State,\r\n    generateObject,\r\n    composeContext,\r\n    type Action,\r\n} from \"@ai16z/eliza\";\r\n\r\nimport { walletProvider } from \"../providers/wallet.ts\";\r\n\r\nexport interface CreateAndBuyContent extends Content {\r\n    tokenMetadata: {\r\n        name: string;\r\n        symbol: string;\r\n        description: string;\r\n        image_description: string;\r\n    };\r\n    buyAmountSol: string | number;\r\n}\r\n\r\nexport function isCreateAndBuyContent(\r\n    runtime: IAgentRuntime,\r\n    content: any\r\n): content is CreateAndBuyContent {\r\n    console.log(\"Content for create & buy\", content);\r\n    return (\r\n        typeof content.tokenMetadata === \"object\" &&\r\n        content.tokenMetadata !== null &&\r\n        typeof content.tokenMetadata.name === \"string\" &&\r\n        typeof content.tokenMetadata.symbol === \"string\" &&\r\n        typeof content.tokenMetadata.description === \"string\" &&\r\n        typeof content.tokenMetadata.image_description === \"string\" &&\r\n        (typeof content.buyAmountSol === \"string\" ||\r\n            typeof content.buyAmountSol === \"number\")\r\n    );\r\n}\r\n\r\nexport const createAndBuyToken = async ({\r\n    deployer,\r\n    mint,\r\n    tokenMetadata,\r\n    buyAmountSol,\r\n    priorityFee,\r\n    allowOffCurve,\r\n    commitment = \"finalized\",\r\n    sdk,\r\n    connection,\r\n    slippage,\r\n}: {\r\n    deployer: Keypair;\r\n    mint: Keypair;\r\n    tokenMetadata: CreateTokenMetadata;\r\n    buyAmountSol: bigint;\r\n    priorityFee: PriorityFee;\r\n    allowOffCurve: boolean;\r\n    commitment?:\r\n        | \"processed\"\r\n        | \"confirmed\"\r\n        | \"finalized\"\r\n        | \"recent\"\r\n        | \"single\"\r\n        | \"singleGossip\"\r\n        | \"root\"\r\n        | \"max\";\r\n    sdk: PumpFunSDK;\r\n    connection: Connection;\r\n    slippage: string;\r\n}) => {\r\n    const createResults = await sdk.createAndBuy(\r\n        deployer,\r\n        mint,\r\n        tokenMetadata,\r\n        buyAmountSol,\r\n        BigInt(slippage),\r\n        priorityFee,\r\n        commitment\r\n    );\r\n\r\n    console.log(\"Create Results: \", createResults);\r\n\r\n    if (createResults.success) {\r\n        console.log(\r\n            \"Success:\",\r\n            `https://pump.fun/${mint.publicKey.toBase58()}`\r\n        );\r\n        const ata = getAssociatedTokenAddressSync(\r\n            mint.publicKey,\r\n            deployer.publicKey,\r\n            allowOffCurve\r\n        );\r\n        const balance = await connection.getTokenAccountBalance(\r\n            ata,\r\n            \"processed\"\r\n        );\r\n        const amount = balance.value.uiAmount;\r\n        if (amount === null) {\r\n            console.log(\r\n                `${deployer.publicKey.toBase58()}:`,\r\n                \"No Account Found\"\r\n            );\r\n        } else {\r\n            console.log(`${deployer.publicKey.toBase58()}:`, amount);\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            ca: mint.publicKey.toBase58(),\r\n            creator: deployer.publicKey.toBase58(),\r\n        };\r\n    } else {\r\n        console.log(\"Create and Buy failed\");\r\n        return {\r\n            success: false,\r\n            ca: mint.publicKey.toBase58(),\r\n            error: createResults.error || \"Transaction failed\",\r\n        };\r\n    }\r\n};\r\n\r\nexport const buyToken = async ({\r\n    sdk,\r\n    buyer,\r\n    mint,\r\n    amount,\r\n    priorityFee,\r\n    allowOffCurve,\r\n    slippage,\r\n    connection,\r\n}: {\r\n    sdk: PumpFunSDK;\r\n    buyer: Keypair;\r\n    mint: PublicKey;\r\n    amount: bigint;\r\n    priorityFee: PriorityFee;\r\n    allowOffCurve: boolean;\r\n    slippage: string;\r\n    connection: Connection;\r\n}) => {\r\n    const buyResults = await sdk.buy(\r\n        buyer,\r\n        mint,\r\n        amount,\r\n        BigInt(slippage),\r\n        priorityFee\r\n    );\r\n    if (buyResults.success) {\r\n        console.log(\"Success:\", `https://pump.fun/${mint.toBase58()}`);\r\n        const ata = getAssociatedTokenAddressSync(\r\n            mint,\r\n            buyer.publicKey,\r\n            allowOffCurve\r\n        );\r\n        const balance = await connection.getTokenAccountBalance(\r\n            ata,\r\n            \"processed\"\r\n        );\r\n        const amount = balance.value.uiAmount;\r\n        if (amount === null) {\r\n            console.log(`${buyer.publicKey.toBase58()}:`, \"No Account Found\");\r\n        } else {\r\n            console.log(`${buyer.publicKey.toBase58()}:`, amount);\r\n        }\r\n    } else {\r\n        console.log(\"Buy failed\");\r\n    }\r\n};\r\n\r\nexport const sellToken = async ({\r\n    sdk,\r\n    seller,\r\n    mint,\r\n    amount,\r\n    priorityFee,\r\n    allowOffCurve,\r\n    slippage,\r\n    connection,\r\n}: {\r\n    sdk: PumpFunSDK;\r\n    seller: Keypair;\r\n    mint: PublicKey;\r\n    amount: bigint;\r\n    priorityFee: PriorityFee;\r\n    allowOffCurve: boolean;\r\n    slippage: string;\r\n    connection: Connection;\r\n}) => {\r\n    const sellResults = await sdk.sell(\r\n        seller,\r\n        mint,\r\n        amount,\r\n        BigInt(slippage),\r\n        priorityFee\r\n    );\r\n    if (sellResults.success) {\r\n        console.log(\"Success:\", `https://pump.fun/${mint.toBase58()}`);\r\n        const ata = getAssociatedTokenAddressSync(\r\n            mint,\r\n            seller.publicKey,\r\n            allowOffCurve\r\n        );\r\n        const balance = await connection.getTokenAccountBalance(\r\n            ata,\r\n            \"processed\"\r\n        );\r\n        const amount = balance.value.uiAmount;\r\n        if (amount === null) {\r\n            console.log(`${seller.publicKey.toBase58()}:`, \"No Account Found\");\r\n        } else {\r\n            console.log(`${seller.publicKey.toBase58()}:`, amount);\r\n        }\r\n    } else {\r\n        console.log(\"Sell failed\");\r\n    }\r\n};\r\n\r\n// previous logic:\r\n// if (typeof window !== \"undefined\" && typeof window.confirm === \"function\") {\r\n//     return window.confirm(\r\n//         \"Confirm the creation and purchase of the token?\"\r\n//     );\r\n// }\r\n// return true;\r\nconst promptConfirmation = async (): Promise<boolean> => {\r\n    return true;\r\n};\r\n\r\n// Save the base64 data to a file\r\nimport * as fs from \"fs\";\r\nimport * as path from \"path\";\r\n\r\nconst pumpfunTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\r\n\r\nExample response:\r\n\\`\\`\\`json\r\n{\r\n    \"tokenMetadata\": {\r\n        \"name\": \"Test Token\",\r\n        \"symbol\": \"TEST\",\r\n        \"description\": \"A test token\",\r\n        \"image_description\": \"create an image of a rabbit\"\r\n    },\r\n    \"buyAmountSol\": \"0.00069\"\r\n}\r\n\\`\\`\\`\r\n\r\n{{recentMessages}}\r\n\r\nGiven the recent messages, extract or generate (come up with if not included) the following information about the requested token creation:\r\n- Token name\r\n- Token symbol\r\n- Token description \r\n- Token image description \r\n- Amount of SOL to buy\r\n\r\nRespond with a JSON markdown block containing only the extracted values.`;\r\n\r\nexport default {\r\n    name: \"CREATE_AND_BUY_TOKEN\",\r\n    similes: [\"CREATE_AND_PURCHASE_TOKEN\", \"DEPLOY_AND_BUY_TOKEN\"],\r\n    validate: async (_runtime: IAgentRuntime, _message: Memory) => {\r\n        return true; //return isCreateAndBuyContent(runtime, message.content);\r\n    },\r\n    description:\r\n        \"Create a new token and buy a specified amount using SOL. Requires deployer private key, token metadata, buy amount in SOL, priority fee, and allowOffCurve flag.\",\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        _options: { [key: string]: unknown },\r\n        callback?: HandlerCallback\r\n    ): Promise<boolean> => {\r\n        console.log(\"Starting CREATE_AND_BUY_TOKEN handler...\");\r\n\r\n        // Compose state if not provided\r\n        if (!state) {\r\n            state = (await runtime.composeState(message)) as State;\r\n        } else {\r\n            state = await runtime.updateRecentMessageState(state);\r\n        }\r\n\r\n        // Get wallet info for context\r\n        const walletInfo = await walletProvider.get(runtime, message, state);\r\n        state.walletInfo = walletInfo;\r\n\r\n        // Generate structured content from natural language\r\n        const pumpContext = composeContext({\r\n            state,\r\n            template: pumpfunTemplate,\r\n        });\r\n\r\n        const content = await generateObject({\r\n            runtime,\r\n            context: pumpContext,\r\n            modelClass: ModelClass.LARGE,\r\n        });\r\n\r\n        // Validate the generated content\r\n        if (!isCreateAndBuyContent(runtime, content)) {\r\n            console.error(\"Invalid content for CREATE_AND_BUY_TOKEN action.\");\r\n            return false;\r\n        }\r\n\r\n        const { tokenMetadata, buyAmountSol } = content;\r\n        /*\r\n            // Generate image if tokenMetadata.file is empty or invalid\r\n            if (!tokenMetadata.file || tokenMetadata.file.length < 100) {  // Basic validation\r\n                try {\r\n                    const imageResult = await generateImage({\r\n                        prompt: `logo for ${tokenMetadata.name} (${tokenMetadata.symbol}) token - ${tokenMetadata.description}`,\r\n                        width: 512,\r\n                        height: 512,\r\n                        count: 1\r\n                    }, runtime);\r\n        \r\n                    if (imageResult.success && imageResult.data && imageResult.data.length > 0) {\r\n                        // Remove the \"data:image/png;base64,\" prefix if present\r\n                        tokenMetadata.file = imageResult.data[0].replace(/^data:image\\/[a-z]+;base64,/, '');\r\n                    } else {\r\n                        console.error(\"Failed to generate image:\", imageResult.error);\r\n                        return false;\r\n                    }\r\n                } catch (error) {\r\n                    console.error(\"Error generating image:\", error);\r\n                    return false;\r\n                }\r\n            } */\r\n\r\n        const imageResult = await generateImage(\r\n            {\r\n                prompt: `logo for ${tokenMetadata.name} (${tokenMetadata.symbol}) token - ${tokenMetadata.description}`,\r\n                width: 256,\r\n                height: 256,\r\n                count: 1,\r\n            },\r\n            runtime\r\n        );\r\n\r\n        tokenMetadata.image_description = imageResult.data[0].replace(\r\n            /^data:image\\/[a-z]+;base64,/,\r\n            \"\"\r\n        );\r\n\r\n        // Convert base64 string to Blob\r\n        const base64Data = tokenMetadata.image_description;\r\n        const outputPath = path.join(\r\n            process.cwd(),\r\n            `generated_image_${Date.now()}.txt`\r\n        );\r\n        fs.writeFileSync(outputPath, base64Data);\r\n        console.log(`Base64 data saved to: ${outputPath}`);\r\n\r\n        const byteCharacters = atob(base64Data);\r\n        const byteNumbers = new Array(byteCharacters.length);\r\n        for (let i = 0; i < byteCharacters.length; i++) {\r\n            byteNumbers[i] = byteCharacters.charCodeAt(i);\r\n        }\r\n        const byteArray = new Uint8Array(byteNumbers);\r\n        const blob = new Blob([byteArray], { type: \"image/png\" });\r\n\r\n        // Add the default decimals and convert file to Blob\r\n        const fullTokenMetadata: CreateTokenMetadata = {\r\n            name: tokenMetadata.name,\r\n            symbol: tokenMetadata.symbol,\r\n            description: tokenMetadata.description,\r\n            file: blob,\r\n        };\r\n\r\n        // Default priority fee for high network load\r\n        const priorityFee = {\r\n            unitLimit: 100_000_000,\r\n            unitPrice: 100_000,\r\n        };\r\n        const slippage = \"2000\";\r\n        try {\r\n            // Get private key from settings and create deployer keypair\r\n            const privateKeyString =\r\n                runtime.getSetting(\"SOLANA_PRIVATE_KEY\") ??\r\n                runtime.getSetting(\"WALLET_PRIVATE_KEY\");\r\n            const secretKey = bs58.decode(privateKeyString);\r\n            const deployerKeypair = Keypair.fromSecretKey(secretKey);\r\n\r\n            // Generate new mint keypair\r\n            const mintKeypair = Keypair.generate();\r\n            console.log(\r\n                `Generated mint address: ${mintKeypair.publicKey.toBase58()}`\r\n            );\r\n\r\n            // Setup connection and SDK\r\n            const connection = new Connection(settings.RPC_URL!, {\r\n                commitment: \"confirmed\",\r\n                confirmTransactionInitialTimeout: 500000, // 120 seconds\r\n                wsEndpoint: settings.RPC_URL!.replace(\"https\", \"wss\"),\r\n            });\r\n\r\n            const wallet = new Wallet(deployerKeypair);\r\n            const provider = new AnchorProvider(connection, wallet, {\r\n                commitment: \"finalized\",\r\n            });\r\n            const sdk = new PumpFunSDK(provider);\r\n            // const slippage = runtime.getSetting(\"SLIPPAGE\");\r\n\r\n            const createAndBuyConfirmation = await promptConfirmation();\r\n            if (!createAndBuyConfirmation) {\r\n                console.log(\"Create and buy token canceled by user\");\r\n                return false;\r\n            }\r\n\r\n            // Convert SOL to lamports (1 SOL = 1_000_000_000 lamports)\r\n            const lamports = Math.floor(Number(buyAmountSol) * 1_000_000_000);\r\n\r\n            console.log(\"Executing create and buy transaction...\");\r\n            const result = await createAndBuyToken({\r\n                deployer: deployerKeypair,\r\n                mint: mintKeypair,\r\n                tokenMetadata: fullTokenMetadata,\r\n                buyAmountSol: BigInt(lamports),\r\n                priorityFee,\r\n                allowOffCurve: false,\r\n                sdk,\r\n                connection,\r\n                slippage,\r\n            });\r\n\r\n            if (callback) {\r\n                if (result.success) {\r\n                    callback({\r\n                        text: `Token ${tokenMetadata.name} (${tokenMetadata.symbol}) created successfully!\\nContract Address: ${result.ca}\\nCreator: ${result.creator}\\nView at: https://pump.fun/${result.ca}`,\r\n                        content: {\r\n                            tokenInfo: {\r\n                                symbol: tokenMetadata.symbol,\r\n                                address: result.ca,\r\n                                creator: result.creator,\r\n                                name: tokenMetadata.name,\r\n                                description: tokenMetadata.description,\r\n                                timestamp: Date.now(),\r\n                            },\r\n                        },\r\n                    });\r\n                } else {\r\n                    callback({\r\n                        text: `Failed to create token: ${result.error}\\nAttempted mint address: ${result.ca}`,\r\n                        content: {\r\n                            error: result.error,\r\n                            mintAddress: result.ca,\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n            //await trustScoreDb.addToken(tokenInfo);\r\n            /*\r\n                // Update runtime state\r\n                await runtime.updateState({\r\n                    ...state,\r\n                    lastCreatedToken: tokenInfo\r\n                });\r\n                */\r\n            // Log success message with token view URL\r\n            const successMessage = `Token created and purchased successfully! View at: https://pump.fun/${mintKeypair.publicKey.toBase58()}`;\r\n            console.log(successMessage);\r\n            return result.success;\r\n        } catch (error) {\r\n            if (callback) {\r\n                callback({\r\n                    text: `Error during token creation: ${error.message}`,\r\n                    content: { error: error.message },\r\n                });\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Create a new token called GLITCHIZA with symbol GLITCHIZA and generate a description about it. Also come up with a description for it to use for image generation .buy 0.00069 SOL worth.\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Token GLITCHIZA (GLITCHIZA) created successfully!\\nContract Address: 3kD5DN4bbA3nykb1abjS66VF7cYZkKdirX8bZ6ShJjBB\\nCreator: 9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa\\nView at: https://pump.fun/EugPwuZ8oUMWsYHeBGERWvELfLGFmA1taDtmY8uMeX6r\",\r\n                    action: \"CREATE_AND_BUY_TOKEN\",\r\n                    content: {\r\n                        tokenInfo: {\r\n                            symbol: \"GLITCHIZA\",\r\n                            address:\r\n                                \"EugPwuZ8oUMWsYHeBGERWvELfLGFmA1taDtmY8uMeX6r\",\r\n                            creator:\r\n                                \"9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa\",\r\n                            name: \"GLITCHIZA\",\r\n                            description: \"A GLITCHIZA token\",\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n","import {\r\n    ActionExample,\r\n    IAgentRuntime,\r\n    Memory,\r\n    type Action,\r\n} from \"@ai16z/eliza\";\r\nimport { Connection, Keypair, PublicKey, Transaction } from \"@solana/web3.js\";\r\nimport { getQuote } from \"./swapUtils.ts\";\r\n\r\nasync function invokeSwapDao(\r\n    connection: Connection,\r\n    authority: Keypair,\r\n    statePDA: PublicKey,\r\n    walletPDA: PublicKey,\r\n    instructionData: Buffer\r\n): Promise<string> {\r\n    const discriminator = new Uint8Array([\r\n        25, 143, 207, 190, 174, 228, 130, 107,\r\n    ]);\r\n\r\n    // Combine discriminator and instructionData into a single Uint8Array\r\n    const combinedData = new Uint8Array(\r\n        discriminator.length + instructionData.length\r\n    );\r\n    combinedData.set(discriminator, 0);\r\n    combinedData.set(instructionData, discriminator.length);\r\n\r\n    const transaction = new Transaction().add({\r\n        programId: new PublicKey(\"PROGRAM_ID\"),\r\n        keys: [\r\n            { pubkey: authority.publicKey, isSigner: true, isWritable: true },\r\n            { pubkey: statePDA, isSigner: false, isWritable: true },\r\n            { pubkey: walletPDA, isSigner: false, isWritable: true },\r\n        ],\r\n        data: Buffer.from(combinedData),\r\n    });\r\n\r\n    const signature = await connection.sendTransaction(transaction, [\r\n        authority,\r\n    ]);\r\n    await connection.confirmTransaction(signature);\r\n    return signature;\r\n}\r\n\r\nasync function promptConfirmation(): Promise<boolean> {\r\n    // confirmation logic here\r\n    const confirmSwap = window.confirm(\"Confirm the token swap?\");\r\n    return confirmSwap;\r\n}\r\n\r\nexport const executeSwapForDAO: Action = {\r\n    name: \"EXECUTE_SWAP_DAO\",\r\n    similes: [\"SWAP_TOKENS_DAO\", \"TOKEN_SWAP_DAO\"],\r\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\r\n        console.log(\"Message:\", message);\r\n        return true;\r\n    },\r\n    description: \"Perform a DAO token swap using execute_invoke.\",\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory\r\n    ): Promise<boolean> => {\r\n        const { inputToken, outputToken, amount } = message.content;\r\n\r\n        try {\r\n            const connection = new Connection(\r\n                runtime.getSetting(\"RPC_URL\") as string\r\n            );\r\n            const authority = Keypair.fromSecretKey(\r\n                Uint8Array.from(\r\n                    Buffer.from(\r\n                        runtime.getSetting(\"SOLANA_PRIVATE_KEY\") ??\r\n                            runtime.getSetting(\"WALLET_PRIVATE_KEY\"), // should be the authority private key\r\n                        \"base64\"\r\n                    )\r\n                )\r\n            );\r\n            const daoMint = new PublicKey(runtime.getSetting(\"DAO_MINT\")); // DAO mint address\r\n\r\n            // Derive PDAs\r\n            const [statePDA] = await PublicKey.findProgramAddress(\r\n                [Buffer.from(\"state\"), daoMint.toBuffer()],\r\n                authority.publicKey\r\n            );\r\n            const [walletPDA] = await PublicKey.findProgramAddress(\r\n                [Buffer.from(\"wallet\"), daoMint.toBuffer()],\r\n                authority.publicKey\r\n            );\r\n\r\n            const quoteData = await getQuote(\r\n                connection as Connection,\r\n                inputToken as string,\r\n                outputToken as string,\r\n                amount as number\r\n            );\r\n            console.log(\"Swap Quote:\", quoteData);\r\n\r\n            const confirmSwap = await promptConfirmation();\r\n            if (!confirmSwap) {\r\n                console.log(\"Swap canceled by user\");\r\n                return false;\r\n            }\r\n\r\n            // Prepare instruction data for swap\r\n            const instructionData = Buffer.from(\r\n                JSON.stringify({\r\n                    quote: quoteData.data,\r\n                    userPublicKey: authority.publicKey.toString(),\r\n                    wrapAndUnwrapSol: true,\r\n                })\r\n            );\r\n\r\n            const txid = await invokeSwapDao(\r\n                connection,\r\n                authority,\r\n                statePDA,\r\n                walletPDA,\r\n                instructionData\r\n            );\r\n\r\n            console.log(\"DAO Swap completed successfully!\");\r\n            console.log(`Transaction ID: ${txid}`);\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error(\"Error during DAO token swap:\", error);\r\n            return false;\r\n        }\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    inputTokenSymbol: \"SOL\",\r\n                    outputTokenSymbol: \"USDC\",\r\n                    inputToken: \"So11111111111111111111111111111111111111112\",\r\n                    outputToken: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\r\n                    amount: 0.1,\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Swapping 0.1 SOL for USDC using DAO...\",\r\n                    action: \"TOKEN_SWAP_DAO\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"DAO Swap completed successfully! Transaction ID: ...\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n","import {\r\n    getAssociatedTokenAddressSync,\r\n    createTransferInstruction,\r\n} from \"@solana/spl-token\";\r\nimport bs58 from \"bs58\";\r\nimport { elizaLogger, settings } from \"@ai16z/eliza\";\r\n\r\nimport {\r\n    Connection,\r\n    Keypair,\r\n    PublicKey,\r\n    TransactionMessage,\r\n    VersionedTransaction,\r\n} from \"@solana/web3.js\";\r\n\r\nimport {\r\n    ActionExample,\r\n    Content,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Memory,\r\n    ModelClass,\r\n    State,\r\n    type Action,\r\n} from \"@ai16z/eliza\";\r\nimport { composeContext } from \"@ai16z/eliza\";\r\nimport { generateObject } from \"@ai16z/eliza\";\r\n\r\nexport interface TransferContent extends Content {\r\n    tokenAddress: string;\r\n    recipient: string;\r\n    amount: string | number;\r\n}\r\n\r\nfunction isTransferContent(\r\n    runtime: IAgentRuntime,\r\n    content: any\r\n): content is TransferContent {\r\n    console.log(\"Content for transfer\", content);\r\n    return (\r\n        typeof content.tokenAddress === \"string\" &&\r\n        typeof content.recipient === \"string\" &&\r\n        (typeof content.amount === \"string\" ||\r\n            typeof content.amount === \"number\")\r\n    );\r\n}\r\n\r\nconst transferTemplate = `Respond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined.\r\n\r\nExample response:\r\n\\`\\`\\`json\r\n{\r\n    \"tokenAddress\": \"BieefG47jAHCGZBxi2q87RDuHyGZyYC3vAzxpyu8pump\",\r\n    \"recipient\": \"9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa\",\r\n    \"amount\": \"1000\"\r\n}\r\n\\`\\`\\`\r\n\r\n{{recentMessages}}\r\n\r\nGiven the recent messages, extract the following information about the requested token transfer:\r\n- Token contract address\r\n- Recipient wallet address\r\n- Amount to transfer\r\n\r\nRespond with a JSON markdown block containing only the extracted values.`;\r\n\r\nexport default {\r\n    name: \"SEND_TOKEN\",\r\n    similes: [\r\n        \"TRANSFER_TOKEN\",\r\n        \"TRANSFER_TOKENS\",\r\n        \"SEND_TOKENS\",\r\n        \"SEND_SOL\",\r\n        \"PAY\",\r\n    ],\r\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\r\n        console.log(\"Validating transfer from user:\", message.userId);\r\n        //add custom validate logic here\r\n        /*\r\n            const adminIds = runtime.getSetting(\"ADMIN_USER_IDS\")?.split(\",\") || [];\r\n            //console.log(\"Admin IDs from settings:\", adminIds);\r\n\r\n            const isAdmin = adminIds.includes(message.userId);\r\n\r\n            if (isAdmin) {\r\n                //console.log(`Authorized transfer from user: ${message.userId}`);\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                //console.log(`Unauthorized transfer attempt from user: ${message.userId}`);\r\n                return false;\r\n            }\r\n            */\r\n        return false;\r\n    },\r\n    description: \"Transfer tokens from the agent's wallet to another address\",\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        _options: { [key: string]: unknown },\r\n        callback?: HandlerCallback\r\n    ): Promise<boolean> => {\r\n        elizaLogger.log(\"Starting SEND_TOKEN handler...\");\r\n\r\n        // Initialize or update state\r\n        if (!state) {\r\n            state = (await runtime.composeState(message)) as State;\r\n        } else {\r\n            state = await runtime.updateRecentMessageState(state);\r\n        }\r\n\r\n        // Compose transfer context\r\n        const transferContext = composeContext({\r\n            state,\r\n            template: transferTemplate,\r\n        });\r\n\r\n        // Generate transfer content\r\n        const content = await generateObject({\r\n            runtime,\r\n            context: transferContext,\r\n            modelClass: ModelClass.LARGE,\r\n        });\r\n\r\n        // Validate transfer content\r\n        if (!isTransferContent(runtime, content)) {\r\n            console.error(\"Invalid content for TRANSFER_TOKEN action.\");\r\n            if (callback) {\r\n                callback({\r\n                    text: \"Unable to process transfer request. Invalid content provided.\",\r\n                    content: { error: \"Invalid transfer content\" },\r\n                });\r\n            }\r\n            return false;\r\n        }\r\n\r\n        try {\r\n            const privateKeyString =\r\n                runtime.getSetting(\"SOLANA_PRIVATE_KEY\") ??\r\n                runtime.getSetting(\"WALLET_PRIVATE_KEY\");\r\n            const secretKey = bs58.decode(privateKeyString);\r\n            const senderKeypair = Keypair.fromSecretKey(secretKey);\r\n\r\n            const connection = new Connection(settings.RPC_URL!);\r\n\r\n            const mintPubkey = new PublicKey(content.tokenAddress);\r\n            const recipientPubkey = new PublicKey(content.recipient);\r\n\r\n            // Get decimals (simplest way)\r\n            const mintInfo = await connection.getParsedAccountInfo(mintPubkey);\r\n            const decimals =\r\n                (mintInfo.value?.data as any)?.parsed?.info?.decimals ?? 9;\r\n\r\n            // Adjust amount with decimals\r\n            const adjustedAmount = BigInt(\r\n                Number(content.amount) * Math.pow(10, decimals)\r\n            );\r\n            console.log(\r\n                `Transferring: ${content.amount} tokens (${adjustedAmount} base units)`\r\n            );\r\n\r\n            // Rest of the existing working code...\r\n            const senderATA = getAssociatedTokenAddressSync(\r\n                mintPubkey,\r\n                senderKeypair.publicKey\r\n            );\r\n            const recipientATA = getAssociatedTokenAddressSync(\r\n                mintPubkey,\r\n                recipientPubkey\r\n            );\r\n\r\n            const instructions = [];\r\n\r\n            const recipientATAInfo =\r\n                await connection.getAccountInfo(recipientATA);\r\n            if (!recipientATAInfo) {\r\n                const { createAssociatedTokenAccountInstruction } =\r\n                    await import(\"@solana/spl-token\");\r\n                instructions.push(\r\n                    createAssociatedTokenAccountInstruction(\r\n                        senderKeypair.publicKey,\r\n                        recipientATA,\r\n                        recipientPubkey,\r\n                        mintPubkey\r\n                    )\r\n                );\r\n            }\r\n\r\n            instructions.push(\r\n                createTransferInstruction(\r\n                    senderATA,\r\n                    recipientATA,\r\n                    senderKeypair.publicKey,\r\n                    adjustedAmount\r\n                )\r\n            );\r\n\r\n            // Create and sign versioned transaction\r\n            const messageV0 = new TransactionMessage({\r\n                payerKey: senderKeypair.publicKey,\r\n                recentBlockhash: (await connection.getLatestBlockhash())\r\n                    .blockhash,\r\n                instructions,\r\n            }).compileToV0Message();\r\n\r\n            const transaction = new VersionedTransaction(messageV0);\r\n            transaction.sign([senderKeypair]);\r\n\r\n            // Send transaction\r\n            const signature = await connection.sendTransaction(transaction);\r\n\r\n            console.log(\"Transfer successful:\", signature);\r\n\r\n            if (callback) {\r\n                callback({\r\n                    text: `Successfully transferred ${content.amount} tokens to ${content.recipient}\\nTransaction: ${signature}`,\r\n                    content: {\r\n                        success: true,\r\n                        signature,\r\n                        amount: content.amount,\r\n                        recipient: content.recipient,\r\n                    },\r\n                });\r\n            }\r\n\r\n            return true;\r\n        } catch (error) {\r\n            console.error(\"Error during token transfer:\", error);\r\n            if (callback) {\r\n                callback({\r\n                    text: `Error transferring tokens: ${error.message}`,\r\n                    content: { error: error.message },\r\n                });\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Send 69 EZSIS BieefG47jAHCGZBxi2q87RDuHyGZyYC3vAzxpyu8pump to 9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"I'll send 69 EZSIS tokens now...\",\r\n                    action: \"SEND_TOKEN\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Successfully sent 69 EZSIS tokens to 9jW8FPr6BSSsemWPV22UUCzSqkVdTp6HTyPqeqyuBbCa\\nTransaction: 5KtPn3DXXzHkb7VAVHZGwXJQqww39ASnrf7YkyJoF2qAGEpBEEGvRHLnnTG8ZVwKqNHMqSckWVGnsQAgfH5pbxEb\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n","export * from \"./providers/token.ts\";\r\nexport * from \"./providers/wallet.ts\";\r\nexport * from \"./providers/trustScoreProvider.ts\";\r\nexport * from \"./evaluators/trust.ts\";\r\n\r\nimport { Plugin } from \"@ai16z/eliza\";\r\nimport { executeSwap } from \"./actions/swap.ts\";\r\nimport take_order from \"./actions/takeOrder\";\r\nimport pumpfun from \"./actions/pumpfun.ts\";\r\nimport { executeSwapForDAO } from \"./actions/swapDao\";\r\nimport transferToken from \"./actions/transfer.ts\";\r\nimport { walletProvider } from \"./providers/wallet.ts\";\r\nimport { trustScoreProvider } from \"./providers/trustScoreProvider.ts\";\r\nimport { trustEvaluator } from \"./evaluators/trust.ts\";\r\nimport { TokenProvider } from \"./providers/token.ts\";\r\nimport { WalletProvider } from \"./providers/wallet.ts\";\r\n\r\nexport { TokenProvider, WalletProvider };\r\n\r\nexport const solanaPlugin: Plugin = {\r\n    name: \"solana\",\r\n    description: \"Solana Plugin for Eliza\",\r\n    actions: [\r\n        executeSwap,\r\n        pumpfun,\r\n        transferToken,\r\n        executeSwapForDAO,\r\n        take_order,\r\n    ],\r\n    evaluators: [trustEvaluator],\r\n    providers: [walletProvider, trustScoreProvider],\r\n};\r\n\r\nexport default solanaPlugin;\r\n"],"mappings":"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","names":["NodeCache","BigNumber","connection","Connection","PublicKey","PROVIDER_CONFIG","tokenAddress","walletProvider","NodeCache","Connection","PublicKey","Connection","PublicKey","Connection","PublicKey","tokenAddress","tokenProvider","process","settings","crypto","settings","tokenProvider","Connection","PublicKey","tokenAddress","TrustScoreDatabase","Connection","PublicKey","walletProvider","tokenProvider","tokenAddress","user","Connection","Keypair","PublicKey","VersionedTransaction","BigNumber","TrustScoreDatabase","ModelClass","composeContext","settings","getAssociatedTokenAddress","Connection","PublicKey","settings","connection","connection","PublicKey","connection","settings","BigNumber","walletProvider","Connection","PublicKey","composeContext","ModelClass","VersionedTransaction","Keypair","tokenProvider","TrustScoreDatabase","ModelClass","composeContext","Wallet","Connection","Keypair","bs58","settings","ModelClass","generateObject","composeContext","path","connection","composeContext","generateObject","ModelClass","bs58","Keypair","connection","Connection","settings","Wallet","Connection","Keypair","PublicKey","connection","PublicKey","promptConfirmation","Connection","Keypair","getAssociatedTokenAddressSync","bs58","settings","Connection","Keypair","PublicKey","VersionedTransaction","ModelClass","composeContext","generateObject","connection"]}