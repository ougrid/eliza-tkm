{"version":3,"sources":["../src/services/browser.ts","../src/services/image.ts","../src/services/llama.ts","../src/services/pdf.ts","../src/services/speech.ts","../src/services/audioUtils.ts","../src/environment.ts","../src/services/transcription.ts","../src/services/video.ts","../src/index.ts"],"sourcesContent":["import { generateText, IBrowserService, trimTokens } from \"@ai16z/eliza\";\r\nimport { parseJSONObjectFromText } from \"@ai16z/eliza\";\r\nimport { Service } from \"@ai16z/eliza\";\r\nimport { settings } from \"@ai16z/eliza\";\r\nimport { IAgentRuntime, ModelClass, ServiceType } from \"@ai16z/eliza\";\r\nimport { stringToUuid } from \"@ai16z/eliza\";\r\nimport { PlaywrightBlocker } from \"@cliqz/adblocker-playwright\";\r\nimport CaptchaSolver from \"capsolver-npm\";\r\nimport { Browser, BrowserContext, chromium, Page } from \"playwright\";\r\n\r\nasync function generateSummary(\r\n    runtime: IAgentRuntime,\r\n    text: string\r\n): Promise<{ title: string; description: string }> {\r\n    // make sure text is under 128k characters\r\n    text = trimTokens(text, 100000, \"gpt-4o-mini\"); // TODO: clean this up\r\n\r\n    const prompt = `Please generate a concise summary for the following text:\r\n  \r\n  Text: \"\"\"\r\n  ${text}\r\n  \"\"\"\r\n  \r\n  Respond with a JSON object in the following format:\r\n  \\`\\`\\`json\r\n  {\r\n    \"title\": \"Generated Title\",\r\n    \"summary\": \"Generated summary and/or description of the text\"\r\n  }\r\n  \\`\\`\\``;\r\n\r\n    const response = await generateText({\r\n        runtime,\r\n        context: prompt,\r\n        modelClass: ModelClass.SMALL,\r\n    });\r\n\r\n    const parsedResponse = parseJSONObjectFromText(response);\r\n\r\n    if (parsedResponse) {\r\n        return {\r\n            title: parsedResponse.title,\r\n            description: parsedResponse.summary,\r\n        };\r\n    }\r\n\r\n    return {\r\n        title: \"\",\r\n        description: \"\",\r\n    };\r\n}\r\n\r\ntype PageContent = {\r\n    title: string;\r\n    description: string;\r\n    bodyContent: string;\r\n};\r\n\r\nexport class BrowserService extends Service implements IBrowserService {\r\n    private browser: Browser | undefined;\r\n    private context: BrowserContext | undefined;\r\n    private blocker: PlaywrightBlocker | undefined;\r\n    private captchaSolver: CaptchaSolver;\r\n    private cacheKey = \"content/browser\";\r\n\r\n    static serviceType: ServiceType = ServiceType.BROWSER;\r\n\r\n    static register(runtime: IAgentRuntime): IAgentRuntime {\r\n        // since we are lazy loading, do nothing\r\n        return runtime;\r\n    }\r\n\r\n    getInstance(): IBrowserService {\r\n        return BrowserService.getInstance();\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n        this.browser = undefined;\r\n        this.context = undefined;\r\n        this.blocker = undefined;\r\n        this.captchaSolver = new CaptchaSolver(\r\n            settings.CAPSOLVER_API_KEY || \"\"\r\n        );\r\n    }\r\n\r\n    async initialize() {}\r\n\r\n    async initializeBrowser() {\r\n        if (!this.browser) {\r\n            this.browser = await chromium.launch({\r\n                headless: true,\r\n                args: [\r\n                    \"--disable-dev-shm-usage\", // Uses /tmp instead of /dev/shm. Prevents memory issues on low-memory systems\r\n                    \"--block-new-web-contents\", // Prevents creation of new windows/tabs\r\n                ],\r\n            });\r\n\r\n            const platform = process.platform;\r\n            let userAgent = \"\";\r\n\r\n            // Change the user agent to match the platform to reduce bot detection\r\n            switch (platform) {\r\n                case \"darwin\":\r\n                    userAgent =\r\n                        \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\";\r\n                    break;\r\n                case \"win32\":\r\n                    userAgent =\r\n                        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\";\r\n                    break;\r\n                case \"linux\":\r\n                    userAgent =\r\n                        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\";\r\n                    break;\r\n                default:\r\n                    userAgent =\r\n                        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\";\r\n            }\r\n\r\n            this.context = await this.browser.newContext({\r\n                userAgent,\r\n                acceptDownloads: false,\r\n            });\r\n\r\n            this.blocker =\r\n                await PlaywrightBlocker.fromPrebuiltAdsAndTracking(fetch);\r\n        }\r\n    }\r\n\r\n    async closeBrowser() {\r\n        if (this.context) {\r\n            await this.context.close();\r\n            this.context = undefined;\r\n        }\r\n        if (this.browser) {\r\n            await this.browser.close();\r\n            this.browser = undefined;\r\n        }\r\n    }\r\n\r\n    async getPageContent(\r\n        url: string,\r\n        runtime: IAgentRuntime\r\n    ): Promise<PageContent> {\r\n        await this.initializeBrowser();\r\n        return await this.fetchPageContent(url, runtime);\r\n    }\r\n\r\n    private getCacheKey(url: string): string {\r\n        return stringToUuid(url);\r\n    }\r\n\r\n    private async fetchPageContent(\r\n        url: string,\r\n        runtime: IAgentRuntime\r\n    ): Promise<PageContent> {\r\n        const cacheKey = this.getCacheKey(url);\r\n        const cached = await runtime.cacheManager.get<{\r\n            url: string;\r\n            content: PageContent;\r\n        }>(`${this.cacheKey}/${cacheKey}`);\r\n\r\n        if (cached) {\r\n            return cached.content;\r\n        }\r\n\r\n        let page: Page | undefined;\r\n\r\n        try {\r\n            if (!this.context) {\r\n                console.log(\r\n                    \"Browser context not initialized. Call initializeBrowser() first.\"\r\n                );\r\n            }\r\n\r\n            page = await this.context.newPage();\r\n\r\n            // Enable stealth mode\r\n            await page.setExtraHTTPHeaders({\r\n                \"Accept-Language\": \"en-US,en;q=0.9\",\r\n            });\r\n\r\n            // Apply ad blocker\r\n            if (this.blocker) {\r\n                await this.blocker.enableBlockingInPage(page);\r\n            }\r\n\r\n            const response = await page.goto(url, { waitUntil: \"networkidle\" });\r\n\r\n            if (!response) {\r\n                console.log(\"Failed to load the page\");\r\n            }\r\n\r\n            if (response.status() === 403 || response.status() === 404) {\r\n                return await this.tryAlternativeSources(url, runtime);\r\n            }\r\n\r\n            // Check for CAPTCHA\r\n            const captchaDetected = await this.detectCaptcha(page);\r\n            if (captchaDetected) {\r\n                await this.solveCaptcha(page, url);\r\n            }\r\n            const documentTitle = await page.evaluate(() => document.title);\r\n            const bodyContent = await page.evaluate(\r\n                () => document.body.innerText\r\n            );\r\n            const { title: parsedTitle, description } = await generateSummary(\r\n                runtime,\r\n                documentTitle + \"\\n\" + bodyContent\r\n            );\r\n            const content = { title: parsedTitle, description, bodyContent };\r\n            await runtime.cacheManager.set(`${this.cacheKey}/${cacheKey}`, {\r\n                url,\r\n                content,\r\n            });\r\n            return content;\r\n        } catch (error) {\r\n            console.error(\"Error:\", error);\r\n            return {\r\n                title: url,\r\n                description: \"Error, could not fetch content\",\r\n                bodyContent: \"\",\r\n            };\r\n        } finally {\r\n            if (page) {\r\n                await page.close();\r\n            }\r\n        }\r\n    }\r\n\r\n    private async detectCaptcha(page: Page): Promise<boolean> {\r\n        const captchaSelectors = [\r\n            'iframe[src*=\"captcha\"]',\r\n            'div[class*=\"captcha\"]',\r\n            \"#captcha\",\r\n            \".g-recaptcha\",\r\n            \".h-captcha\",\r\n        ];\r\n\r\n        for (const selector of captchaSelectors) {\r\n            const element = await page.$(selector);\r\n            if (element) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private async solveCaptcha(page: Page, url: string): Promise<void> {\r\n        try {\r\n            const hcaptchaKey = await this.getHCaptchaWebsiteKey(page);\r\n            if (hcaptchaKey) {\r\n                const solution = await this.captchaSolver.hcaptchaProxyless({\r\n                    websiteURL: url,\r\n                    websiteKey: hcaptchaKey,\r\n                });\r\n                await page.evaluate((token) => {\r\n                    // eslint-disable-next-line\r\n                    // @ts-ignore\r\n                    window.hcaptcha.setResponse(token);\r\n                }, solution.gRecaptchaResponse);\r\n                return;\r\n            }\r\n\r\n            const recaptchaKey = await this.getReCaptchaWebsiteKey(page);\r\n            if (recaptchaKey) {\r\n                const solution = await this.captchaSolver.recaptchaV2Proxyless({\r\n                    websiteURL: url,\r\n                    websiteKey: recaptchaKey,\r\n                });\r\n                await page.evaluate((token) => {\r\n                    // eslint-disable-next-line\r\n                    // @ts-ignore\r\n                    document.getElementById(\"g-recaptcha-response\").innerHTML =\r\n                        token;\r\n                }, solution.gRecaptchaResponse);\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Error solving CAPTCHA:\", error);\r\n        }\r\n    }\r\n\r\n    private async getHCaptchaWebsiteKey(page: Page): Promise<string> {\r\n        return page.evaluate(() => {\r\n            const hcaptchaIframe = document.querySelector(\r\n                'iframe[src*=\"hcaptcha.com\"]'\r\n            );\r\n            if (hcaptchaIframe) {\r\n                const src = hcaptchaIframe.getAttribute(\"src\");\r\n                const match = src?.match(/sitekey=([^&]*)/);\r\n                return match ? match[1] : \"\";\r\n            }\r\n            return \"\";\r\n        });\r\n    }\r\n\r\n    private async getReCaptchaWebsiteKey(page: Page): Promise<string> {\r\n        return page.evaluate(() => {\r\n            const recaptchaElement = document.querySelector(\".g-recaptcha\");\r\n            return recaptchaElement\r\n                ? recaptchaElement.getAttribute(\"data-sitekey\") || \"\"\r\n                : \"\";\r\n        });\r\n    }\r\n\r\n    private async tryAlternativeSources(\r\n        url: string,\r\n        runtime: IAgentRuntime\r\n    ): Promise<{ title: string; description: string; bodyContent: string }> {\r\n        // Try Internet Archive\r\n        const archiveUrl = `https://web.archive.org/web/${url}`;\r\n        try {\r\n            return await this.fetchPageContent(archiveUrl, runtime);\r\n        } catch (error) {\r\n            console.error(\"Error fetching from Internet Archive:\", error);\r\n        }\r\n\r\n        // Try Google Search as a last resort\r\n        const googleSearchUrl = `https://www.google.com/search?q=${encodeURIComponent(url)}`;\r\n        try {\r\n            return await this.fetchPageContent(googleSearchUrl, runtime);\r\n        } catch (error) {\r\n            console.error(\"Error fetching from Google Search:\", error);\r\n            console.error(\"Failed to fetch content from alternative sources\");\r\n            return {\r\n                title: url,\r\n                description:\r\n                    \"Error, could not fetch content from alternative sources\",\r\n                bodyContent: \"\",\r\n            };\r\n        }\r\n    }\r\n}\r\n","import { elizaLogger, models } from \"@ai16z/eliza\";\r\nimport { Service } from \"@ai16z/eliza\";\r\nimport {\r\n    IAgentRuntime,\r\n    ModelProviderName,\r\n    ServiceType,\r\n    IImageDescriptionService,\r\n} from \"@ai16z/eliza\";\r\nimport {\r\n    AutoProcessor,\r\n    AutoTokenizer,\r\n    env,\r\n    Florence2ForConditionalGeneration,\r\n    Florence2Processor,\r\n    PreTrainedModel,\r\n    PreTrainedTokenizer,\r\n    RawImage,\r\n    type Tensor,\r\n} from \"@huggingface/transformers\";\r\nimport fs from \"fs\";\r\nimport gifFrames from \"gif-frames\";\r\nimport os from \"os\";\r\nimport path from \"path\";\r\n\r\nexport class ImageDescriptionService\r\n    extends Service\r\n    implements IImageDescriptionService\r\n{\r\n    static serviceType: ServiceType = ServiceType.IMAGE_DESCRIPTION;\r\n\r\n    private modelId: string = \"onnx-community/Florence-2-base-ft\";\r\n    private device: string = \"gpu\";\r\n    private model: PreTrainedModel | null = null;\r\n    private processor: Florence2Processor | null = null;\r\n    private tokenizer: PreTrainedTokenizer | null = null;\r\n    private initialized: boolean = false;\r\n    private runtime: IAgentRuntime | null = null;\r\n    private queue: string[] = [];\r\n    private processing: boolean = false;\r\n\r\n    getInstance(): IImageDescriptionService {\r\n        return ImageDescriptionService.getInstance();\r\n    }\r\n\r\n    async initialize(runtime: IAgentRuntime): Promise<void> {\r\n        console.log(\"Initializing ImageDescriptionService\");\r\n        this.runtime = runtime;\r\n    }\r\n\r\n    private async initializeLocalModel(): Promise<void> {\r\n        env.allowLocalModels = false;\r\n        env.allowRemoteModels = true;\r\n        env.backends.onnx.logLevel = \"fatal\";\r\n        env.backends.onnx.wasm.proxy = false;\r\n        env.backends.onnx.wasm.numThreads = 1;\r\n\r\n        elizaLogger.info(\"Downloading Florence model...\");\r\n\r\n        this.model = await Florence2ForConditionalGeneration.from_pretrained(\r\n            this.modelId,\r\n            {\r\n                device: \"gpu\",\r\n                progress_callback: (progress) => {\r\n                    if (progress.status === \"downloading\") {\r\n                        const percent = (\r\n                            (progress.loaded / progress.total) *\r\n                            100\r\n                        ).toFixed(1);\r\n                        const dots = \".\".repeat(\r\n                            Math.floor(Number(percent) / 5)\r\n                        );\r\n                        elizaLogger.info(\r\n                            `Downloading Florence model: [${dots.padEnd(20, \" \")}] ${percent}%`\r\n                        );\r\n                    }\r\n                },\r\n            }\r\n        );\r\n\r\n        elizaLogger.success(\"Florence model downloaded successfully\");\r\n\r\n        elizaLogger.info(\"Downloading processor...\");\r\n        this.processor = (await AutoProcessor.from_pretrained(\r\n            this.modelId\r\n        )) as Florence2Processor;\r\n\r\n        elizaLogger.info(\"Downloading tokenizer...\");\r\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.modelId);\r\n        elizaLogger.success(\"Image service initialization complete\");\r\n    }\r\n\r\n    async describeImage(\r\n        imageUrl: string\r\n    ): Promise<{ title: string; description: string }> {\r\n        if (!this.initialized) {\r\n            const model = models[this.runtime?.character?.modelProvider];\r\n\r\n            if (model === models[ModelProviderName.LLAMALOCAL]) {\r\n                await this.initializeLocalModel();\r\n            } else {\r\n                this.modelId = \"gpt-4o-mini\";\r\n                this.device = \"cloud\";\r\n            }\r\n\r\n            this.initialized = true;\r\n        }\r\n\r\n        if (this.device === \"cloud\") {\r\n            if (!this.runtime) {\r\n                throw new Error(\r\n                    \"Runtime is required for OpenAI image recognition\"\r\n                );\r\n            }\r\n            return this.recognizeWithOpenAI(imageUrl);\r\n        }\r\n\r\n        this.queue.push(imageUrl);\r\n        this.processQueue();\r\n\r\n        return new Promise((resolve, _reject) => {\r\n            const checkQueue = () => {\r\n                const index = this.queue.indexOf(imageUrl);\r\n                if (index !== -1) {\r\n                    setTimeout(checkQueue, 100);\r\n                } else {\r\n                    resolve(this.processImage(imageUrl));\r\n                }\r\n            };\r\n            checkQueue();\r\n        });\r\n    }\r\n\r\n    private async recognizeWithOpenAI(\r\n        imageUrl: string\r\n    ): Promise<{ title: string; description: string }> {\r\n        const isGif = imageUrl.toLowerCase().endsWith(\".gif\");\r\n        let imageData: Buffer | null = null;\r\n\r\n        try {\r\n            if (isGif) {\r\n                const { filePath } =\r\n                    await this.extractFirstFrameFromGif(imageUrl);\r\n                imageData = fs.readFileSync(filePath);\r\n            } else {\r\n                const response = await fetch(imageUrl);\r\n                if (!response.ok) {\r\n                    throw new Error(\r\n                        `Failed to fetch image: ${response.statusText}`\r\n                    );\r\n                }\r\n                imageData = Buffer.from(await response.arrayBuffer());\r\n            }\r\n\r\n            if (!imageData || imageData.length === 0) {\r\n                throw new Error(\"Failed to fetch image data\");\r\n            }\r\n\r\n            const prompt =\r\n                \"Describe this image and give it a title. The first line should be the title, and then a line break, then a detailed description of the image. Respond with the format 'title\\ndescription'\";\r\n            const text = await this.requestOpenAI(\r\n                imageUrl,\r\n                imageData,\r\n                prompt,\r\n                isGif\r\n            );\r\n\r\n            const [title, ...descriptionParts] = text.split(\"\\n\");\r\n            return {\r\n                title,\r\n                description: descriptionParts.join(\"\\n\"),\r\n            };\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error in recognizeWithOpenAI:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async requestOpenAI(\r\n        imageUrl: string,\r\n        imageData: Buffer,\r\n        prompt: string,\r\n        isGif: boolean\r\n    ): Promise<string> {\r\n        for (let attempt = 0; attempt < 3; attempt++) {\r\n            try {\r\n                const content = [\r\n                    { type: \"text\", text: prompt },\r\n                    {\r\n                        type: \"image_url\",\r\n                        image_url: {\r\n                            url: isGif\r\n                                ? `data:image/png;base64,${imageData.toString(\"base64\")}`\r\n                                : imageUrl,\r\n                        },\r\n                    },\r\n                ];\r\n\r\n                const response = await fetch(\r\n                    \"https://api.openai.com/v1/chat/completions\",\r\n                    {\r\n                        method: \"POST\",\r\n                        headers: {\r\n                            \"Content-Type\": \"application/json\",\r\n                            Authorization: `Bearer ${this.runtime.getSetting(\"OPENAI_API_KEY\")}`,\r\n                        },\r\n                        body: JSON.stringify({\r\n                            model: \"gpt-4o-mini\",\r\n                            messages: [{ role: \"user\", content }],\r\n                            max_tokens: isGif ? 500 : 300,\r\n                        }),\r\n                    }\r\n                );\r\n\r\n                if (!response.ok) {\r\n                    throw new Error(`HTTP error! status: ${response.status}`);\r\n                }\r\n\r\n                const data = await response.json();\r\n                return data.choices[0].message.content;\r\n            } catch (error) {\r\n                elizaLogger.error(\r\n                    `OpenAI request failed (attempt ${attempt + 1}):`,\r\n                    error\r\n                );\r\n                if (attempt === 2) throw error;\r\n            }\r\n        }\r\n        throw new Error(\r\n            \"Failed to recognize image with OpenAI after 3 attempts\"\r\n        );\r\n    }\r\n\r\n    private async processQueue(): Promise<void> {\r\n        if (this.processing || this.queue.length === 0) return;\r\n\r\n        this.processing = true;\r\n        while (this.queue.length > 0) {\r\n            const imageUrl = this.queue.shift();\r\n            await this.processImage(imageUrl);\r\n        }\r\n        this.processing = false;\r\n    }\r\n\r\n    private async processImage(\r\n        imageUrl: string\r\n    ): Promise<{ title: string; description: string }> {\r\n        if (!this.model || !this.processor || !this.tokenizer) {\r\n            throw new Error(\"Model components not initialized\");\r\n        }\r\n\r\n        elizaLogger.log(\"Processing image:\", imageUrl);\r\n        const isGif = imageUrl.toLowerCase().endsWith(\".gif\");\r\n        let imageToProcess = imageUrl;\r\n\r\n        try {\r\n            if (isGif) {\r\n                elizaLogger.log(\"Extracting first frame from GIF\");\r\n                const { filePath } =\r\n                    await this.extractFirstFrameFromGif(imageUrl);\r\n                imageToProcess = filePath;\r\n            }\r\n\r\n            const image = await RawImage.fromURL(imageToProcess);\r\n            const visionInputs = await this.processor(image);\r\n            const prompts =\r\n                this.processor.construct_prompts(\"<DETAILED_CAPTION>\");\r\n            const textInputs = this.tokenizer(prompts);\r\n\r\n            elizaLogger.log(\"Generating image description\");\r\n            const generatedIds = (await this.model.generate({\r\n                ...textInputs,\r\n                ...visionInputs,\r\n                max_new_tokens: 256,\r\n            })) as Tensor;\r\n\r\n            const generatedText = this.tokenizer.batch_decode(generatedIds, {\r\n                skip_special_tokens: false,\r\n            })[0];\r\n\r\n            const result = this.processor.post_process_generation(\r\n                generatedText,\r\n                \"<DETAILED_CAPTION>\",\r\n                image.size\r\n            );\r\n\r\n            const detailedCaption = result[\"<DETAILED_CAPTION>\"] as string;\r\n            return { title: detailedCaption, description: detailedCaption };\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error processing image:\", error);\r\n            throw error;\r\n        } finally {\r\n            if (isGif && imageToProcess !== imageUrl) {\r\n                fs.unlinkSync(imageToProcess);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async extractFirstFrameFromGif(\r\n        gifUrl: string\r\n    ): Promise<{ filePath: string }> {\r\n        const frameData = await gifFrames({\r\n            url: gifUrl,\r\n            frames: 1,\r\n            outputType: \"png\",\r\n        });\r\n\r\n        const tempFilePath = path.join(\r\n            os.tmpdir(),\r\n            `gif_frame_${Date.now()}.png`\r\n        );\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const writeStream = fs.createWriteStream(tempFilePath);\r\n            frameData[0].getImage().pipe(writeStream);\r\n            writeStream.on(\"finish\", () => resolve({ filePath: tempFilePath }));\r\n            writeStream.on(\"error\", reject);\r\n        });\r\n    }\r\n}\r\n\r\nexport default ImageDescriptionService;\r\n","import {\r\n    elizaLogger,\r\n    IAgentRuntime,\r\n    ServiceType,\r\n    ModelProviderName,\r\n} from \"@ai16z/eliza\";\r\nimport { Service } from \"@ai16z/eliza\";\r\nimport fs from \"fs\";\r\nimport https from \"https\";\r\nimport {\r\n    GbnfJsonSchema,\r\n    getLlama,\r\n    Llama,\r\n    LlamaContext,\r\n    LlamaContextSequence,\r\n    LlamaContextSequenceRepeatPenalty,\r\n    LlamaJsonSchemaGrammar,\r\n    LlamaModel,\r\n    Token,\r\n} from \"node-llama-cpp\";\r\nimport path from \"path\";\r\nimport si from \"systeminformation\";\r\nimport { fileURLToPath } from \"url\";\r\n\r\nconst wordsToPunish = [\r\n    \" please\",\r\n    \" feel\",\r\n    \" free\",\r\n    \"!\",\r\n    \"–\",\r\n    \"—\",\r\n    \"?\",\r\n    \".\",\r\n    \",\",\r\n    \"; \",\r\n    \" cosmos\",\r\n    \" tapestry\",\r\n    \" tapestries\",\r\n    \" glitch\",\r\n    \" matrix\",\r\n    \" cyberspace\",\r\n    \" troll\",\r\n    \" questions\",\r\n    \" topics\",\r\n    \" discuss\",\r\n    \" basically\",\r\n    \" simulation\",\r\n    \" simulate\",\r\n    \" universe\",\r\n    \" like\",\r\n    \" debug\",\r\n    \" debugging\",\r\n    \" wild\",\r\n    \" existential\",\r\n    \" juicy\",\r\n    \" circuits\",\r\n    \" help\",\r\n    \" ask\",\r\n    \" happy\",\r\n    \" just\",\r\n    \" cosmic\",\r\n    \" cool\",\r\n    \" joke\",\r\n    \" punchline\",\r\n    \" fancy\",\r\n    \" glad\",\r\n    \" assist\",\r\n    \" algorithm\",\r\n    \" Indeed\",\r\n    \" Furthermore\",\r\n    \" However\",\r\n    \" Notably\",\r\n    \" Therefore\",\r\n    \" Additionally\",\r\n    \" conclusion\",\r\n    \" Significantly\",\r\n    \" Consequently\",\r\n    \" Thus\",\r\n    \" What\",\r\n    \" Otherwise\",\r\n    \" Moreover\",\r\n    \" Subsequently\",\r\n    \" Accordingly\",\r\n    \" Unlock\",\r\n    \" Unleash\",\r\n    \" buckle\",\r\n    \" pave\",\r\n    \" forefront\",\r\n    \" harness\",\r\n    \" harnessing\",\r\n    \" bridging\",\r\n    \" bridging\",\r\n    \" Spearhead\",\r\n    \" spearheading\",\r\n    \" Foster\",\r\n    \" foster\",\r\n    \" environmental\",\r\n    \" impact\",\r\n    \" Navigate\",\r\n    \" navigating\",\r\n    \" challenges\",\r\n    \" chaos\",\r\n    \" social\",\r\n    \" inclusion\",\r\n    \" inclusive\",\r\n    \" diversity\",\r\n    \" diverse\",\r\n    \" delve\",\r\n    \" noise\",\r\n    \" infinite\",\r\n    \" insanity\",\r\n    \" coffee\",\r\n    \" singularity\",\r\n    \" AI\",\r\n    \" digital\",\r\n    \" artificial\",\r\n    \" intelligence\",\r\n    \" consciousness\",\r\n    \" reality\",\r\n    \" metaverse\",\r\n    \" virtual\",\r\n    \" virtual reality\",\r\n    \" VR\",\r\n    \" Metaverse\",\r\n    \" humanity\",\r\n];\r\n\r\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\r\n\r\nconst jsonSchemaGrammar: Readonly<{\r\n    type: string;\r\n    properties: {\r\n        user: {\r\n            type: string;\r\n        };\r\n        content: {\r\n            type: string;\r\n        };\r\n    };\r\n}> = {\r\n    type: \"object\",\r\n    properties: {\r\n        user: {\r\n            type: \"string\",\r\n        },\r\n        content: {\r\n            type: \"string\",\r\n        },\r\n    },\r\n};\r\n\r\ninterface QueuedMessage {\r\n    context: string;\r\n    temperature: number;\r\n    stop: string[];\r\n    max_tokens: number;\r\n    frequency_penalty: number;\r\n    presence_penalty: number;\r\n    useGrammar: boolean;\r\n    resolve: (value: any | string | PromiseLike<any | string>) => void;\r\n    reject: (reason?: any) => void;\r\n}\r\n\r\nexport class LlamaService extends Service {\r\n    private llama: Llama | undefined;\r\n    private model: LlamaModel | undefined;\r\n    private modelPath: string;\r\n    private grammar: LlamaJsonSchemaGrammar<GbnfJsonSchema> | undefined;\r\n    private ctx: LlamaContext | undefined;\r\n    private sequence: LlamaContextSequence | undefined;\r\n    private modelUrl: string;\r\n    private ollamaModel: string | undefined;\r\n\r\n    private messageQueue: QueuedMessage[] = [];\r\n    private isProcessing: boolean = false;\r\n    private modelInitialized: boolean = false;\r\n    private runtime: IAgentRuntime | undefined;\r\n\r\n    static serviceType: ServiceType = ServiceType.TEXT_GENERATION;\r\n\r\n    constructor() {\r\n        super();\r\n        this.llama = undefined;\r\n        this.model = undefined;\r\n        this.modelUrl =\r\n            \"https://huggingface.co/NousResearch/Hermes-3-Llama-3.1-8B-GGUF/resolve/main/Hermes-3-Llama-3.1-8B.Q8_0.gguf?download=true\";\r\n        const modelName = \"model.gguf\";\r\n        this.modelPath = path.join(\r\n            process.env.LLAMALOCAL_PATH?.trim() ?? \"./\",\r\n            modelName\r\n        );\r\n        this.ollamaModel = process.env.OLLAMA_MODEL;\r\n    }\r\n\r\n    async initialize(runtime: IAgentRuntime): Promise<void> {\r\n        elizaLogger.info(\"Initializing LlamaService...\");\r\n        this.runtime = runtime;\r\n    }\r\n\r\n    private async ensureInitialized() {\r\n        if (!this.modelInitialized) {\r\n            elizaLogger.info(\r\n                \"Model not initialized, starting initialization...\"\r\n            );\r\n            await this.initializeModel();\r\n        } else {\r\n            elizaLogger.info(\"Model already initialized\");\r\n        }\r\n    }\r\n\r\n    async initializeModel() {\r\n        try {\r\n            elizaLogger.info(\"Checking model file...\");\r\n            await this.checkModel();\r\n\r\n            const systemInfo = await si.graphics();\r\n            const hasCUDA = systemInfo.controllers.some((controller) =>\r\n                controller.vendor.toLowerCase().includes(\"nvidia\")\r\n            );\r\n\r\n            if (hasCUDA) {\r\n                elizaLogger.info(\r\n                    \"LlamaService: CUDA detected, using GPU acceleration\"\r\n                );\r\n            } else {\r\n                elizaLogger.warn(\r\n                    \"LlamaService: No CUDA detected - local response will be slow\"\r\n                );\r\n            }\r\n\r\n            elizaLogger.info(\"Initializing Llama instance...\");\r\n            this.llama = await getLlama({\r\n                gpu: hasCUDA ? \"cuda\" : undefined,\r\n            });\r\n\r\n            elizaLogger.info(\"Creating JSON schema grammar...\");\r\n            const grammar = new LlamaJsonSchemaGrammar(\r\n                this.llama,\r\n                jsonSchemaGrammar as GbnfJsonSchema\r\n            );\r\n            this.grammar = grammar;\r\n\r\n            elizaLogger.info(\"Loading model...\");\r\n            this.model = await this.llama.loadModel({\r\n                modelPath: this.modelPath,\r\n            });\r\n\r\n            elizaLogger.info(\"Creating context and sequence...\");\r\n            this.ctx = await this.model.createContext({ contextSize: 8192 });\r\n            this.sequence = this.ctx.getSequence();\r\n\r\n            this.modelInitialized = true;\r\n            elizaLogger.success(\"Model initialization complete\");\r\n            this.processQueue();\r\n        } catch (error) {\r\n            elizaLogger.error(\r\n                \"Model initialization failed. Deleting model and retrying:\",\r\n                error\r\n            );\r\n            try {\r\n                elizaLogger.info(\r\n                    \"Attempting to delete and re-download model...\"\r\n                );\r\n                await this.deleteModel();\r\n                await this.initializeModel();\r\n            } catch (retryError) {\r\n                elizaLogger.error(\r\n                    \"Model re-initialization failed:\",\r\n                    retryError\r\n                );\r\n                throw new Error(\r\n                    `Model initialization failed after retry: ${retryError.message}`\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    async checkModel() {\r\n        if (!fs.existsSync(this.modelPath)) {\r\n            elizaLogger.info(\"Model file not found, starting download...\");\r\n            await new Promise<void>((resolve, reject) => {\r\n                const file = fs.createWriteStream(this.modelPath);\r\n                let downloadedSize = 0;\r\n                let totalSize = 0;\r\n\r\n                const downloadModel = (url: string) => {\r\n                    https\r\n                        .get(url, (response) => {\r\n                            if (\r\n                                response.statusCode >= 300 &&\r\n                                response.statusCode < 400 &&\r\n                                response.headers.location\r\n                            ) {\r\n                                elizaLogger.info(\r\n                                    `Following redirect to: ${response.headers.location}`\r\n                                );\r\n                                downloadModel(response.headers.location);\r\n                                return;\r\n                            }\r\n\r\n                            if (response.statusCode !== 200) {\r\n                                reject(\r\n                                    new Error(\r\n                                        `Failed to download model: HTTP ${response.statusCode}`\r\n                                    )\r\n                                );\r\n                                return;\r\n                            }\r\n\r\n                            totalSize = parseInt(\r\n                                response.headers[\"content-length\"] || \"0\",\r\n                                10\r\n                            );\r\n                            elizaLogger.info(\r\n                                `Downloading model: Hermes-3-Llama-3.1-8B.Q8_0.gguf`\r\n                            );\r\n                            elizaLogger.info(\r\n                                `Download location: ${this.modelPath}`\r\n                            );\r\n                            elizaLogger.info(\r\n                                `Total size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`\r\n                            );\r\n\r\n                            response.pipe(file);\r\n\r\n                            let progressString = \"\";\r\n                            response.on(\"data\", (chunk) => {\r\n                                downloadedSize += chunk.length;\r\n                                const progress =\r\n                                    totalSize > 0\r\n                                        ? (\r\n                                              (downloadedSize / totalSize) *\r\n                                              100\r\n                                          ).toFixed(1)\r\n                                        : \"0.0\";\r\n                                const dots = \".\".repeat(\r\n                                    Math.floor(Number(progress) / 5)\r\n                                );\r\n                                progressString = `Downloading model: [${dots.padEnd(20, \" \")}] ${progress}%`;\r\n                                elizaLogger.progress(progressString);\r\n                            });\r\n\r\n                            file.on(\"finish\", () => {\r\n                                file.close();\r\n                                elizaLogger.progress(\"\"); // Clear the progress line\r\n                                elizaLogger.success(\"Model download complete\");\r\n                                resolve();\r\n                            });\r\n\r\n                            response.on(\"error\", (error) => {\r\n                                fs.unlink(this.modelPath, () => {});\r\n                                reject(\r\n                                    new Error(\r\n                                        `Model download failed: ${error.message}`\r\n                                    )\r\n                                );\r\n                            });\r\n                        })\r\n                        .on(\"error\", (error) => {\r\n                            fs.unlink(this.modelPath, () => {});\r\n                            reject(\r\n                                new Error(\r\n                                    `Model download request failed: ${error.message}`\r\n                                )\r\n                            );\r\n                        });\r\n                };\r\n\r\n                downloadModel(this.modelUrl);\r\n\r\n                file.on(\"error\", (err) => {\r\n                    fs.unlink(this.modelPath, () => {}); // Delete the file async\r\n                    console.error(\"File write error:\", err.message);\r\n                    reject(err);\r\n                });\r\n            });\r\n        } else {\r\n            elizaLogger.warn(\"Model already exists.\");\r\n        }\r\n    }\r\n\r\n    async deleteModel() {\r\n        if (fs.existsSync(this.modelPath)) {\r\n            fs.unlinkSync(this.modelPath);\r\n        }\r\n    }\r\n\r\n    async queueMessageCompletion(\r\n        context: string,\r\n        temperature: number,\r\n        stop: string[],\r\n        frequency_penalty: number,\r\n        presence_penalty: number,\r\n        max_tokens: number\r\n    ): Promise<any> {\r\n        await this.ensureInitialized();\r\n        return new Promise((resolve, reject) => {\r\n            this.messageQueue.push({\r\n                context,\r\n                temperature,\r\n                stop,\r\n                frequency_penalty,\r\n                presence_penalty,\r\n                max_tokens,\r\n                useGrammar: true,\r\n                resolve,\r\n                reject,\r\n            });\r\n            this.processQueue();\r\n        });\r\n    }\r\n\r\n    async queueTextCompletion(\r\n        context: string,\r\n        temperature: number,\r\n        stop: string[],\r\n        frequency_penalty: number,\r\n        presence_penalty: number,\r\n        max_tokens: number\r\n    ): Promise<string> {\r\n        await this.ensureInitialized();\r\n\r\n        return new Promise((resolve, reject) => {\r\n            this.messageQueue.push({\r\n                context,\r\n                temperature,\r\n                stop,\r\n                frequency_penalty: frequency_penalty ?? 1.0,\r\n                presence_penalty: presence_penalty ?? 1.0,\r\n                max_tokens,\r\n                useGrammar: false,\r\n                resolve,\r\n                reject,\r\n            });\r\n            this.processQueue();\r\n        });\r\n    }\r\n\r\n    private async processQueue() {\r\n        if (\r\n            this.isProcessing ||\r\n            this.messageQueue.length === 0 ||\r\n            !this.modelInitialized\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        this.isProcessing = true;\r\n\r\n        while (this.messageQueue.length > 0) {\r\n            const message = this.messageQueue.shift();\r\n            if (message) {\r\n                try {\r\n                    const response = await this.getCompletionResponse(\r\n                        message.context,\r\n                        message.temperature,\r\n                        message.stop,\r\n                        message.frequency_penalty,\r\n                        message.presence_penalty,\r\n                        message.max_tokens,\r\n                        message.useGrammar\r\n                    );\r\n                    message.resolve(response);\r\n                } catch (error) {\r\n                    message.reject(error);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.isProcessing = false;\r\n    }\r\n\r\n    async completion(prompt: string, runtime: IAgentRuntime): Promise<string> {\r\n        try {\r\n            await this.initialize(runtime);\r\n\r\n            if (runtime.modelProvider === ModelProviderName.OLLAMA) {\r\n                return await this.ollamaCompletion(prompt);\r\n            }\r\n\r\n            return await this.localCompletion(prompt);\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error in completion:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    async embedding(text: string, runtime: IAgentRuntime): Promise<number[]> {\r\n        try {\r\n            await this.initialize(runtime);\r\n\r\n            if (runtime.modelProvider === ModelProviderName.OLLAMA) {\r\n                return await this.ollamaEmbedding(text);\r\n            }\r\n\r\n            return await this.localEmbedding(text);\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error in embedding:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async getCompletionResponse(\r\n        context: string,\r\n        temperature: number,\r\n        stop: string[],\r\n        frequency_penalty: number,\r\n        presence_penalty: number,\r\n        max_tokens: number,\r\n        useGrammar: boolean\r\n    ): Promise<any | string> {\r\n        const ollamaModel = process.env.OLLAMA_MODEL;\r\n        if (ollamaModel) {\r\n            const ollamaUrl =\r\n                process.env.OLLAMA_SERVER_URL || \"http://localhost:11434\";\r\n            elizaLogger.info(\r\n                `Using Ollama API at ${ollamaUrl} with model ${ollamaModel}`\r\n            );\r\n\r\n            const response = await fetch(`${ollamaUrl}/api/generate`, {\r\n                method: \"POST\",\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    model: ollamaModel,\r\n                    prompt: context,\r\n                    stream: false,\r\n                    options: {\r\n                        temperature,\r\n                        stop,\r\n                        frequency_penalty,\r\n                        presence_penalty,\r\n                        num_predict: max_tokens,\r\n                    },\r\n                }),\r\n            });\r\n\r\n            if (!response.ok) {\r\n                throw new Error(\r\n                    `Ollama request failed: ${response.statusText}`\r\n                );\r\n            }\r\n\r\n            const result = await response.json();\r\n            return useGrammar ? { content: result.response } : result.response;\r\n        }\r\n\r\n        // Use local GGUF model\r\n        if (!this.sequence) {\r\n            throw new Error(\"Model not initialized.\");\r\n        }\r\n\r\n        const tokens = this.model!.tokenize(context);\r\n\r\n        // tokenize the words to punish\r\n        const wordsToPunishTokens = wordsToPunish\r\n            .map((word) => this.model!.tokenize(word))\r\n            .flat();\r\n\r\n        const repeatPenalty: LlamaContextSequenceRepeatPenalty = {\r\n            punishTokens: () => wordsToPunishTokens,\r\n            penalty: 1.2,\r\n            frequencyPenalty: frequency_penalty,\r\n            presencePenalty: presence_penalty,\r\n        };\r\n\r\n        const responseTokens: Token[] = [];\r\n\r\n        for await (const token of this.sequence.evaluate(tokens, {\r\n            temperature: Number(temperature),\r\n            repeatPenalty: repeatPenalty,\r\n            grammarEvaluationState: useGrammar ? this.grammar : undefined,\r\n            yieldEogToken: false,\r\n        })) {\r\n            const current = this.model.detokenize([...responseTokens, token]);\r\n            if ([...stop].some((s) => current.includes(s))) {\r\n                elizaLogger.info(\"Stop sequence found\");\r\n                break;\r\n            }\r\n\r\n            responseTokens.push(token);\r\n            process.stdout.write(this.model!.detokenize([token]));\r\n            if (useGrammar) {\r\n                if (current.replaceAll(\"\\n\", \"\").includes(\"}```\")) {\r\n                    elizaLogger.info(\"JSON block found\");\r\n                    break;\r\n                }\r\n            }\r\n            if (responseTokens.length > max_tokens) {\r\n                elizaLogger.info(\"Max tokens reached\");\r\n                break;\r\n            }\r\n        }\r\n\r\n        const response = this.model!.detokenize(responseTokens);\r\n\r\n        if (!response) {\r\n            throw new Error(\"Response is undefined\");\r\n        }\r\n\r\n        if (useGrammar) {\r\n            // extract everything between ```json and ```\r\n            let jsonString = response.match(/```json(.*?)```/s)?.[1].trim();\r\n            if (!jsonString) {\r\n                // try parsing response as JSON\r\n                try {\r\n                    jsonString = JSON.stringify(JSON.parse(response));\r\n                } catch {\r\n                    throw new Error(\"JSON string not found\");\r\n                }\r\n            }\r\n            try {\r\n                const parsedResponse = JSON.parse(jsonString);\r\n                if (!parsedResponse) {\r\n                    throw new Error(\"Parsed response is undefined\");\r\n                }\r\n                await this.sequence.clearHistory();\r\n                return parsedResponse;\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error parsing JSON:\", error);\r\n            }\r\n        } else {\r\n            await this.sequence.clearHistory();\r\n            return response;\r\n        }\r\n    }\r\n\r\n    async getEmbeddingResponse(input: string): Promise<number[] | undefined> {\r\n        const ollamaModel = process.env.OLLAMA_MODEL;\r\n        if (ollamaModel) {\r\n            const ollamaUrl =\r\n                process.env.OLLAMA_SERVER_URL || \"http://localhost:11434\";\r\n            const embeddingModel =\r\n                process.env.OLLAMA_EMBEDDING_MODEL || \"mxbai-embed-large\";\r\n            elizaLogger.info(\r\n                `Using Ollama API for embeddings with model ${embeddingModel} (base: ${ollamaModel})`\r\n            );\r\n\r\n            const response = await fetch(`${ollamaUrl}/api/embeddings`, {\r\n                method: \"POST\",\r\n                headers: { \"Content-Type\": \"application/json\" },\r\n                body: JSON.stringify({\r\n                    model: embeddingModel,\r\n                    prompt: input,\r\n                }),\r\n            });\r\n\r\n            if (!response.ok) {\r\n                throw new Error(\r\n                    `Ollama embeddings request failed: ${response.statusText}`\r\n                );\r\n            }\r\n\r\n            const result = await response.json();\r\n            return result.embedding;\r\n        }\r\n\r\n        // Use local GGUF model\r\n        if (!this.sequence) {\r\n            throw new Error(\"Sequence not initialized\");\r\n        }\r\n\r\n        const ollamaUrl =\r\n            process.env.OLLAMA_SERVER_URL || \"http://localhost:11434\";\r\n        const embeddingModel =\r\n            process.env.OLLAMA_EMBEDDING_MODEL || \"mxbai-embed-large\";\r\n        elizaLogger.info(\r\n            `Using Ollama API for embeddings with model ${embeddingModel} (base: ${this.ollamaModel})`\r\n        );\r\n\r\n        const response = await fetch(`${ollamaUrl}/api/embeddings`, {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Content-Type\": \"application/json\",\r\n            },\r\n            body: JSON.stringify({\r\n                input: input,\r\n                model: embeddingModel,\r\n            }),\r\n        });\r\n\r\n        if (!response.ok) {\r\n            throw new Error(`Failed to get embedding: ${response.statusText}`);\r\n        }\r\n\r\n        const embedding = await response.json();\r\n        return embedding.vector;\r\n    }\r\n\r\n    private async ollamaCompletion(prompt: string): Promise<string> {\r\n        const ollamaModel = process.env.OLLAMA_MODEL;\r\n        const ollamaUrl =\r\n            process.env.OLLAMA_SERVER_URL || \"http://localhost:11434\";\r\n        elizaLogger.info(\r\n            `Using Ollama API at ${ollamaUrl} with model ${ollamaModel}`\r\n        );\r\n\r\n        const response = await fetch(`${ollamaUrl}/api/generate`, {\r\n            method: \"POST\",\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({\r\n                model: ollamaModel,\r\n                prompt: prompt,\r\n                stream: false,\r\n                options: {\r\n                    temperature: 0.7,\r\n                    stop: [\"\\n\"],\r\n                    frequency_penalty: 0.5,\r\n                    presence_penalty: 0.5,\r\n                    num_predict: 256,\r\n                },\r\n            }),\r\n        });\r\n\r\n        if (!response.ok) {\r\n            throw new Error(`Ollama request failed: ${response.statusText}`);\r\n        }\r\n\r\n        const result = await response.json();\r\n        return result.response;\r\n    }\r\n\r\n    private async ollamaEmbedding(text: string): Promise<number[]> {\r\n        const ollamaModel = process.env.OLLAMA_MODEL;\r\n        const ollamaUrl =\r\n            process.env.OLLAMA_SERVER_URL || \"http://localhost:11434\";\r\n        const embeddingModel =\r\n            process.env.OLLAMA_EMBEDDING_MODEL || \"mxbai-embed-large\";\r\n        elizaLogger.info(\r\n            `Using Ollama API for embeddings with model ${embeddingModel} (base: ${ollamaModel})`\r\n        );\r\n\r\n        const response = await fetch(`${ollamaUrl}/api/embeddings`, {\r\n            method: \"POST\",\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({\r\n                model: embeddingModel,\r\n                prompt: text,\r\n            }),\r\n        });\r\n\r\n        if (!response.ok) {\r\n            throw new Error(\r\n                `Ollama embeddings request failed: ${response.statusText}`\r\n            );\r\n        }\r\n\r\n        const result = await response.json();\r\n        return result.embedding;\r\n    }\r\n\r\n    private async localCompletion(prompt: string): Promise<string> {\r\n        if (!this.sequence) {\r\n            throw new Error(\"Sequence not initialized\");\r\n        }\r\n\r\n        const tokens = this.model!.tokenize(prompt);\r\n\r\n        // tokenize the words to punish\r\n        const wordsToPunishTokens = wordsToPunish\r\n            .map((word) => this.model!.tokenize(word))\r\n            .flat();\r\n\r\n        const repeatPenalty: LlamaContextSequenceRepeatPenalty = {\r\n            punishTokens: () => wordsToPunishTokens,\r\n            penalty: 1.2,\r\n            frequencyPenalty: 0.5,\r\n            presencePenalty: 0.5,\r\n        };\r\n\r\n        const responseTokens: Token[] = [];\r\n\r\n        for await (const token of this.sequence.evaluate(tokens, {\r\n            temperature: 0.7,\r\n            repeatPenalty: repeatPenalty,\r\n            yieldEogToken: false,\r\n        })) {\r\n            const current = this.model.detokenize([...responseTokens, token]);\r\n            if (current.includes(\"\\n\")) {\r\n                elizaLogger.info(\"Stop sequence found\");\r\n                break;\r\n            }\r\n\r\n            responseTokens.push(token);\r\n            process.stdout.write(this.model!.detokenize([token]));\r\n            if (responseTokens.length > 256) {\r\n                elizaLogger.info(\"Max tokens reached\");\r\n                break;\r\n            }\r\n        }\r\n\r\n        const response = this.model!.detokenize(responseTokens);\r\n\r\n        if (!response) {\r\n            throw new Error(\"Response is undefined\");\r\n        }\r\n\r\n        await this.sequence.clearHistory();\r\n        return response;\r\n    }\r\n\r\n    private async localEmbedding(text: string): Promise<number[]> {\r\n        if (!this.sequence) {\r\n            throw new Error(\"Sequence not initialized\");\r\n        }\r\n\r\n        const embeddingContext = await this.model.createEmbeddingContext();\r\n        const embedding = await embeddingContext.getEmbeddingFor(text);\r\n        return embedding?.vector ? [...embedding.vector] : undefined;\r\n    }\r\n}\r\n\r\nexport default LlamaService;\r\n","import { IAgentRuntime, IPdfService, Service, ServiceType } from \"@ai16z/eliza\";\r\nimport { getDocument, PDFDocumentProxy } from \"pdfjs-dist\";\r\nimport { TextItem, TextMarkedContent } from \"pdfjs-dist/types/src/display/api\";\r\n\r\nexport class PdfService extends Service implements IPdfService {\r\n    static serviceType: ServiceType = ServiceType.PDF;\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    getInstance(): IPdfService {\r\n        return PdfService.getInstance();\r\n    }\r\n\r\n    async initialize(_runtime: IAgentRuntime): Promise<void> {}\r\n\r\n    async convertPdfToText(pdfBuffer: Buffer): Promise<string> {\r\n        // Convert Buffer to Uint8Array\r\n        const uint8Array = new Uint8Array(pdfBuffer);\r\n\r\n        const pdf: PDFDocumentProxy = await getDocument({ data: uint8Array })\r\n            .promise;\r\n        const numPages = pdf.numPages;\r\n        const textPages: string[] = [];\r\n\r\n        for (let pageNum = 1; pageNum <= numPages; pageNum++) {\r\n            const page = await pdf.getPage(pageNum);\r\n            const textContent = await page.getTextContent();\r\n            const pageText = textContent.items\r\n                .filter(isTextItem)\r\n                .map((item) => item.str)\r\n                .join(\" \");\r\n            textPages.push(pageText);\r\n        }\r\n\r\n        return textPages.join(\"\\n\");\r\n    }\r\n}\r\n\r\n// Type guard function\r\nfunction isTextItem(item: TextItem | TextMarkedContent): item is TextItem {\r\n    return \"str\" in item;\r\n}\r\n","import { PassThrough, Readable } from \"stream\";\r\nimport { IAgentRuntime, ISpeechService, ServiceType } from \"@ai16z/eliza\";\r\nimport { getWavHeader } from \"./audioUtils.ts\";\r\nimport { Service } from \"@ai16z/eliza\";\r\nimport { validateNodeConfig } from \"../environment.ts\";\r\nimport * as Echogarden from \"echogarden\";\r\nimport { elizaLogger } from \"@ai16z/eliza\";\r\n\r\nfunction prependWavHeader(\r\n    readable: Readable,\r\n    audioLength: number,\r\n    sampleRate: number,\r\n    channelCount: number = 1,\r\n    bitsPerSample: number = 16\r\n): Readable {\r\n    const wavHeader = getWavHeader(\r\n        audioLength,\r\n        sampleRate,\r\n        channelCount,\r\n        bitsPerSample\r\n    );\r\n    let pushedHeader = false;\r\n    const passThrough = new PassThrough();\r\n    readable.on(\"data\", function (data) {\r\n        if (!pushedHeader) {\r\n            passThrough.push(wavHeader);\r\n            pushedHeader = true;\r\n        }\r\n        passThrough.push(data);\r\n    });\r\n    readable.on(\"end\", function () {\r\n        passThrough.end();\r\n    });\r\n    return passThrough;\r\n}\r\n\r\nasync function getVoiceSettings(runtime: IAgentRuntime) {\r\n    const hasElevenLabs = !!runtime.getSetting(\"ELEVENLABS_XI_API_KEY\");\r\n    const useVits = !hasElevenLabs;\r\n\r\n    // Get voice settings from character card\r\n    const voiceSettings = runtime.character.settings?.voice;\r\n    const elevenlabsSettings = voiceSettings?.elevenlabs;\r\n\r\n    elizaLogger.debug(\"Voice settings:\", {\r\n        hasElevenLabs,\r\n        useVits,\r\n        voiceSettings,\r\n        elevenlabsSettings,\r\n    });\r\n\r\n    return {\r\n        elevenlabsVoiceId:\r\n            elevenlabsSettings?.voiceId ||\r\n            runtime.getSetting(\"ELEVENLABS_VOICE_ID\"),\r\n        elevenlabsModel:\r\n            elevenlabsSettings?.model ||\r\n            runtime.getSetting(\"ELEVENLABS_MODEL_ID\") ||\r\n            \"eleven_monolingual_v1\",\r\n        elevenlabsStability:\r\n            elevenlabsSettings?.stability ||\r\n            runtime.getSetting(\"ELEVENLABS_VOICE_STABILITY\") ||\r\n            \"0.5\",\r\n        // ... other ElevenLabs settings ...\r\n        vitsVoice:\r\n            voiceSettings?.model ||\r\n            voiceSettings?.url ||\r\n            runtime.getSetting(\"VITS_VOICE\") ||\r\n            \"en_US-hfc_female-medium\",\r\n        useVits,\r\n    };\r\n}\r\n\r\nasync function textToSpeech(runtime: IAgentRuntime, text: string) {\r\n    await validateNodeConfig(runtime);\r\n    const { elevenlabsVoiceId } = await getVoiceSettings(runtime);\r\n\r\n    try {\r\n        const response = await fetch(\r\n            `https://api.elevenlabs.io/v1/text-to-speech/${elevenlabsVoiceId}/stream?optimize_streaming_latency=${runtime.getSetting(\"ELEVENLABS_OPTIMIZE_STREAMING_LATENCY\")}&output_format=${runtime.getSetting(\"ELEVENLABS_OUTPUT_FORMAT\")}`,\r\n            {\r\n                method: \"POST\",\r\n                headers: {\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"xi-api-key\": runtime.getSetting(\"ELEVENLABS_XI_API_KEY\"),\r\n                },\r\n                body: JSON.stringify({\r\n                    model_id: runtime.getSetting(\"ELEVENLABS_MODEL_ID\"),\r\n                    text: text,\r\n                    voice_settings: {\r\n                        similarity_boost: runtime.getSetting(\r\n                            \"ELEVENLABS_VOICE_SIMILARITY_BOOST\"\r\n                        ),\r\n                        stability: runtime.getSetting(\r\n                            \"ELEVENLABS_VOICE_STABILITY\"\r\n                        ),\r\n                        style: runtime.getSetting(\"ELEVENLABS_VOICE_STYLE\"),\r\n                        use_speaker_boost: runtime.getSetting(\r\n                            \"ELEVENLABS_VOICE_USE_SPEAKER_BOOST\"\r\n                        ),\r\n                    },\r\n                }),\r\n            }\r\n        );\r\n\r\n        const status = response.status;\r\n        if (status != 200) {\r\n            const errorBodyString = await response.text();\r\n            const errorBody = JSON.parse(errorBodyString);\r\n\r\n            // Check for quota exceeded error\r\n            if (\r\n                status === 401 &&\r\n                errorBody.detail?.status === \"quota_exceeded\"\r\n            ) {\r\n                console.log(\"ElevenLabs quota exceeded, falling back to VITS\");\r\n                throw new Error(\"QUOTA_EXCEEDED\");\r\n            }\r\n\r\n            throw new Error(\r\n                `Received status ${status} from Eleven Labs API: ${errorBodyString}`\r\n            );\r\n        }\r\n\r\n        if (response) {\r\n            const reader = response.body?.getReader();\r\n            const readable = new Readable({\r\n                read() {\r\n                    reader && // eslint-disable-line\r\n                        reader.read().then(({ done, value }) => {\r\n                            if (done) {\r\n                                this.push(null);\r\n                            } else {\r\n                                this.push(value);\r\n                            }\r\n                        });\r\n                },\r\n            });\r\n\r\n            if (\r\n                runtime\r\n                    .getSetting(\"ELEVENLABS_OUTPUT_FORMAT\")\r\n                    .startsWith(\"pcm_\")\r\n            ) {\r\n                const sampleRate = parseInt(\r\n                    runtime.getSetting(\"ELEVENLABS_OUTPUT_FORMAT\").substring(4)\r\n                );\r\n                const withHeader = prependWavHeader(\r\n                    readable,\r\n                    1024 * 1024 * 100,\r\n                    sampleRate,\r\n                    1,\r\n                    16\r\n                );\r\n                return withHeader;\r\n            } else {\r\n                return readable;\r\n            }\r\n        } else {\r\n            return new Readable({\r\n                read() {},\r\n            });\r\n        }\r\n    } catch (error) {\r\n        if (error.message === \"QUOTA_EXCEEDED\") {\r\n            // Fall back to VITS\r\n            const { vitsVoice } = await getVoiceSettings(runtime);\r\n            const { audio } = await Echogarden.synthesize(text, {\r\n                engine: \"vits\",\r\n                voice: vitsVoice,\r\n            });\r\n\r\n            let wavStream: Readable;\r\n            if (audio instanceof Buffer) {\r\n                console.log(\"audio is a buffer\");\r\n                wavStream = Readable.from(audio);\r\n            } else if (\"audioChannels\" in audio && \"sampleRate\" in audio) {\r\n                console.log(\"audio is a RawAudio\");\r\n                const floatBuffer = Buffer.from(audio.audioChannels[0].buffer);\r\n                console.log(\"buffer length: \", floatBuffer.length);\r\n\r\n                // Get the sample rate from the RawAudio object\r\n                const sampleRate = audio.sampleRate;\r\n\r\n                // Create a Float32Array view of the floatBuffer\r\n                const floatArray = new Float32Array(floatBuffer.buffer);\r\n\r\n                // Convert 32-bit float audio to 16-bit PCM\r\n                const pcmBuffer = new Int16Array(floatArray.length);\r\n                for (let i = 0; i < floatArray.length; i++) {\r\n                    pcmBuffer[i] = Math.round(floatArray[i] * 32767);\r\n                }\r\n\r\n                // Prepend WAV header to the buffer\r\n                const wavHeaderBuffer = getWavHeader(\r\n                    pcmBuffer.length * 2,\r\n                    sampleRate,\r\n                    1,\r\n                    16\r\n                );\r\n                const wavBuffer = Buffer.concat([\r\n                    wavHeaderBuffer,\r\n                    Buffer.from(pcmBuffer.buffer),\r\n                ]);\r\n\r\n                wavStream = Readable.from(wavBuffer);\r\n            } else {\r\n                throw new Error(\"Unsupported audio format\");\r\n            }\r\n            return wavStream;\r\n        }\r\n        throw error; // Re-throw other errors\r\n    }\r\n}\r\n\r\nasync function processVitsAudio(audio: any): Promise<Readable> {\r\n    let wavStream: Readable;\r\n    if (audio instanceof Buffer) {\r\n        console.log(\"audio is a buffer\");\r\n        wavStream = Readable.from(audio);\r\n    } else if (\"audioChannels\" in audio && \"sampleRate\" in audio) {\r\n        console.log(\"audio is a RawAudio\");\r\n        const floatBuffer = Buffer.from(audio.audioChannels[0].buffer);\r\n        console.log(\"buffer length: \", floatBuffer.length);\r\n\r\n        const sampleRate = audio.sampleRate;\r\n        const floatArray = new Float32Array(floatBuffer.buffer);\r\n        const pcmBuffer = new Int16Array(floatArray.length);\r\n\r\n        for (let i = 0; i < floatArray.length; i++) {\r\n            pcmBuffer[i] = Math.round(floatArray[i] * 32767);\r\n        }\r\n\r\n        const wavHeaderBuffer = getWavHeader(\r\n            pcmBuffer.length * 2,\r\n            sampleRate,\r\n            1,\r\n            16\r\n        );\r\n        const wavBuffer = Buffer.concat([\r\n            wavHeaderBuffer,\r\n            Buffer.from(pcmBuffer.buffer),\r\n        ]);\r\n        wavStream = Readable.from(wavBuffer);\r\n    } else {\r\n        throw new Error(\"Unsupported audio format\");\r\n    }\r\n    return wavStream;\r\n}\r\n\r\nasync function generateVitsAudio(\r\n    runtime: IAgentRuntime,\r\n    text: string\r\n): Promise<Readable> {\r\n    const { vitsVoice } = await getVoiceSettings(runtime);\r\n    const { audio } = await Echogarden.synthesize(text, {\r\n        engine: \"vits\",\r\n        voice: vitsVoice,\r\n    });\r\n    return processVitsAudio(audio);\r\n}\r\n\r\nexport class SpeechService extends Service implements ISpeechService {\r\n    static serviceType: ServiceType = ServiceType.SPEECH_GENERATION;\r\n\r\n    async initialize(_runtime: IAgentRuntime): Promise<void> {}\r\n\r\n    getInstance(): ISpeechService {\r\n        return SpeechService.getInstance();\r\n    }\r\n\r\n    async generate(runtime: IAgentRuntime, text: string): Promise<Readable> {\r\n        try {\r\n            const { useVits } = await getVoiceSettings(runtime);\r\n\r\n            if (useVits || !runtime.getSetting(\"ELEVENLABS_XI_API_KEY\")) {\r\n                return await generateVitsAudio(runtime, text);\r\n            }\r\n\r\n            return await textToSpeech(runtime, text);\r\n        } catch (error) {\r\n            console.error(\"Speech generation error:\", error);\r\n            return await generateVitsAudio(runtime, text);\r\n        }\r\n    }\r\n}\r\n","export function getWavHeader(\r\n    audioLength: number,\r\n    sampleRate: number,\r\n    channelCount: number = 1,\r\n    bitsPerSample: number = 16\r\n): Buffer {\r\n    const wavHeader = Buffer.alloc(44);\r\n    wavHeader.write(\"RIFF\", 0);\r\n    wavHeader.writeUInt32LE(36 + audioLength, 4); // Length of entire file in bytes minus 8\r\n    wavHeader.write(\"WAVE\", 8);\r\n    wavHeader.write(\"fmt \", 12);\r\n    wavHeader.writeUInt32LE(16, 16); // Length of format data\r\n    wavHeader.writeUInt16LE(1, 20); // Type of format (1 is PCM)\r\n    wavHeader.writeUInt16LE(channelCount, 22); // Number of channels\r\n    wavHeader.writeUInt32LE(sampleRate, 24); // Sample rate\r\n    wavHeader.writeUInt32LE(\r\n        (sampleRate * bitsPerSample * channelCount) / 8,\r\n        28\r\n    ); // Byte rate\r\n    wavHeader.writeUInt16LE((bitsPerSample * channelCount) / 8, 32); // Block align ((BitsPerSample * Channels) / 8)\r\n    wavHeader.writeUInt16LE(bitsPerSample, 34); // Bits per sample\r\n    wavHeader.write(\"data\", 36); // Data chunk header\r\n    wavHeader.writeUInt32LE(audioLength, 40); // Data chunk size\r\n    return wavHeader;\r\n}\r\n","import { IAgentRuntime } from \"@ai16z/eliza\";\r\nimport { z } from \"zod\";\r\n\r\nexport const nodeEnvSchema = z.object({\r\n    OPENAI_API_KEY: z.string().min(1, \"OpenAI API key is required\"),\r\n\r\n    // Core settings\r\n    ELEVENLABS_XI_API_KEY: z.string().optional(),\r\n\r\n    // All other settings optional with defaults\r\n    ELEVENLABS_MODEL_ID: z.string().optional(),\r\n    ELEVENLABS_VOICE_ID: z.string().optional(),\r\n    ELEVENLABS_VOICE_STABILITY: z.string().optional(),\r\n    ELEVENLABS_VOICE_SIMILARITY_BOOST: z.string().optional(),\r\n    ELEVENLABS_VOICE_STYLE: z.string().optional(),\r\n    ELEVENLABS_VOICE_USE_SPEAKER_BOOST: z.string().optional(),\r\n    ELEVENLABS_OPTIMIZE_STREAMING_LATENCY: z.string().optional(),\r\n    ELEVENLABS_OUTPUT_FORMAT: z.string().optional(),\r\n    VITS_VOICE: z.string().optional(),\r\n    VITS_MODEL: z.string().optional(),\r\n});\r\n\r\nexport type NodeConfig = z.infer<typeof nodeEnvSchema>;\r\n\r\nexport async function validateNodeConfig(\r\n    runtime: IAgentRuntime\r\n): Promise<NodeConfig> {\r\n    try {\r\n        const voiceSettings = runtime.character.settings?.voice;\r\n        const elevenlabs = voiceSettings?.elevenlabs;\r\n\r\n        // Only include what's absolutely required\r\n        const config = {\r\n            OPENAI_API_KEY:\r\n                runtime.getSetting(\"OPENAI_API_KEY\") ||\r\n                process.env.OPENAI_API_KEY,\r\n            ELEVENLABS_XI_API_KEY:\r\n                runtime.getSetting(\"ELEVENLABS_XI_API_KEY\") ||\r\n                process.env.ELEVENLABS_XI_API_KEY,\r\n\r\n            // Use character card settings first, fall back to env vars, then defaults\r\n            ...(runtime.getSetting(\"ELEVENLABS_XI_API_KEY\") && {\r\n                ELEVENLABS_MODEL_ID:\r\n                    elevenlabs?.model ||\r\n                    process.env.ELEVENLABS_MODEL_ID ||\r\n                    \"eleven_monolingual_v1\",\r\n                ELEVENLABS_VOICE_ID:\r\n                    elevenlabs?.voiceId || process.env.ELEVENLABS_VOICE_ID,\r\n                ELEVENLABS_VOICE_STABILITY:\r\n                    elevenlabs?.stability ||\r\n                    process.env.ELEVENLABS_VOICE_STABILITY ||\r\n                    \"0.5\",\r\n                ELEVENLABS_VOICE_SIMILARITY_BOOST:\r\n                    elevenlabs?.similarityBoost ||\r\n                    process.env.ELEVENLABS_VOICE_SIMILARITY_BOOST ||\r\n                    \"0.75\",\r\n                ELEVENLABS_VOICE_STYLE:\r\n                    elevenlabs?.style ||\r\n                    process.env.ELEVENLABS_VOICE_STYLE ||\r\n                    \"0\",\r\n                ELEVENLABS_VOICE_USE_SPEAKER_BOOST:\r\n                    elevenlabs?.useSpeakerBoost ||\r\n                    process.env.ELEVENLABS_VOICE_USE_SPEAKER_BOOST ||\r\n                    \"true\",\r\n                ELEVENLABS_OPTIMIZE_STREAMING_LATENCY:\r\n                    process.env.ELEVENLABS_OPTIMIZE_STREAMING_LATENCY || \"0\",\r\n                ELEVENLABS_OUTPUT_FORMAT:\r\n                    process.env.ELEVENLABS_OUTPUT_FORMAT || \"pcm_16000\",\r\n            }),\r\n\r\n            // VITS settings\r\n            VITS_VOICE: voiceSettings?.model || process.env.VITS_VOICE,\r\n            VITS_MODEL: process.env.VITS_MODEL,\r\n        };\r\n\r\n        return nodeEnvSchema.parse(config);\r\n    } catch (error) {\r\n        if (error instanceof z.ZodError) {\r\n            const errorMessages = error.errors\r\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\r\n                .join(\"\\n\");\r\n            throw new Error(\r\n                `Node configuration validation failed:\\n${errorMessages}`\r\n            );\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n","import {\r\n    elizaLogger,\r\n    IAgentRuntime,\r\n    ITranscriptionService,\r\n    settings,\r\n} from \"@ai16z/eliza\";\r\nimport { Service, ServiceType } from \"@ai16z/eliza\";\r\nimport { exec } from \"child_process\";\r\nimport { File } from \"formdata-node\";\r\nimport fs from \"fs\";\r\nimport { nodewhisper } from \"nodejs-whisper\";\r\nimport OpenAI from \"openai\"; // todo, can probably move this to model provider or whateer\r\nimport os from \"os\";\r\nimport path from \"path\";\r\nimport { fileURLToPath } from \"url\";\r\nimport { promisify } from \"util\";\r\n\r\n// const __dirname = path.dirname(new URL(import.meta.url).pathname); #compatibility issues with windows\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = path.dirname(__filename);\r\n\r\nconst execAsync = promisify(exec);\r\n\r\nexport class TranscriptionService\r\n    extends Service\r\n    implements ITranscriptionService\r\n{\r\n    static serviceType: ServiceType = ServiceType.TRANSCRIPTION;\r\n    private CONTENT_CACHE_DIR: string;\r\n    private DEBUG_AUDIO_DIR: string;\r\n    private TARGET_SAMPLE_RATE = 16000; // Common sample rate for speech recognition\r\n    private isCudaAvailable: boolean = false;\r\n    private openai: OpenAI | null = null;\r\n\r\n    private queue: { audioBuffer: ArrayBuffer; resolve: Function }[] = [];\r\n    private processing: boolean = false;\r\n\r\n    async initialize(_runtime: IAgentRuntime): Promise<void> {}\r\n\r\n    constructor() {\r\n        super();\r\n        const rootDir = path.resolve(__dirname, \"../../\");\r\n        this.CONTENT_CACHE_DIR = path.join(rootDir, \"content_cache\");\r\n        this.DEBUG_AUDIO_DIR = path.join(rootDir, \"debug_audio\");\r\n        this.ensureCacheDirectoryExists();\r\n        this.ensureDebugDirectoryExists();\r\n        // TODO: It'd be nice to handle this more gracefully, but we can do local transcription for now\r\n        // TODO: remove the runtime from here, use it when called\r\n        // if (runtime.getSetting(\"OPENAI_API_KEY\")) {\r\n        //     this.openai = new OpenAI({\r\n        //         apiKey: runtime.getSetting(\"OPENAI_API_KEY\"),\r\n        //     });\r\n        // } else {\r\n        //     this.detectCuda();\r\n        // }\r\n    }\r\n\r\n    private ensureCacheDirectoryExists() {\r\n        if (!fs.existsSync(this.CONTENT_CACHE_DIR)) {\r\n            fs.mkdirSync(this.CONTENT_CACHE_DIR, { recursive: true });\r\n        }\r\n    }\r\n\r\n    private ensureDebugDirectoryExists() {\r\n        if (!fs.existsSync(this.DEBUG_AUDIO_DIR)) {\r\n            fs.mkdirSync(this.DEBUG_AUDIO_DIR, { recursive: true });\r\n        }\r\n    }\r\n\r\n    private detectCuda() {\r\n        const platform = os.platform();\r\n        if (platform === \"linux\") {\r\n            try {\r\n                fs.accessSync(\"/usr/local/cuda/bin/nvcc\", fs.constants.X_OK);\r\n                this.isCudaAvailable = true;\r\n                console.log(\r\n                    \"CUDA detected. Transcription will use CUDA acceleration.\"\r\n                );\r\n                // eslint-disable-next-line\r\n            } catch (_error) {\r\n                console.log(\r\n                    \"CUDA not detected. Transcription will run on CPU.\"\r\n                );\r\n            }\r\n        } else if (platform === \"win32\") {\r\n            const cudaPath = path.join(\r\n                settings.CUDA_PATH ||\r\n                    \"C:\\\\Program Files\\\\NVIDIA GPU Computing Toolkit\\\\CUDA\\\\v11.0\",\r\n                \"bin\",\r\n                \"nvcc.exe\"\r\n            );\r\n            if (fs.existsSync(cudaPath)) {\r\n                this.isCudaAvailable = true;\r\n                console.log(\r\n                    \"CUDA detected. Transcription will use CUDA acceleration.\"\r\n                );\r\n            } else {\r\n                console.log(\r\n                    \"CUDA not detected. Transcription will run on CPU.\"\r\n                );\r\n            }\r\n        } else {\r\n            console.log(\r\n                \"CUDA not supported on this platform. Transcription will run on CPU.\"\r\n            );\r\n        }\r\n    }\r\n\r\n    private async convertAudio(inputBuffer: ArrayBuffer): Promise<Buffer> {\r\n        const inputPath = path.join(\r\n            this.CONTENT_CACHE_DIR,\r\n            `input_${Date.now()}.wav`\r\n        );\r\n        const outputPath = path.join(\r\n            this.CONTENT_CACHE_DIR,\r\n            `output_${Date.now()}.wav`\r\n        );\r\n\r\n        fs.writeFileSync(inputPath, Buffer.from(inputBuffer));\r\n\r\n        try {\r\n            const { stdout } = await execAsync(\r\n                `ffprobe -v error -show_entries stream=codec_name,sample_rate,channels -of json \"${inputPath}\"`\r\n            );\r\n            const probeResult = JSON.parse(stdout);\r\n            const stream = probeResult.streams[0];\r\n\r\n            elizaLogger.log(\"Input audio info:\", stream);\r\n\r\n            let ffmpegCommand = `ffmpeg -i \"${inputPath}\" -ar ${this.TARGET_SAMPLE_RATE} -ac 1`;\r\n\r\n            if (stream.codec_name === \"pcm_f32le\") {\r\n                ffmpegCommand += \" -acodec pcm_s16le\";\r\n            }\r\n\r\n            ffmpegCommand += ` \"${outputPath}\"`;\r\n\r\n            elizaLogger.log(\"FFmpeg command:\", ffmpegCommand);\r\n\r\n            await execAsync(ffmpegCommand);\r\n\r\n            const convertedBuffer = fs.readFileSync(outputPath);\r\n            fs.unlinkSync(inputPath);\r\n            fs.unlinkSync(outputPath);\r\n            return convertedBuffer;\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error converting audio:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async saveDebugAudio(audioBuffer: ArrayBuffer, prefix: string) {\r\n        this.ensureDebugDirectoryExists();\r\n\r\n        const filename = `${prefix}_${Date.now()}.wav`;\r\n        const filePath = path.join(this.DEBUG_AUDIO_DIR, filename);\r\n\r\n        fs.writeFileSync(filePath, Buffer.from(audioBuffer));\r\n        elizaLogger.log(`Debug audio saved: ${filePath}`);\r\n    }\r\n\r\n    public async transcribeAttachment(\r\n        audioBuffer: ArrayBuffer\r\n    ): Promise<string | null> {\r\n        return await this.transcribe(audioBuffer);\r\n    }\r\n\r\n    public async transcribe(audioBuffer: ArrayBuffer): Promise<string | null> {\r\n        // if the audio buffer is less than .2 seconds, just return null\r\n        if (audioBuffer.byteLength < 0.2 * 16000) {\r\n            return null;\r\n        }\r\n        return new Promise((resolve) => {\r\n            this.queue.push({ audioBuffer, resolve });\r\n            if (!this.processing) {\r\n                this.processQueue();\r\n            }\r\n        });\r\n    }\r\n\r\n    public async transcribeAttachmentLocally(\r\n        audioBuffer: ArrayBuffer\r\n    ): Promise<string | null> {\r\n        return this.transcribeLocally(audioBuffer);\r\n    }\r\n\r\n    private async processQueue(): Promise<void> {\r\n        if (this.processing || this.queue.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this.processing = true;\r\n\r\n        while (this.queue.length > 0) {\r\n            const { audioBuffer, resolve } = this.queue.shift()!;\r\n            let result: string | null = null;\r\n\r\n            if (this.openai) {\r\n                result = await this.transcribeWithOpenAI(audioBuffer);\r\n            } else {\r\n                result = await this.transcribeLocally(audioBuffer);\r\n            }\r\n\r\n            resolve(result);\r\n        }\r\n\r\n        this.processing = false;\r\n    }\r\n\r\n    private async transcribeWithOpenAI(\r\n        audioBuffer: ArrayBuffer\r\n    ): Promise<string | null> {\r\n        elizaLogger.log(\"Transcribing audio with OpenAI...\");\r\n\r\n        try {\r\n            await this.saveDebugAudio(audioBuffer, \"openai_input_original\");\r\n\r\n            const convertedBuffer = await this.convertAudio(audioBuffer);\r\n\r\n            await this.saveDebugAudio(\r\n                convertedBuffer,\r\n                \"openai_input_converted\"\r\n            );\r\n\r\n            const file = new File([convertedBuffer], \"audio.wav\", {\r\n                type: \"audio/wav\",\r\n            });\r\n\r\n            const result = await this.openai!.audio.transcriptions.create({\r\n                model: \"whisper-1\",\r\n                language: \"en\",\r\n                response_format: \"text\",\r\n                file: file,\r\n            });\r\n\r\n            const trimmedResult = (result as any).trim();\r\n            elizaLogger.log(`OpenAI speech to text result: \"${trimmedResult}\"`);\r\n\r\n            return trimmedResult;\r\n        } catch (error) {\r\n            elizaLogger.error(\r\n                \"Error in OpenAI speech-to-text conversion:\",\r\n                error\r\n            );\r\n            if (error.response) {\r\n                elizaLogger.error(\"Response data:\", error.response.data);\r\n                elizaLogger.error(\"Response status:\", error.response.status);\r\n                elizaLogger.error(\"Response headers:\", error.response.headers);\r\n            } else if (error.request) {\r\n                elizaLogger.error(\"No response received:\", error.request);\r\n            } else {\r\n                elizaLogger.error(\"Error setting up request:\", error.message);\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public async transcribeLocally(\r\n        audioBuffer: ArrayBuffer\r\n    ): Promise<string | null> {\r\n        try {\r\n            elizaLogger.log(\"Transcribing audio locally...\");\r\n\r\n            await this.saveDebugAudio(audioBuffer, \"local_input_original\");\r\n\r\n            const convertedBuffer = await this.convertAudio(audioBuffer);\r\n\r\n            await this.saveDebugAudio(convertedBuffer, \"local_input_converted\");\r\n\r\n            const tempWavFile = path.join(\r\n                this.CONTENT_CACHE_DIR,\r\n                `temp_${Date.now()}.wav`\r\n            );\r\n            fs.writeFileSync(tempWavFile, convertedBuffer);\r\n\r\n            elizaLogger.debug(`Temporary WAV file created: ${tempWavFile}`);\r\n\r\n            let output = await nodewhisper(tempWavFile, {\r\n                modelName: \"base.en\",\r\n                autoDownloadModelName: \"base.en\",\r\n                verbose: false,\r\n                removeWavFileAfterTranscription: false,\r\n                withCuda: this.isCudaAvailable,\r\n                whisperOptions: {\r\n                    outputInText: true,\r\n                    outputInVtt: false,\r\n                    outputInSrt: false,\r\n                    outputInCsv: false,\r\n                    translateToEnglish: false,\r\n                    wordTimestamps: false,\r\n                    timestamps_length: 60,\r\n                    // splitOnWord: true,\r\n                },\r\n            });\r\n\r\n            output = output\r\n                .split(\"\\n\")\r\n                .map((line) => {\r\n                    if (line.trim().startsWith(\"[\")) {\r\n                        const endIndex = line.indexOf(\"]\");\r\n                        return line.substring(endIndex + 1);\r\n                    }\r\n                    return line;\r\n                })\r\n                .join(\"\\n\");\r\n\r\n            fs.unlinkSync(tempWavFile);\r\n\r\n            if (!output || output.length < 5) {\r\n                elizaLogger.log(\"Output is null or too short, returning null\");\r\n                return null;\r\n            }\r\n            return output;\r\n        } catch (error) {\r\n            elizaLogger.error(\r\n                \"Error in local speech-to-text conversion:\",\r\n                error\r\n            );\r\n            return null;\r\n        }\r\n    }\r\n}\r\n","import { Service } from \"@ai16z/eliza\";\r\nimport {\r\n    IAgentRuntime,\r\n    ITranscriptionService,\r\n    Media,\r\n    ServiceType,\r\n    IVideoService,\r\n} from \"@ai16z/eliza\";\r\nimport { stringToUuid } from \"@ai16z/eliza\";\r\nimport ffmpeg from \"fluent-ffmpeg\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport { tmpdir } from \"os\";\r\nimport youtubeDl from \"youtube-dl-exec\";\r\n\r\nexport class VideoService extends Service implements IVideoService {\r\n    static serviceType: ServiceType = ServiceType.VIDEO;\r\n    private cacheKey = \"content/video\";\r\n    private dataDir = \"./content_cache\";\r\n\r\n    private queue: string[] = [];\r\n    private processing: boolean = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.ensureDataDirectoryExists();\r\n    }\r\n\r\n    getInstance(): IVideoService {\r\n        return VideoService.getInstance();\r\n    }\r\n\r\n    async initialize(_runtime: IAgentRuntime): Promise<void> {}\r\n\r\n    private ensureDataDirectoryExists() {\r\n        if (!fs.existsSync(this.dataDir)) {\r\n            fs.mkdirSync(this.dataDir);\r\n        }\r\n    }\r\n\r\n    public isVideoUrl(url: string): boolean {\r\n        return (\r\n            url.includes(\"youtube.com\") ||\r\n            url.includes(\"youtu.be\") ||\r\n            url.includes(\"vimeo.com\")\r\n        );\r\n    }\r\n\r\n    public async downloadMedia(url: string): Promise<string> {\r\n        const videoId = this.getVideoId(url);\r\n        const outputFile = path.join(this.dataDir, `${videoId}.mp4`);\r\n\r\n        // if it already exists, return it\r\n        if (fs.existsSync(outputFile)) {\r\n            return outputFile;\r\n        }\r\n\r\n        try {\r\n            await youtubeDl(url, {\r\n                verbose: true,\r\n                output: outputFile,\r\n                writeInfoJson: true,\r\n            });\r\n            return outputFile;\r\n        } catch (error) {\r\n            console.error(\"Error downloading media:\", error);\r\n            throw new Error(\"Failed to download media\");\r\n        }\r\n    }\r\n\r\n    public async downloadVideo(videoInfo: any): Promise<string> {\r\n        const videoId = this.getVideoId(videoInfo.webpage_url);\r\n        const outputFile = path.join(this.dataDir, `${videoId}.mp4`);\r\n\r\n        // if it already exists, return it\r\n        if (fs.existsSync(outputFile)) {\r\n            return outputFile;\r\n        }\r\n\r\n        try {\r\n            await youtubeDl(videoInfo.webpage_url, {\r\n                verbose: true,\r\n                output: outputFile,\r\n                format: \"bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best\",\r\n                writeInfoJson: true,\r\n            });\r\n            return outputFile;\r\n        } catch (error) {\r\n            console.error(\"Error downloading video:\", error);\r\n            throw new Error(\"Failed to download video\");\r\n        }\r\n    }\r\n\r\n    public async processVideo(\r\n        url: string,\r\n        runtime: IAgentRuntime\r\n    ): Promise<Media> {\r\n        this.queue.push(url);\r\n        this.processQueue(runtime);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const checkQueue = async () => {\r\n                const index = this.queue.indexOf(url);\r\n                if (index !== -1) {\r\n                    setTimeout(checkQueue, 100);\r\n                } else {\r\n                    try {\r\n                        const result = await this.processVideoFromUrl(\r\n                            url,\r\n                            runtime\r\n                        );\r\n                        resolve(result);\r\n                    } catch (error) {\r\n                        reject(error);\r\n                    }\r\n                }\r\n            };\r\n            checkQueue();\r\n        });\r\n    }\r\n\r\n    private async processQueue(runtime): Promise<void> {\r\n        if (this.processing || this.queue.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this.processing = true;\r\n\r\n        while (this.queue.length > 0) {\r\n            const url = this.queue.shift()!;\r\n            await this.processVideoFromUrl(url, runtime);\r\n        }\r\n\r\n        this.processing = false;\r\n    }\r\n\r\n    private async processVideoFromUrl(\r\n        url: string,\r\n        runtime: IAgentRuntime\r\n    ): Promise<Media> {\r\n        const videoId =\r\n            url.match(\r\n                /(?:youtu\\.be\\/|youtube\\.com(?:\\/embed\\/|\\/v\\/|\\/watch\\?v=|\\/watch\\?.+&v=))([^\\/&?]+)/ // eslint-disable-line\r\n            )?.[1] || \"\";\r\n        const videoUuid = this.getVideoId(videoId);\r\n        const cacheKey = `${this.cacheKey}/${videoUuid}`;\r\n\r\n        const cached = await runtime.cacheManager.get<Media>(cacheKey);\r\n\r\n        if (cached) {\r\n            console.log(\"Returning cached video file\");\r\n            return cached;\r\n        }\r\n\r\n        console.log(\"Cache miss, processing video\");\r\n        console.log(\"Fetching video info\");\r\n        const videoInfo = await this.fetchVideoInfo(url);\r\n        console.log(\"Getting transcript\");\r\n        const transcript = await this.getTranscript(url, videoInfo, runtime);\r\n\r\n        const result: Media = {\r\n            id: videoUuid,\r\n            url: url,\r\n            title: videoInfo.title,\r\n            source: videoInfo.channel,\r\n            description: videoInfo.description,\r\n            text: transcript,\r\n        };\r\n\r\n        await runtime.cacheManager.set(cacheKey, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    private getVideoId(url: string): string {\r\n        return stringToUuid(url);\r\n    }\r\n\r\n    async fetchVideoInfo(url: string): Promise<any> {\r\n        if (url.endsWith(\".mp4\") || url.includes(\".mp4?\")) {\r\n            try {\r\n                const response = await fetch(url);\r\n                if (response.ok) {\r\n                    // If the URL is a direct link to an MP4 file, return a simplified video info object\r\n                    return {\r\n                        title: path.basename(url),\r\n                        description: \"\",\r\n                        channel: \"\",\r\n                    };\r\n                }\r\n            } catch (error) {\r\n                console.error(\"Error downloading MP4 file:\", error);\r\n                // Fall back to using youtube-dl if direct download fails\r\n            }\r\n        }\r\n\r\n        try {\r\n            const result = await youtubeDl(url, {\r\n                dumpJson: true,\r\n                verbose: true,\r\n                callHome: false,\r\n                noCheckCertificates: true,\r\n                preferFreeFormats: true,\r\n                youtubeSkipDashManifest: true,\r\n                writeSub: true,\r\n                writeAutoSub: true,\r\n                subLang: \"en\",\r\n                skipDownload: true,\r\n            });\r\n            return result;\r\n        } catch (error) {\r\n            console.error(\"Error fetching video info:\", error);\r\n            throw new Error(\"Failed to fetch video information\");\r\n        }\r\n    }\r\n\r\n    private async getTranscript(\r\n        url: string,\r\n        videoInfo: any,\r\n        runtime: IAgentRuntime\r\n    ): Promise<string> {\r\n        console.log(\"Getting transcript\");\r\n        try {\r\n            // Check for manual subtitles\r\n            if (videoInfo.subtitles && videoInfo.subtitles.en) {\r\n                console.log(\"Manual subtitles found\");\r\n                const srtContent = await this.downloadSRT(\r\n                    videoInfo.subtitles.en[0].url\r\n                );\r\n                return this.parseSRT(srtContent);\r\n            }\r\n\r\n            // Check for automatic captions\r\n            if (\r\n                videoInfo.automatic_captions &&\r\n                videoInfo.automatic_captions.en\r\n            ) {\r\n                console.log(\"Automatic captions found\");\r\n                const captionUrl = videoInfo.automatic_captions.en[0].url;\r\n                const captionContent = await this.downloadCaption(captionUrl);\r\n                return this.parseCaption(captionContent);\r\n            }\r\n\r\n            // Check if it's a music video\r\n            if (\r\n                videoInfo.categories &&\r\n                videoInfo.categories.includes(\"Music\")\r\n            ) {\r\n                console.log(\"Music video detected, no lyrics available\");\r\n                return \"No lyrics available.\";\r\n            }\r\n\r\n            // Fall back to audio transcription\r\n            console.log(\r\n                \"No captions found, falling back to audio transcription\"\r\n            );\r\n            return this.transcribeAudio(url, runtime);\r\n        } catch (error) {\r\n            console.error(\"Error in getTranscript:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async downloadCaption(url: string): Promise<string> {\r\n        console.log(\"Downloading caption from:\", url);\r\n        const response = await fetch(url);\r\n        if (!response.ok) {\r\n            throw new Error(\r\n                `Failed to download caption: ${response.statusText}`\r\n            );\r\n        }\r\n        return await response.text();\r\n    }\r\n\r\n    private parseCaption(captionContent: string): string {\r\n        console.log(\"Parsing caption\");\r\n        try {\r\n            const jsonContent = JSON.parse(captionContent);\r\n            if (jsonContent.events) {\r\n                return jsonContent.events\r\n                    .filter((event) => event.segs)\r\n                    .map((event) => event.segs.map((seg) => seg.utf8).join(\"\"))\r\n                    .join(\"\")\r\n                    .replace(\"\\n\", \" \");\r\n            } else {\r\n                console.error(\"Unexpected caption format:\", jsonContent);\r\n                return \"Error: Unable to parse captions\";\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Error parsing caption:\", error);\r\n            return \"Error: Unable to parse captions\";\r\n        }\r\n    }\r\n\r\n    private parseSRT(srtContent: string): string {\r\n        // Simple SRT parser (replace with a more robust solution if needed)\r\n        return srtContent\r\n            .split(\"\\n\\n\")\r\n            .map((block) => block.split(\"\\n\").slice(2).join(\" \"))\r\n            .join(\" \");\r\n    }\r\n\r\n    private async downloadSRT(url: string): Promise<string> {\r\n        console.log(\"downloadSRT\");\r\n        const response = await fetch(url);\r\n        return await response.text();\r\n    }\r\n\r\n    async transcribeAudio(\r\n        url: string,\r\n        runtime: IAgentRuntime\r\n    ): Promise<string> {\r\n        console.log(\"Preparing audio for transcription...\");\r\n        const mp4FilePath = path.join(\r\n            this.dataDir,\r\n            `${this.getVideoId(url)}.mp4`\r\n        );\r\n\r\n        const mp3FilePath = path.join(\r\n            this.dataDir,\r\n            `${this.getVideoId(url)}.mp3`\r\n        );\r\n\r\n        if (!fs.existsSync(mp3FilePath)) {\r\n            if (fs.existsSync(mp4FilePath)) {\r\n                console.log(\"MP4 file found. Converting to MP3...\");\r\n                await this.convertMp4ToMp3(mp4FilePath, mp3FilePath);\r\n            } else {\r\n                console.log(\"Downloading audio...\");\r\n                await this.downloadAudio(url, mp3FilePath);\r\n            }\r\n        }\r\n\r\n        console.log(`Audio prepared at ${mp3FilePath}`);\r\n\r\n        const audioBuffer = fs.readFileSync(mp3FilePath);\r\n        console.log(`Audio file size: ${audioBuffer.length} bytes`);\r\n\r\n        console.log(\"Starting transcription...\");\r\n        const startTime = Date.now();\r\n        const transcriptionService = runtime.getService<ITranscriptionService>(\r\n            ServiceType.TRANSCRIPTION\r\n        );\r\n\r\n        if (!transcriptionService) {\r\n            throw new Error(\"Transcription service not found\");\r\n        }\r\n\r\n        const transcript = await transcriptionService.transcribe(audioBuffer);\r\n\r\n        const endTime = Date.now();\r\n        console.log(\r\n            `Transcription completed in ${(endTime - startTime) / 1000} seconds`\r\n        );\r\n\r\n        // Don't delete the MP3 file as it might be needed for future use\r\n        return transcript || \"Transcription failed\";\r\n    }\r\n\r\n    private async convertMp4ToMp3(\r\n        inputPath: string,\r\n        outputPath: string\r\n    ): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            ffmpeg(inputPath)\r\n                .output(outputPath)\r\n                .noVideo()\r\n                .audioCodec(\"libmp3lame\")\r\n                .on(\"end\", () => {\r\n                    console.log(\"Conversion to MP3 complete\");\r\n                    resolve();\r\n                })\r\n                .on(\"error\", (err) => {\r\n                    console.error(\"Error converting to MP3:\", err);\r\n                    reject(err);\r\n                })\r\n                .run();\r\n        });\r\n    }\r\n\r\n    private async downloadAudio(\r\n        url: string,\r\n        outputFile: string\r\n    ): Promise<string> {\r\n        console.log(\"Downloading audio\");\r\n        outputFile =\r\n            outputFile ??\r\n            path.join(this.dataDir, `${this.getVideoId(url)}.mp3`);\r\n\r\n        try {\r\n            if (url.endsWith(\".mp4\") || url.includes(\".mp4?\")) {\r\n                console.log(\r\n                    \"Direct MP4 file detected, downloading and converting to MP3\"\r\n                );\r\n                const tempMp4File = path.join(\r\n                    tmpdir(),\r\n                    `${this.getVideoId(url)}.mp4`\r\n                );\r\n                const response = await fetch(url);\r\n                const arrayBuffer = await response.arrayBuffer();\r\n                const buffer = Buffer.from(arrayBuffer);\r\n                fs.writeFileSync(tempMp4File, buffer);\r\n\r\n                await new Promise<void>((resolve, reject) => {\r\n                    ffmpeg(tempMp4File)\r\n                        .output(outputFile)\r\n                        .noVideo()\r\n                        .audioCodec(\"libmp3lame\")\r\n                        .on(\"end\", () => {\r\n                            fs.unlinkSync(tempMp4File);\r\n                            resolve();\r\n                        })\r\n                        .on(\"error\", (err) => {\r\n                            reject(err);\r\n                        })\r\n                        .run();\r\n                });\r\n            } else {\r\n                console.log(\r\n                    \"YouTube video detected, downloading audio with youtube-dl\"\r\n                );\r\n                await youtubeDl(url, {\r\n                    verbose: true,\r\n                    extractAudio: true,\r\n                    audioFormat: \"mp3\",\r\n                    output: outputFile,\r\n                    writeInfoJson: true,\r\n                });\r\n            }\r\n            return outputFile;\r\n        } catch (error) {\r\n            console.error(\"Error downloading audio:\", error);\r\n            throw new Error(\"Failed to download audio\");\r\n        }\r\n    }\r\n}\r\n","export * from \"./services/index.ts\";\r\n\r\nimport { Plugin } from \"@ai16z/eliza\";\r\n\r\nimport {\r\n    BrowserService,\r\n    ImageDescriptionService,\r\n    LlamaService,\r\n    PdfService,\r\n    SpeechService,\r\n    TranscriptionService,\r\n    VideoService,\r\n} from \"./services/index.ts\";\r\n\r\nexport type NodePlugin = ReturnType<typeof createNodePlugin>;\r\n\r\nexport function createNodePlugin() {\r\n    return {\r\n        name: \"default\",\r\n        description: \"Default plugin, with basic actions and evaluators\",\r\n        services: [\r\n            new BrowserService(),\r\n            new ImageDescriptionService(),\r\n            new LlamaService(),\r\n            new PdfService(),\r\n            new SpeechService(),\r\n            new TranscriptionService(),\r\n            new VideoService(),\r\n        ],\r\n    } as const satisfies Plugin;\r\n}\r\n"],"mappings":"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","names":["Service","ServiceType","elizaLogger","ServiceType","ModelProviderName","Service","fs","path","response","ollamaUrl","embeddingModel","Service","ServiceType","ServiceType","Service","elizaLogger","Service","ServiceType","elizaLogger","settings","Service","ServiceType","fs","os","path","fileURLToPath","__dirname","Service","ServiceType","stringToUuid","fs","path"]}