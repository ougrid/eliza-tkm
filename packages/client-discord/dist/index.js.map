{"version":3,"sources":["../../../node_modules/lodash/isObject.js","../../../node_modules/lodash/_freeGlobal.js","../../../node_modules/lodash/_root.js","../../../node_modules/lodash/now.js","../../../node_modules/lodash/_trimmedEndIndex.js","../../../node_modules/lodash/_baseTrim.js","../../../node_modules/lodash/_Symbol.js","../../../node_modules/lodash/_getRawTag.js","../../../node_modules/lodash/_objectToString.js","../../../node_modules/lodash/_baseGetTag.js","../../../node_modules/lodash/isObjectLike.js","../../../node_modules/lodash/isSymbol.js","../../../node_modules/lodash/toNumber.js","../../../node_modules/lodash/debounce.js","../src/index.ts","../src/actions/chat_with_attachments.ts","../src/actions/download_media.ts","../src/actions/joinvoice.ts","../src/actions/leavevoice.ts","../src/actions/summarize_conversation.ts","../src/actions/transcribe_media.ts","../src/messages.ts","../src/attachments.ts","../src/templates.ts","../src/utils.ts","../src/providers/channelState.ts","../src/providers/voiceState.ts","../src/voice.ts"],"sourcesContent":["/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n","var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","import { getEmbeddingZeroVector } from \"@ai16z/eliza\";\r\nimport { Character, Client as ElizaClient, IAgentRuntime } from \"@ai16z/eliza\";\r\nimport { stringToUuid } from \"@ai16z/eliza\";\r\nimport { elizaLogger } from \"@ai16z/eliza\";\r\nimport {\r\n    Client,\r\n    Events,\r\n    GatewayIntentBits,\r\n    Guild,\r\n    MessageReaction,\r\n    Partials,\r\n    User,\r\n} from \"discord.js\";\r\nimport { EventEmitter } from \"events\";\r\nimport chat_with_attachments from \"./actions/chat_with_attachments.ts\";\r\nimport download_media from \"./actions/download_media.ts\";\r\nimport joinvoice from \"./actions/joinvoice.ts\";\r\nimport leavevoice from \"./actions/leavevoice.ts\";\r\nimport summarize from \"./actions/summarize_conversation.ts\";\r\nimport transcribe_media from \"./actions/transcribe_media.ts\";\r\nimport { MessageManager } from \"./messages.ts\";\r\nimport channelStateProvider from \"./providers/channelState.ts\";\r\nimport voiceStateProvider from \"./providers/voiceState.ts\";\r\nimport { VoiceManager } from \"./voice.ts\";\r\nimport { PermissionsBitField } from \"discord.js\";\r\n\r\nexport class DiscordClient extends EventEmitter {\r\n    apiToken: string;\r\n    client: Client;\r\n    runtime: IAgentRuntime;\r\n    character: Character;\r\n    private messageManager: MessageManager;\r\n    private voiceManager: VoiceManager;\r\n\r\n    constructor(runtime: IAgentRuntime) {\r\n        super();\r\n\r\n        this.apiToken = runtime.getSetting(\"DISCORD_API_TOKEN\") as string;\r\n        this.client = new Client({\r\n            intents: [\r\n                GatewayIntentBits.Guilds,\r\n                GatewayIntentBits.DirectMessages,\r\n                GatewayIntentBits.GuildVoiceStates,\r\n                GatewayIntentBits.MessageContent,\r\n                GatewayIntentBits.GuildMessages,\r\n                GatewayIntentBits.DirectMessageTyping,\r\n                GatewayIntentBits.GuildMessageTyping,\r\n                GatewayIntentBits.GuildMessageReactions,\r\n            ],\r\n            partials: [\r\n                Partials.Channel,\r\n                Partials.Message,\r\n                Partials.User,\r\n                Partials.Reaction,\r\n            ],\r\n        });\r\n\r\n        this.runtime = runtime;\r\n        this.voiceManager = new VoiceManager(this);\r\n        this.messageManager = new MessageManager(this, this.voiceManager);\r\n\r\n        this.client.once(Events.ClientReady, this.onClientReady.bind(this));\r\n        this.client.login(this.apiToken);\r\n\r\n        this.setupEventListeners();\r\n\r\n        this.runtime.registerAction(joinvoice);\r\n        this.runtime.registerAction(leavevoice);\r\n        this.runtime.registerAction(summarize);\r\n        this.runtime.registerAction(chat_with_attachments);\r\n        this.runtime.registerAction(transcribe_media);\r\n        this.runtime.registerAction(download_media);\r\n\r\n        this.runtime.providers.push(channelStateProvider);\r\n        this.runtime.providers.push(voiceStateProvider);\r\n    }\r\n\r\n    private setupEventListeners() {\r\n        // When joining to a new server\r\n        this.client.on(\"guildCreate\", this.handleGuildCreate.bind(this));\r\n\r\n        this.client.on(\r\n            Events.MessageReactionAdd,\r\n            this.handleReactionAdd.bind(this)\r\n        );\r\n        this.client.on(\r\n            Events.MessageReactionRemove,\r\n            this.handleReactionRemove.bind(this)\r\n        );\r\n\r\n        // Handle voice events with the voice manager\r\n        this.client.on(\r\n            \"voiceStateUpdate\",\r\n            this.voiceManager.handleVoiceStateUpdate.bind(this.voiceManager)\r\n        );\r\n        this.client.on(\r\n            \"userStream\",\r\n            this.voiceManager.handleUserStream.bind(this.voiceManager)\r\n        );\r\n\r\n        // Handle a new message with the message manager\r\n        this.client.on(\r\n            Events.MessageCreate,\r\n            this.messageManager.handleMessage.bind(this.messageManager)\r\n        );\r\n\r\n        // Handle a new interaction\r\n        this.client.on(\r\n            Events.InteractionCreate,\r\n            this.handleInteractionCreate.bind(this)\r\n        );\r\n    }\r\n\r\n    private async onClientReady(readyClient: { user: { tag: any; id: any } }) {\r\n        elizaLogger.success(`Logged in as ${readyClient.user?.tag}`);\r\n\r\n        // Register slash commands\r\n        const commands = [\r\n            {\r\n                name: \"joinchannel\",\r\n                description: \"Join a voice channel\",\r\n                options: [\r\n                    {\r\n                        name: \"channel\",\r\n                        type: 7, // CHANNEL type\r\n                        description: \"The voice channel to join\",\r\n                        required: true,\r\n                        channel_types: [2], // GuildVoice type\r\n                    },\r\n                ],\r\n            },\r\n            {\r\n                name: \"leavechannel\",\r\n                description: \"Leave the current voice channel\",\r\n            },\r\n        ];\r\n\r\n        try {\r\n            await this.client.application?.commands.set(commands);\r\n            elizaLogger.success(\"Slash commands registered\");\r\n        } catch (error) {\r\n            console.error(\"Error registering slash commands:\", error);\r\n        }\r\n\r\n        // Required permissions for the bot\r\n        const requiredPermissions = [\r\n            // Text Permissions\r\n            PermissionsBitField.Flags.ViewChannel,\r\n            PermissionsBitField.Flags.SendMessages,\r\n            PermissionsBitField.Flags.SendMessagesInThreads,\r\n            PermissionsBitField.Flags.CreatePrivateThreads,\r\n            PermissionsBitField.Flags.CreatePublicThreads,\r\n            PermissionsBitField.Flags.EmbedLinks,\r\n            PermissionsBitField.Flags.AttachFiles,\r\n            PermissionsBitField.Flags.AddReactions,\r\n            PermissionsBitField.Flags.UseExternalEmojis,\r\n            PermissionsBitField.Flags.UseExternalStickers,\r\n            PermissionsBitField.Flags.MentionEveryone,\r\n            PermissionsBitField.Flags.ManageMessages,\r\n            PermissionsBitField.Flags.ReadMessageHistory,\r\n            // Voice Permissions\r\n            PermissionsBitField.Flags.Connect,\r\n            PermissionsBitField.Flags.Speak,\r\n            PermissionsBitField.Flags.UseVAD,\r\n            PermissionsBitField.Flags.PrioritySpeaker,\r\n        ].reduce((a, b) => a | b, 0n);\r\n\r\n        elizaLogger.success(\"Use this URL to add the bot to your server:\");\r\n        elizaLogger.success(\r\n            `https://discord.com/api/oauth2/authorize?client_id=${readyClient.user?.id}&permissions=${requiredPermissions}&scope=bot%20applications.commands`\r\n        );\r\n        await this.onReady();\r\n    }\r\n\r\n    async handleReactionAdd(reaction: MessageReaction, user: User) {\r\n        try {\r\n            elizaLogger.log(\"Reaction added\");\r\n\r\n            // Early returns\r\n            if (!reaction || !user) {\r\n                elizaLogger.warn(\"Invalid reaction or user\");\r\n                return;\r\n            }\r\n\r\n            // Get emoji info\r\n            let emoji = reaction.emoji.name;\r\n            if (!emoji && reaction.emoji.id) {\r\n                emoji = `<:${reaction.emoji.name}:${reaction.emoji.id}>`;\r\n            }\r\n\r\n            // Fetch full message if partial\r\n            if (reaction.partial) {\r\n                try {\r\n                    await reaction.fetch();\r\n                } catch (error) {\r\n                    elizaLogger.error(\r\n                        \"Failed to fetch partial reaction:\",\r\n                        error\r\n                    );\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // Generate IDs with timestamp to ensure uniqueness\r\n            const timestamp = Date.now();\r\n            const roomId = stringToUuid(\r\n                `${reaction.message.channel.id}-${this.runtime.agentId}`\r\n            );\r\n            const userIdUUID = stringToUuid(\r\n                `${user.id}-${this.runtime.agentId}`\r\n            );\r\n            const reactionUUID = stringToUuid(\r\n                `${reaction.message.id}-${user.id}-${emoji}-${timestamp}-${this.runtime.agentId}`\r\n            );\r\n\r\n            // Validate IDs\r\n            if (!userIdUUID || !roomId) {\r\n                elizaLogger.error(\"Invalid user ID or room ID\", {\r\n                    userIdUUID,\r\n                    roomId,\r\n                });\r\n                return;\r\n            }\r\n\r\n            // Process message content\r\n            const messageContent = reaction.message.content || \"\";\r\n            const truncatedContent =\r\n                messageContent.length > 100\r\n                    ? `${messageContent.substring(0, 100)}...`\r\n                    : messageContent;\r\n            const reactionMessage = `*<${emoji}>: \"${truncatedContent}\"*`;\r\n\r\n            // Get user info\r\n            const userName = reaction.message.author?.username || \"unknown\";\r\n            const name = reaction.message.author?.displayName || userName;\r\n\r\n            // Ensure connection\r\n            await this.runtime.ensureConnection(\r\n                userIdUUID,\r\n                roomId,\r\n                userName,\r\n                name,\r\n                \"discord\"\r\n            );\r\n\r\n            // Create memory with retry logic\r\n            const memory = {\r\n                id: reactionUUID,\r\n                userId: userIdUUID,\r\n                agentId: this.runtime.agentId,\r\n                content: {\r\n                    text: reactionMessage,\r\n                    source: \"discord\",\r\n                    inReplyTo: stringToUuid(\r\n                        `${reaction.message.id}-${this.runtime.agentId}`\r\n                    ),\r\n                },\r\n                roomId,\r\n                createdAt: timestamp,\r\n                embedding: getEmbeddingZeroVector(),\r\n            };\r\n\r\n            try {\r\n                await this.runtime.messageManager.createMemory(memory);\r\n                elizaLogger.debug(\"Reaction memory created\", {\r\n                    reactionId: reactionUUID,\r\n                    emoji,\r\n                    userId: user.id,\r\n                });\r\n            } catch (error) {\r\n                if (error.code === \"23505\") {\r\n                    // Duplicate key error\r\n                    elizaLogger.warn(\"Duplicate reaction memory, skipping\", {\r\n                        reactionId: reactionUUID,\r\n                    });\r\n                    return;\r\n                }\r\n                throw error; // Re-throw other errors\r\n            }\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error handling reaction:\", error);\r\n        }\r\n    }\r\n\r\n    async handleReactionRemove(reaction: MessageReaction, user: User) {\r\n        elizaLogger.log(\"Reaction removed\");\r\n        // if (user.bot) return;\r\n\r\n        let emoji = reaction.emoji.name;\r\n        if (!emoji && reaction.emoji.id) {\r\n            emoji = `<:${reaction.emoji.name}:${reaction.emoji.id}>`;\r\n        }\r\n\r\n        // Fetch the full message if it's a partial\r\n        if (reaction.partial) {\r\n            try {\r\n                await reaction.fetch();\r\n            } catch (error) {\r\n                console.error(\r\n                    \"Something went wrong when fetching the message:\",\r\n                    error\r\n                );\r\n                return;\r\n            }\r\n        }\r\n\r\n        const messageContent = reaction.message.content;\r\n        const truncatedContent =\r\n            messageContent.length > 50\r\n                ? messageContent.substring(0, 50) + \"...\"\r\n                : messageContent;\r\n\r\n        const reactionMessage = `*Removed <${emoji} emoji> from: \"${truncatedContent}\"*`;\r\n\r\n        const roomId = stringToUuid(\r\n            reaction.message.channel.id + \"-\" + this.runtime.agentId\r\n        );\r\n        const userIdUUID = stringToUuid(user.id);\r\n\r\n        // Generate a unique UUID for the reaction removal\r\n        const reactionUUID = stringToUuid(\r\n            `${reaction.message.id}-${user.id}-${emoji}-removed-${this.runtime.agentId}`\r\n        );\r\n\r\n        const userName = reaction.message.author.username;\r\n        const name = reaction.message.author.displayName;\r\n\r\n        await this.runtime.ensureConnection(\r\n            userIdUUID,\r\n            roomId,\r\n            userName,\r\n            name,\r\n            \"discord\"\r\n        );\r\n\r\n        try {\r\n            // Save the reaction removal as a message\r\n            await this.runtime.messageManager.createMemory({\r\n                id: reactionUUID, // This is the ID of the reaction removal message\r\n                userId: userIdUUID,\r\n                agentId: this.runtime.agentId,\r\n                content: {\r\n                    text: reactionMessage,\r\n                    source: \"discord\",\r\n                    inReplyTo: stringToUuid(\r\n                        reaction.message.id + \"-\" + this.runtime.agentId\r\n                    ), // This is the ID of the original message\r\n                },\r\n                roomId,\r\n                createdAt: Date.now(),\r\n                embedding: getEmbeddingZeroVector(),\r\n            });\r\n        } catch (error) {\r\n            console.error(\"Error creating reaction removal message:\", error);\r\n        }\r\n    }\r\n\r\n    private handleGuildCreate(guild: Guild) {\r\n        console.log(`Joined guild ${guild.name}`);\r\n        this.voiceManager.scanGuild(guild);\r\n    }\r\n\r\n    private async handleInteractionCreate(interaction: any) {\r\n        if (!interaction.isCommand()) return;\r\n\r\n        switch (interaction.commandName) {\r\n            case \"joinchannel\":\r\n                await this.voiceManager.handleJoinChannelCommand(interaction);\r\n                break;\r\n            case \"leavechannel\":\r\n                await this.voiceManager.handleLeaveChannelCommand(interaction);\r\n                break;\r\n        }\r\n    }\r\n\r\n    private async onReady() {\r\n        const guilds = await this.client.guilds.fetch();\r\n        for (const [, guild] of guilds) {\r\n            const fullGuild = await guild.fetch();\r\n            this.voiceManager.scanGuild(fullGuild);\r\n        }\r\n    }\r\n}\r\n\r\nexport function startDiscord(runtime: IAgentRuntime) {\r\n    return new DiscordClient(runtime);\r\n}\r\n\r\nexport const DiscordClientInterface: ElizaClient = {\r\n    start: async (runtime: IAgentRuntime) => new DiscordClient(runtime),\r\n    stop: async (_runtime: IAgentRuntime) => {\r\n        console.warn(\"Discord client does not support stopping yet\");\r\n    },\r\n};\r\n","import { composeContext } from \"@ai16z/eliza\";\r\nimport { generateText, trimTokens } from \"@ai16z/eliza\";\r\nimport { models } from \"@ai16z/eliza\";\r\nimport { parseJSONObjectFromText } from \"@ai16z/eliza\";\r\nimport {\r\n    Action,\r\n    ActionExample,\r\n    Content,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Memory,\r\n    ModelClass,\r\n    State,\r\n} from \"@ai16z/eliza\";\r\nexport const summarizationTemplate = `# Summarized so far (we are adding to this)\r\n{{currentSummary}}\r\n\r\n# Current attachments we are summarizing\r\n{{attachmentsWithText}}\r\n\r\nSummarization objective: {{objective}}\r\n\r\n# Instructions: Summarize the attachments. Return the summary. Do not acknowledge this request, just summarize and continue the existing summary if there is one. Capture any important details based on the objective. Only respond with the new summary text.`;\r\n\r\nexport const attachmentIdsTemplate = `# Messages we are summarizing \r\n{{recentMessages}}\r\n\r\n# Instructions: {{senderName}} is requesting a summary of specific attachments. Your goal is to determine their objective, along with the list of attachment IDs to summarize.\r\nThe \"objective\" is a detailed description of what the user wants to summarize based on the conversation.\r\nThe \"attachmentIds\" is an array of attachment IDs that the user wants to summarize. If not specified, default to including all attachments from the conversation.\r\n\r\nYour response must be formatted as a JSON block with this structure:\r\n\\`\\`\\`json\r\n{\r\n  \"objective\": \"<What the user wants to summarize>\",\r\n  \"attachmentIds\": [\"<Attachment ID 1>\", \"<Attachment ID 2>\", ...]\r\n}\r\n\\`\\`\\`\r\n`;\r\n\r\nconst getAttachmentIds = async (\r\n    runtime: IAgentRuntime,\r\n    message: Memory,\r\n    state: State\r\n): Promise<{ objective: string; attachmentIds: string[] } | null> => {\r\n    state = (await runtime.composeState(message)) as State;\r\n\r\n    const context = composeContext({\r\n        state,\r\n        template: attachmentIdsTemplate,\r\n    });\r\n\r\n    for (let i = 0; i < 5; i++) {\r\n        const response = await generateText({\r\n            runtime,\r\n            context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n        console.log(\"response\", response);\r\n        // try parsing to a json object\r\n        const parsedResponse = parseJSONObjectFromText(response) as {\r\n            objective: string;\r\n            attachmentIds: string[];\r\n        } | null;\r\n        // see if it contains objective and attachmentIds\r\n        if (parsedResponse?.objective && parsedResponse?.attachmentIds) {\r\n            return parsedResponse;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nconst summarizeAction = {\r\n    name: \"CHAT_WITH_ATTACHMENTS\",\r\n    similes: [\r\n        \"CHAT_WITH_ATTACHMENT\",\r\n        \"SUMMARIZE_FILES\",\r\n        \"SUMMARIZE_FILE\",\r\n        \"SUMMARIZE_ATACHMENT\",\r\n        \"CHAT_WITH_PDF\",\r\n        \"ATTACHMENT_SUMMARY\",\r\n        \"RECAP_ATTACHMENTS\",\r\n        \"SUMMARIZE_FILE\",\r\n        \"SUMMARIZE_VIDEO\",\r\n        \"SUMMARIZE_AUDIO\",\r\n        \"SUMMARIZE_IMAGE\",\r\n        \"SUMMARIZE_DOCUMENT\",\r\n        \"SUMMARIZE_LINK\",\r\n        \"ATTACHMENT_SUMMARY\",\r\n        \"FILE_SUMMARY\",\r\n    ],\r\n    description:\r\n        \"Answer a user request informed by specific attachments based on their IDs. If a user asks to chat with a PDF, or wants more specific information about a link or video or anything else they've attached, this is the action to use.\",\r\n    validate: async (\r\n        _runtime: IAgentRuntime,\r\n        message: Memory,\r\n        _state: State\r\n    ) => {\r\n        if (message.content.source !== \"discord\") {\r\n            return false;\r\n        }\r\n        // only show if one of the keywords are in the message\r\n        const keywords: string[] = [\r\n            \"attachment\",\r\n            \"summary\",\r\n            \"summarize\",\r\n            \"research\",\r\n            \"pdf\",\r\n            \"video\",\r\n            \"audio\",\r\n            \"image\",\r\n            \"document\",\r\n            \"link\",\r\n            \"file\",\r\n            \"attachment\",\r\n            \"summarize\",\r\n            \"code\",\r\n            \"report\",\r\n            \"write\",\r\n            \"details\",\r\n            \"information\",\r\n            \"talk\",\r\n            \"chat\",\r\n            \"read\",\r\n            \"listen\",\r\n            \"watch\",\r\n        ];\r\n        return keywords.some((keyword) =>\r\n            message.content.text.toLowerCase().includes(keyword.toLowerCase())\r\n        );\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        options: any,\r\n        callback: HandlerCallback\r\n    ) => {\r\n        state = (await runtime.composeState(message)) as State;\r\n\r\n        const callbackData: Content = {\r\n            text: \"\", // fill in later\r\n            action: \"CHAT_WITH_ATTACHMENTS_RESPONSE\",\r\n            source: message.content.source,\r\n            attachments: [],\r\n        };\r\n\r\n        // 1. extract attachment IDs from the message\r\n        const attachmentData = await getAttachmentIds(runtime, message, state);\r\n        if (!attachmentData) {\r\n            console.error(\"Couldn't get attachment IDs from message\");\r\n            return;\r\n        }\r\n\r\n        const { objective, attachmentIds } = attachmentData;\r\n\r\n        // This is pretty gross but it can catch cases where the returned generated UUID is stupidly wrong for some reason\r\n        const attachments = state.recentMessagesData\r\n            .filter(\r\n                (msg) =>\r\n                    msg.content.attachments &&\r\n                    msg.content.attachments.length > 0\r\n            )\r\n            .flatMap((msg) => msg.content.attachments)\r\n            // check by first 5 characters of uuid\r\n            .filter(\r\n                (attachment) =>\r\n                    attachmentIds\r\n                        .map((attch) => attch.toLowerCase().slice(0, 5))\r\n                        .includes(attachment.id.toLowerCase().slice(0, 5)) ||\r\n                    // or check the other way\r\n                    attachmentIds.some((id) => {\r\n                        const attachmentId = id.toLowerCase().slice(0, 5);\r\n                        return attachment.id\r\n                            .toLowerCase()\r\n                            .includes(attachmentId);\r\n                    })\r\n            );\r\n\r\n        const attachmentsWithText = attachments\r\n            .map((attachment) => `# ${attachment.title}\\n${attachment.text}`)\r\n            .join(\"\\n\\n\");\r\n\r\n        let currentSummary = \"\";\r\n\r\n        const model = models[runtime.character.modelProvider];\r\n        const chunkSize = model.settings.maxOutputTokens;\r\n\r\n        state.attachmentsWithText = attachmentsWithText;\r\n        state.objective = objective;\r\n\r\n        const context = composeContext({\r\n            state,\r\n            // make sure it fits, we can pad the tokens a bit\r\n            template: trimTokens(\r\n                summarizationTemplate,\r\n                chunkSize + 500,\r\n                \"gpt-4o-mini\" // TODO: make this dynamic and generic\r\n            ),\r\n        });\r\n\r\n        const summary = await generateText({\r\n            runtime,\r\n            context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n\r\n        currentSummary = currentSummary + \"\\n\" + summary;\r\n\r\n        if (!currentSummary) {\r\n            console.error(\"No summary found, that's not good!\");\r\n            return;\r\n        }\r\n\r\n        callbackData.text = currentSummary.trim();\r\n        if (\r\n            callbackData.text &&\r\n            (currentSummary.trim()?.split(\"\\n\").length < 4 ||\r\n                currentSummary.trim()?.split(\" \").length < 100)\r\n        ) {\r\n            callbackData.text = `Here is the summary:\r\n\\`\\`\\`md\r\n${currentSummary.trim()}\r\n\\`\\`\\`\r\n`;\r\n            await callback(callbackData);\r\n        } else if (currentSummary.trim()) {\r\n            const summaryFilename = `content/summary_${Date.now()}`;\r\n            await runtime.cacheManager.set(summaryFilename, currentSummary);\r\n            // save the summary to a file\r\n            await callback(\r\n                {\r\n                    ...callbackData,\r\n                    text: `I've attached the summary of the requested attachments as a text file.`,\r\n                },\r\n                [summaryFilename]\r\n            );\r\n        } else {\r\n            console.warn(\r\n                \"Empty response from chat with attachments action, skipping\"\r\n            );\r\n        }\r\n\r\n        return callbackData;\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Can you summarize the attachments b3e23, c4f67, and d5a89?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sure thing! I'll pull up those specific attachments and provide a summary of their content.\",\r\n                    action: \"CHAT_WITH_ATTACHMENTS\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"I need a technical summary of the PDFs I sent earlier - a1b2c3.pdf, d4e5f6.pdf, and g7h8i9.pdf\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"I'll take a look at those specific PDF attachments and put together a technical summary for you. Give me a few minutes to review them.\",\r\n                    action: \"CHAT_WITH_ATTACHMENTS\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Can you watch this video for me and tell me which parts you think are most relevant to the report I'm writing? (the one I attached in my last message)\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"sure, no problem.\",\r\n                    action: \"CHAT_WITH_ATTACHMENTS\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"can you read my blog post and give me a detailed breakdown of the key points I made, and then suggest a handful of tweets to promote it?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"great idea, give me a minute\",\r\n                    action: \"CHAT_WITH_ATTACHMENTS\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n\r\nexport default summarizeAction;\r\n","import path from \"path\";\r\nimport { composeContext } from \"@ai16z/eliza\";\r\nimport { parseJSONObjectFromText } from \"@ai16z/eliza\";\r\nimport {\r\n    Action,\r\n    ActionExample,\r\n    Content,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    IVideoService,\r\n    Memory,\r\n    ModelClass,\r\n    ServiceType,\r\n    State,\r\n} from \"@ai16z/eliza\";\r\nimport { generateText } from \"@ai16z/eliza\";\r\n\r\nexport const mediaUrlTemplate = `# Messages we are searching for a media URL\r\n{{recentMessages}}\r\n\r\n# Instructions: {{senderName}} is requesting to download a specific media file (video or audio). Your goal is to determine the URL of the media they want to download.\r\nThe \"mediaUrl\" is the URL of the media file that the user wants downloaded. If not specified, return null.\r\n\r\nYour response must be formatted as a JSON block with this structure:\r\n\\`\\`\\`json\r\n{\r\n  \"mediaUrl\": \"<Media URL>\"\r\n}\r\n\\`\\`\\`\r\n`;\r\n\r\nconst getMediaUrl = async (\r\n    runtime: IAgentRuntime,\r\n    message: Memory,\r\n    state: State\r\n): Promise<string | null> => {\r\n    if (!state) {\r\n        state = (await runtime.composeState(message)) as State;\r\n    }\r\n\r\n    const context = composeContext({\r\n        state,\r\n        template: mediaUrlTemplate,\r\n    });\r\n\r\n    for (let i = 0; i < 5; i++) {\r\n        const response = await generateText({\r\n            runtime,\r\n            context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n\r\n        const parsedResponse = parseJSONObjectFromText(response) as {\r\n            mediaUrl: string;\r\n        } | null;\r\n\r\n        if (parsedResponse?.mediaUrl) {\r\n            return parsedResponse.mediaUrl;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nexport default {\r\n    name: \"DOWNLOAD_MEDIA\",\r\n    similes: [\r\n        \"DOWNLOAD_VIDEO\",\r\n        \"DOWNLOAD_AUDIO\",\r\n        \"GET_MEDIA\",\r\n        \"DOWNLOAD_PODCAST\",\r\n        \"DOWNLOAD_YOUTUBE\",\r\n    ],\r\n    description:\r\n        \"Downloads a video or audio file from a URL and attaches it to the response message.\",\r\n    validate: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        _state: State\r\n    ) => {\r\n        if (message.content.source !== \"discord\") {\r\n            return false;\r\n        }\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        options: any,\r\n        callback: HandlerCallback\r\n    ) => {\r\n        const videoService = runtime\r\n            .getService<IVideoService>(ServiceType.VIDEO)\r\n            .getInstance();\r\n        if (!state) {\r\n            state = (await runtime.composeState(message)) as State;\r\n        }\r\n\r\n        const mediaUrl = await getMediaUrl(runtime, message, state);\r\n        if (!mediaUrl) {\r\n            console.error(\"Couldn't get media URL from messages\");\r\n            return;\r\n        }\r\n\r\n        const videoInfo = await videoService.fetchVideoInfo(mediaUrl);\r\n        const mediaPath = await videoService.downloadVideo(videoInfo);\r\n\r\n        const response: Content = {\r\n            text: `I downloaded the video \"${videoInfo.title}\" and attached it below.`,\r\n            action: \"DOWNLOAD_MEDIA_RESPONSE\",\r\n            source: message.content.source,\r\n            attachments: [],\r\n        };\r\n\r\n        const filename = path.basename(mediaPath);\r\n\r\n        const maxRetries = 3;\r\n        let retries = 0;\r\n\r\n        while (retries < maxRetries) {\r\n            try {\r\n                await callback(\r\n                    {\r\n                        ...response,\r\n                    },\r\n                    [\"content_cache/\" + filename]\r\n                );\r\n                break;\r\n            } catch (error) {\r\n                retries++;\r\n                console.error(\r\n                    `Error sending message (attempt ${retries}):`,\r\n                    error\r\n                );\r\n\r\n                if (retries === maxRetries) {\r\n                    console.error(\r\n                        \"Max retries reached. Failed to send message with attachment.\"\r\n                    );\r\n                    break;\r\n                }\r\n\r\n                // Wait for a short delay before retrying\r\n                await new Promise((resolve) => setTimeout(resolve, 2000));\r\n            }\r\n        }\r\n\r\n        return response;\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Downloading the YouTube video now, one sec\",\r\n                    action: \"DOWNLOAD_MEDIA\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Can you grab this video for me? https://vimeo.com/123456789\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sure thing, I'll download that Vimeo video for you\",\r\n                    action: \"DOWNLOAD_MEDIA\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"I need this video downloaded: https://www.youtube.com/watch?v=abcdefg\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"No problem, I'm on it. I'll have that YouTube video downloaded in a jiffy\",\r\n                    action: \"DOWNLOAD_MEDIA\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n","// eslint-disable-next-line\r\n// @ts-nocheck\r\n// src/actions/joinVoice\r\nimport {\r\n    Action,\r\n    ActionExample,\r\n    composeContext,\r\n    IAgentRuntime,\r\n    Memory,\r\n    State,\r\n} from \"@ai16z/eliza\";\r\nimport {\r\n    Channel,\r\n    ChannelType,\r\n    Client,\r\n    Message as DiscordMessage,\r\n    Guild,\r\n    GuildMember,\r\n} from \"discord.js\";\r\n\r\nexport default {\r\n    name: \"JOIN_VOICE\",\r\n    similes: [\r\n        \"JOIN_VOICE\",\r\n        \"JOIN_VC\",\r\n        \"JOIN_VOICE_CHAT\",\r\n        \"JOIN_VOICE_CHANNEL\",\r\n        \"JOIN_MEETING\",\r\n        \"JOIN_CALL\",\r\n    ],\r\n    validate: async (\r\n        _runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State\r\n    ) => {\r\n        if (message.content.source !== \"discord\") {\r\n            // not a discord message\r\n            return false;\r\n        }\r\n\r\n        if (!state.discordClient) {\r\n            return;\r\n        }\r\n\r\n        // did they say something about joining a voice channel? if not, don't validate\r\n        const keywords = [\r\n            \"join\",\r\n            \"come to\",\r\n            \"come on\",\r\n            \"enter\",\r\n            \"voice\",\r\n            \"chat\",\r\n            \"talk\",\r\n            \"call\",\r\n            \"hop on\",\r\n            \"get on\",\r\n            \"vc\",\r\n            \"meeting\",\r\n            \"discussion\",\r\n        ];\r\n        if (\r\n            !keywords.some((keyword) =>\r\n                message.content.text.toLowerCase().includes(keyword)\r\n            )\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        const client = state.discordClient as Client;\r\n\r\n        // Check if the client is connected to any voice channel\r\n        const isConnectedToVoice = client.voice.adapters.size === 0;\r\n\r\n        return isConnectedToVoice;\r\n    },\r\n    description: \"Join a voice channel to participate in voice chat.\",\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State\r\n    ): Promise<boolean> => {\r\n        if (!state) {\r\n            console.error(\"State is not available.\");\r\n        }\r\n\r\n        // We normalize data in from voice channels\r\n        const discordMessage = (state.discordChannel ||\r\n            state.discordMessage) as DiscordMessage;\r\n\r\n        if (!discordMessage.content) {\r\n            discordMessage.content = message.content.text;\r\n        }\r\n\r\n        const id = (discordMessage as DiscordMessage).guild?.id as string;\r\n        const client = state.discordClient as Client;\r\n        const voiceChannels = (\r\n            client.guilds.cache.get(id) as Guild\r\n        ).channels.cache.filter(\r\n            (channel: Channel) => channel.type === ChannelType.GuildVoice\r\n        );\r\n\r\n        const messageContent = discordMessage.content;\r\n\r\n        const targetChannel = voiceChannels.find((channel) => {\r\n            const name = (channel as { name: string }).name.toLowerCase();\r\n\r\n            // remove all non-alphanumeric characters (keep spaces between words)\r\n            const replacedName = name.replace(/[^a-z0-9 ]/g, \"\");\r\n\r\n            return (\r\n                name.includes(messageContent) ||\r\n                messageContent.includes(name) ||\r\n                replacedName.includes(messageContent) ||\r\n                messageContent.includes(replacedName)\r\n            );\r\n        });\r\n\r\n        if (!state.voiceManager) {\r\n            state.voiceManager = new VoiceManager({\r\n                client: state.discordClient,\r\n                runtime: runtime,\r\n            });\r\n        }\r\n\r\n        if (targetChannel) {\r\n            state.voiceManager.joinVoiceChannel({\r\n                channelId: targetChannel.id,\r\n                guildId: (discordMessage as DiscordMessage).guild?.id as string,\r\n                adapterCreator: (client.guilds.cache.get(id) as Guild)\r\n                    .voiceAdapterCreator,\r\n            });\r\n            return true;\r\n        } else {\r\n            const member = (discordMessage as DiscordMessage)\r\n                .member as GuildMember;\r\n            if (member?.voice?.channel) {\r\n                state.voiceManager.joinVoiceChannel({\r\n                    channelId: member.voice.channel.id,\r\n                    guildId: (discordMessage as DiscordMessage).guild\r\n                        ?.id as string,\r\n                    adapterCreator: (client.guilds.cache.get(id) as Guild)\r\n                        .voiceAdapterCreator,\r\n                });\r\n                return true;\r\n            }\r\n\r\n            const messageTemplate = `\r\nThe user has requested to join a voice channel.\r\nHere is the list of channels available in the server:\r\n{{voiceChannels}}\r\n\r\nHere is the user's request:\r\n{{userMessage}}\r\n\r\nPlease respond with the name of the voice channel which the bot should join. Try to infer what channel the user is talking about. If the user didn't specify a voice channel, respond with \"none\".\r\nYou should only respond with the name of the voice channel or none, no commentary or additional information should be included.\r\n`;\r\n\r\n            const guessState = {\r\n                userMessage: message.content.text,\r\n                voiceChannels: voiceChannels\r\n                    .map((channel) => (channel as { name: string }).name)\r\n                    .join(\"\\n\"),\r\n            };\r\n\r\n            const context = composeContext({\r\n                template: messageTemplate,\r\n                state: guessState as unknown as State,\r\n            });\r\n\r\n            const _datestr = new Date().toUTCString().replace(/:/g, \"-\");\r\n\r\n            const responseContent = await generateText({\r\n                runtime,\r\n                context,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            runtime.databaseAdapter.log({\r\n                body: { message, context, response: responseContent },\r\n                userId: message.userId,\r\n                roomId: message.roomId,\r\n                type: \"joinvoice\",\r\n            });\r\n\r\n            if (responseContent && responseContent.trim().length > 0) {\r\n                // join the voice channel\r\n                const channelName = responseContent.toLowerCase();\r\n\r\n                const targetChannel = voiceChannels.find((channel) => {\r\n                    const name = (\r\n                        channel as { name: string }\r\n                    ).name.toLowerCase();\r\n\r\n                    // remove all non-alphanumeric characters (keep spaces between words)\r\n                    const replacedName = name.replace(/[^a-z0-9 ]/g, \"\");\r\n\r\n                    return (\r\n                        name.includes(channelName) ||\r\n                        channelName.includes(name) ||\r\n                        replacedName.includes(channelName) ||\r\n                        channelName.includes(replacedName)\r\n                    );\r\n                });\r\n\r\n                if (targetChannel) {\r\n                    state.voiceManager.joinVoiceChannel({\r\n                        channelId: targetChannel.id,\r\n                        guildId: (discordMessage as DiscordMessage).guild\r\n                            ?.id as string,\r\n                        adapterCreator: (client.guilds.cache.get(id) as Guild)\r\n                            .voiceAdapterCreator,\r\n                    });\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            await (discordMessage as DiscordMessage).reply(\r\n                \"I couldn't figure out which channel you wanted me to join.\"\r\n            );\r\n            return false;\r\n        }\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Hey, let's jump into the 'General' voice and chat\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sounds good\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"{{user2}}, can you join the vc, I want to discuss our strat\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sure I'll join right now\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"hey {{user2}}, we're having a team meeting in the 'conference' voice channel, plz join us\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"OK see you there\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"{{user2}}, let's have a quick voice chat in the 'Lounge' channel.\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"kk be there in a sec\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Hey {{user2}}, can you join me in the 'Music' voice channel\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sure\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"join voice chat with us {{user2}}\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"coming\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"hop in vc {{user2}}\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"joining now\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"get in vc with us {{user2}}\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"im in\",\r\n                    action: \"JOIN_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n","// src/actions/leaveVoice\r\nimport { getVoiceConnection } from \"@discordjs/voice\";\r\nimport {\r\n    Channel,\r\n    ChannelType,\r\n    Client,\r\n    Message as DiscordMessage,\r\n} from \"discord.js\";\r\nimport {\r\n    Action,\r\n    ActionExample,\r\n    IAgentRuntime,\r\n    Memory,\r\n    State,\r\n} from \"@ai16z/eliza\";\r\n\r\nexport default {\r\n    name: \"LEAVE_VOICE\",\r\n    similes: [\r\n        \"LEAVE_VOICE\",\r\n        \"LEAVE_VC\",\r\n        \"LEAVE_VOICE_CHAT\",\r\n        \"LEAVE_VOICE_CHANNEL\",\r\n        \"LEAVE_MEETING\",\r\n        \"LEAVE_CALL\",\r\n    ],\r\n    validate: async (runtime: IAgentRuntime, message: Memory, state: State) => {\r\n        if (message.content.source !== \"discord\") {\r\n            // not a discord message\r\n            return false;\r\n        }\r\n\r\n        if (!state.discordClient) {\r\n            return false;\r\n        }\r\n\r\n        const keywords = [\r\n            \"leave\",\r\n            \"exit\",\r\n            \"stop\",\r\n            \"quit\",\r\n            \"get off\",\r\n            \"get out\",\r\n            \"bye\",\r\n            \"cya\",\r\n            \"see you\",\r\n            \"hop off\",\r\n            \"get off\",\r\n            \"voice\",\r\n            \"vc\",\r\n            \"chat\",\r\n            \"call\",\r\n            \"meeting\",\r\n            \"discussion\",\r\n        ];\r\n        if (\r\n            !keywords.some((keyword) =>\r\n                message.content.text.toLowerCase().includes(keyword)\r\n            )\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        const client = state.discordClient as Client;\r\n\r\n        // Check if the client is connected to any voice channel\r\n        const isConnectedToVoice = client.voice.adapters.size > 0;\r\n\r\n        return isConnectedToVoice;\r\n    },\r\n    description: \"Leave the current voice channel.\",\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State\r\n    ): Promise<boolean> => {\r\n        if (!state.discordClient) {\r\n            return;\r\n        }\r\n\r\n        const discordMessage = (state.discordMessage ||\r\n            state.discordChannel) as DiscordMessage;\r\n\r\n        if (!discordMessage) {\r\n            throw new Error(\"Discord message is not available in the state.\");\r\n        }\r\n        const voiceChannels = (state.discordClient as Client)?.guilds.cache\r\n            .get((discordMessage as DiscordMessage).guild?.id as string)\r\n            ?.channels.cache.filter(\r\n                (channel: Channel) => channel.type === ChannelType.GuildVoice\r\n            );\r\n\r\n        voiceChannels?.forEach((_channel: Channel) => {\r\n            const connection = getVoiceConnection(\r\n                (discordMessage as DiscordMessage).guild?.id as string\r\n            );\r\n            if (connection) {\r\n                connection.destroy();\r\n            }\r\n        });\r\n        return true;\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Hey {{user2}} please leave the voice channel\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sure\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"I have to go now but thanks for the chat\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"You too, talk to you later\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Great call everyone, hopping off now\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Agreed, I'll hop off too\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Hey {{user2}} I need you to step away from the voice chat for a bit\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"No worries, I'll leave the voice channel\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"{{user2}}, I think we covered everything, you can leave the voice chat now\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sounds good, see you both later\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"leave voice {{user2}}\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"ok leaving\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"plz leave the voice chat {{user2}}\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"aight im out\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"yo {{user2}} gtfo the vc\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"sorry, talk to you later\",\r\n                    action: \"LEAVE_VOICE\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n","import { composeContext } from \"@ai16z/eliza\";\r\nimport { generateText, splitChunks, trimTokens } from \"@ai16z/eliza\";\r\nimport { getActorDetails } from \"@ai16z/eliza\";\r\nimport { models } from \"@ai16z/eliza\";\r\nimport { parseJSONObjectFromText } from \"@ai16z/eliza\";\r\nimport {\r\n    Action,\r\n    ActionExample,\r\n    Content,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Media,\r\n    Memory,\r\n    ModelClass,\r\n    State,\r\n} from \"@ai16z/eliza\";\r\nexport const summarizationTemplate = `# Summarized so far (we are adding to this)\r\n{{currentSummary}}\r\n\r\n# Current conversation chunk we are summarizing (includes attachments)\r\n{{memoriesWithAttachments}}\r\n\r\nSummarization objective: {{objective}}\r\n\r\n# Instructions: Summarize the conversation so far. Return the summary. Do not acknowledge this request, just summarize and continue the existing summary if there is one. Capture any important details to the objective. Only respond with the new summary text.\r\nYour response should be extremely detailed and include any and all relevant information.`;\r\n\r\nexport const dateRangeTemplate = `# Messages we are summarizing (the conversation is continued after this)\r\n{{recentMessages}}\r\n\r\n# Instructions: {{senderName}} is requesting a summary of the conversation. Your goal is to determine their objective, along with the range of dates that their request covers.\r\nThe \"objective\" is a detailed description of what the user wants to summarize based on the conversation. If they just ask for a general summary, you can either base it off the converation if the summary range is very recent, or set the object to be general, like \"a detailed summary of the conversation between all users\".\r\nThe \"start\" and \"end\" are the range of dates that the user wants to summarize, relative to the current time. The start and end should be relative to the current time, and measured in seconds, minutes, hours and days. The format is \"2 days ago\" or \"3 hours ago\" or \"4 minutes ago\" or \"5 seconds ago\", i.e. \"<integer> <unit> ago\".\r\nIf you aren't sure, you can use a default range of \"0 minutes ago\" to \"2 hours ago\" or more. Better to err on the side of including too much than too little.\r\n\r\nYour response must be formatted as a JSON block with this structure:\r\n\\`\\`\\`json\r\n{\r\n  \"objective\": \"<What the user wants to summarize>\",\r\n  \"start\": \"0 minutes ago\",\r\n  \"end\": \"2 hours ago\"\r\n}\r\n\\`\\`\\`\r\n`;\r\n\r\nconst getDateRange = async (\r\n    runtime: IAgentRuntime,\r\n    message: Memory,\r\n    state: State\r\n) => {\r\n    state = (await runtime.composeState(message)) as State;\r\n\r\n    const context = composeContext({\r\n        state,\r\n        template: dateRangeTemplate,\r\n    });\r\n\r\n    for (let i = 0; i < 5; i++) {\r\n        const response = await generateText({\r\n            runtime,\r\n            context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n        console.log(\"response\", response);\r\n        // try parsing to a json object\r\n        const parsedResponse = parseJSONObjectFromText(response) as {\r\n            objective: string;\r\n            start: string | number;\r\n            end: string | number;\r\n        } | null;\r\n        // see if it contains objective, start and end\r\n        if (parsedResponse) {\r\n            if (\r\n                parsedResponse.objective &&\r\n                parsedResponse.start &&\r\n                parsedResponse.end\r\n            ) {\r\n                // TODO: parse start and end into timestamps\r\n                const startIntegerString = (\r\n                    parsedResponse.start as string\r\n                ).match(/\\d+/)?.[0];\r\n                const endIntegerString = (parsedResponse.end as string).match(\r\n                    /\\d+/\r\n                )?.[0];\r\n\r\n                // parse multiplier\r\n                const multipliers = {\r\n                    second: 1 * 1000,\r\n                    minute: 60 * 1000,\r\n                    hour: 3600 * 1000,\r\n                    day: 86400 * 1000,\r\n                };\r\n\r\n                const startMultiplier = (parsedResponse.start as string).match(\r\n                    /second|minute|hour|day/\r\n                )?.[0];\r\n                const endMultiplier = (parsedResponse.end as string).match(\r\n                    /second|minute|hour|day/\r\n                )?.[0];\r\n\r\n                const startInteger = startIntegerString\r\n                    ? parseInt(startIntegerString)\r\n                    : 0;\r\n                const endInteger = endIntegerString\r\n                    ? parseInt(endIntegerString)\r\n                    : 0;\r\n\r\n                // multiply by multiplier\r\n                const startTime =\r\n                    startInteger *\r\n                    multipliers[startMultiplier as keyof typeof multipliers];\r\n\r\n                console.log(\"startTime\", startTime);\r\n\r\n                const endTime =\r\n                    endInteger *\r\n                    multipliers[endMultiplier as keyof typeof multipliers];\r\n\r\n                console.log(\"endTime\", endTime);\r\n\r\n                // get the current time and subtract the start and end times\r\n                parsedResponse.start = Date.now() - startTime;\r\n                parsedResponse.end = Date.now() - endTime;\r\n\r\n                return parsedResponse;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nconst summarizeAction = {\r\n    name: \"SUMMARIZE_CONVERSATION\",\r\n    similes: [\r\n        \"RECAP\",\r\n        \"RECAP_CONVERSATION\",\r\n        \"SUMMARIZE_CHAT\",\r\n        \"SUMMARIZATION\",\r\n        \"CHAT_SUMMARY\",\r\n        \"CONVERSATION_SUMMARY\",\r\n    ],\r\n    description: \"Summarizes the conversation and attachments.\",\r\n    validate: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        _state: State\r\n    ) => {\r\n        if (message.content.source !== \"discord\") {\r\n            return false;\r\n        }\r\n        // only show if one of the keywords are in the message\r\n        const keywords: string[] = [\r\n            \"summarize\",\r\n            \"summarization\",\r\n            \"summary\",\r\n            \"recap\",\r\n            \"report\",\r\n            \"overview\",\r\n            \"review\",\r\n            \"rundown\",\r\n            \"wrap-up\",\r\n            \"brief\",\r\n            \"debrief\",\r\n            \"abstract\",\r\n            \"synopsis\",\r\n            \"outline\",\r\n            \"digest\",\r\n            \"abridgment\",\r\n            \"condensation\",\r\n            \"encapsulation\",\r\n            \"essence\",\r\n            \"gist\",\r\n            \"main points\",\r\n            \"key points\",\r\n            \"key takeaways\",\r\n            \"bulletpoint\",\r\n            \"highlights\",\r\n            \"tldr\",\r\n            \"tl;dr\",\r\n            \"in a nutshell\",\r\n            \"bottom line\",\r\n            \"long story short\",\r\n            \"sum up\",\r\n            \"sum it up\",\r\n            \"short version\",\r\n            \"bring me up to speed\",\r\n            \"catch me up\",\r\n        ];\r\n        return keywords.some((keyword) =>\r\n            message.content.text.toLowerCase().includes(keyword.toLowerCase())\r\n        );\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        options: any,\r\n        callback: HandlerCallback\r\n    ) => {\r\n        state = (await runtime.composeState(message)) as State;\r\n\r\n        const callbackData: Content = {\r\n            text: \"\", // fill in later\r\n            action: \"SUMMARIZATION_RESPONSE\",\r\n            source: message.content.source,\r\n            attachments: [],\r\n        };\r\n        const { roomId } = message;\r\n\r\n        // 1. extract date range from the message\r\n        const dateRange = await getDateRange(runtime, message, state);\r\n        if (!dateRange) {\r\n            console.error(\"Couldn't get date range from message\");\r\n            return;\r\n        }\r\n\r\n        console.log(\"dateRange\", dateRange);\r\n\r\n        const { objective, start, end } = dateRange;\r\n\r\n        // 2. get these memories from the database\r\n        const memories = await runtime.messageManager.getMemories({\r\n            roomId,\r\n            // subtract start from current time\r\n            start: parseInt(start as string),\r\n            end: parseInt(end as string),\r\n            count: 10000,\r\n            unique: false,\r\n        });\r\n\r\n        const actors = await getActorDetails({\r\n            runtime: runtime as IAgentRuntime,\r\n            roomId,\r\n        });\r\n\r\n        const actorMap = new Map(actors.map((actor) => [actor.id, actor]));\r\n\r\n        const formattedMemories = memories\r\n            .map((memory) => {\r\n                const attachments = memory.content.attachments\r\n                    ?.map((attachment: Media) => {\r\n                        return `---\\nAttachment: ${attachment.id}\\n${attachment.description}\\n${attachment.text}\\n---`;\r\n                    })\r\n                    .join(\"\\n\");\r\n                return `${actorMap.get(memory.userId)?.name ?? \"Unknown User\"} (${actorMap.get(memory.userId)?.username ?? \"\"}): ${memory.content.text}\\n${attachments}`;\r\n            })\r\n            .join(\"\\n\");\r\n\r\n        let currentSummary = \"\";\r\n\r\n        const model = models[runtime.character.settings.model];\r\n        const chunkSize = model.settings.maxContextLength - 1000;\r\n\r\n        const chunks = await splitChunks(formattedMemories, chunkSize, 0);\r\n\r\n        const _datestr = new Date().toUTCString().replace(/:/g, \"-\");\r\n\r\n        state.memoriesWithAttachments = formattedMemories;\r\n        state.objective = objective;\r\n\r\n        for (let i = 0; i < chunks.length; i++) {\r\n            const chunk = chunks[i];\r\n            state.currentSummary = currentSummary;\r\n            state.currentChunk = chunk;\r\n            const context = composeContext({\r\n                state,\r\n                // make sure it fits, we can pad the tokens a bit\r\n                template: trimTokens(\r\n                    summarizationTemplate,\r\n                    chunkSize + 500,\r\n                    \"gpt-4o-mini\"\r\n                ),\r\n            });\r\n\r\n            const summary = await generateText({\r\n                runtime,\r\n                context,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            currentSummary = currentSummary + \"\\n\" + summary;\r\n        }\r\n\r\n        if (!currentSummary) {\r\n            console.error(\"No summary found, that's not good!\");\r\n            return;\r\n        }\r\n\r\n        callbackData.text = currentSummary.trim();\r\n        if (\r\n            callbackData.text &&\r\n            (currentSummary.trim()?.split(\"\\n\").length < 4 ||\r\n                currentSummary.trim()?.split(\" \").length < 100)\r\n        ) {\r\n            callbackData.text = `Here is the summary:\r\n\\`\\`\\`md\r\n${currentSummary.trim()}\r\n\\`\\`\\`\r\n`;\r\n            await callback(callbackData);\r\n        } else if (currentSummary.trim()) {\r\n            const summaryFilename = `content/conversation_summary_${Date.now()}`;\r\n            await runtime.cacheManager.set(summaryFilename, currentSummary);\r\n            // save the summary to a file\r\n            await callback(\r\n                {\r\n                    ...callbackData,\r\n                    text: `I've attached the summary of the conversation from \\`${new Date(parseInt(start as string)).toString()}\\` to \\`${new Date(parseInt(end as string)).toString()}\\` as a text file.`,\r\n                },\r\n                [summaryFilename]\r\n            );\r\n        } else {\r\n            console.warn(\r\n                \"Empty response from summarize conversation action, skipping\"\r\n            );\r\n        }\r\n\r\n        return callbackData;\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"```js\\nconst x = 10\\n```\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"can you give me a detailed report on what we're talking about?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"sure, no problem, give me a minute to get that together for you\",\r\n                    action: \"SUMMARIZE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"please summarize the conversation we just had and include this blogpost i'm linking (Attachment: b3e12)\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"sure, give me a sec\",\r\n                    action: \"SUMMARIZE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Can you summarize what moon and avf are talking about?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Yeah, just hold on a second while I get that together for you...\",\r\n                    action: \"SUMMARIZE\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"i need to write a blog post about farming, can you summarize the discussion from a few hours ago?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"no probblem, give me a few minutes to read through everything\",\r\n                    action: \"SUMMARIZE\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n\r\nexport default summarizeAction;\r\n","import { composeContext } from \"@ai16z/eliza\";\r\nimport { generateText } from \"@ai16z/eliza\";\r\nimport { parseJSONObjectFromText } from \"@ai16z/eliza\";\r\nimport {\r\n    Action,\r\n    ActionExample,\r\n    Content,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Memory,\r\n    ModelClass,\r\n    State,\r\n} from \"@ai16z/eliza\";\r\n\r\nexport const transcriptionTemplate = `# Transcription of media file\r\n{{mediaTranscript}}\r\n\r\n# Instructions: Return only the full transcript of the media file without any additional context or commentary.`;\r\n\r\nexport const mediaAttachmentIdTemplate = `# Messages we are transcribing\r\n{{recentMessages}}\r\n\r\n# Instructions: {{senderName}} is requesting a transcription of a specific media file (audio or video). Your goal is to determine the ID of the attachment they want transcribed.\r\nThe \"attachmentId\" is the ID of the media file attachment that the user wants transcribed. If not specified, return null.\r\n\r\nYour response must be formatted as a JSON block with this structure:\r\n\\`\\`\\`json\r\n{\r\n  \"attachmentId\": \"<Attachment ID>\"\r\n}\r\n\\`\\`\\`\r\n`;\r\n\r\nconst getMediaAttachmentId = async (\r\n    runtime: IAgentRuntime,\r\n    message: Memory,\r\n    state: State\r\n): Promise<string | null> => {\r\n    state = (await runtime.composeState(message)) as State;\r\n\r\n    const context = composeContext({\r\n        state,\r\n        template: mediaAttachmentIdTemplate,\r\n    });\r\n\r\n    for (let i = 0; i < 5; i++) {\r\n        const response = await generateText({\r\n            runtime,\r\n            context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n        console.log(\"response\", response);\r\n\r\n        const parsedResponse = parseJSONObjectFromText(response) as {\r\n            attachmentId: string;\r\n        } | null;\r\n\r\n        if (parsedResponse?.attachmentId) {\r\n            return parsedResponse.attachmentId;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nconst transcribeMediaAction = {\r\n    name: \"TRANSCRIBE_MEDIA\",\r\n    similes: [\r\n        \"TRANSCRIBE_AUDIO\",\r\n        \"TRANSCRIBE_VIDEO\",\r\n        \"MEDIA_TRANSCRIPT\",\r\n        \"VIDEO_TRANSCRIPT\",\r\n        \"AUDIO_TRANSCRIPT\",\r\n    ],\r\n    description:\r\n        \"Transcribe the full text of an audio or video file that the user has attached.\",\r\n    validate: async (\r\n        _runtime: IAgentRuntime,\r\n        message: Memory,\r\n        _state: State\r\n    ) => {\r\n        if (message.content.source !== \"discord\") {\r\n            return false;\r\n        }\r\n\r\n        const keywords: string[] = [\r\n            \"transcribe\",\r\n            \"transcript\",\r\n            \"audio\",\r\n            \"video\",\r\n            \"media\",\r\n            \"youtube\",\r\n            \"meeting\",\r\n            \"recording\",\r\n            \"podcast\",\r\n            \"call\",\r\n            \"conference\",\r\n            \"interview\",\r\n            \"speech\",\r\n            \"lecture\",\r\n            \"presentation\",\r\n        ];\r\n        return keywords.some((keyword) =>\r\n            message.content.text.toLowerCase().includes(keyword.toLowerCase())\r\n        );\r\n    },\r\n    handler: async (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state: State,\r\n        options: any,\r\n        callback: HandlerCallback\r\n    ) => {\r\n        state = (await runtime.composeState(message)) as State;\r\n\r\n        const callbackData: Content = {\r\n            text: \"\", // fill in later\r\n            action: \"TRANSCRIBE_MEDIA_RESPONSE\",\r\n            source: message.content.source,\r\n            attachments: [],\r\n        };\r\n\r\n        const attachmentId = await getMediaAttachmentId(\r\n            runtime,\r\n            message,\r\n            state\r\n        );\r\n        if (!attachmentId) {\r\n            console.error(\"Couldn't get media attachment ID from message\");\r\n            return;\r\n        }\r\n\r\n        const attachment = state.recentMessagesData\r\n            .filter(\r\n                (msg) =>\r\n                    msg.content.attachments &&\r\n                    msg.content.attachments.length > 0\r\n            )\r\n            .flatMap((msg) => msg.content.attachments)\r\n            .find(\r\n                (attachment) =>\r\n                    attachment.id.toLowerCase() === attachmentId.toLowerCase()\r\n            );\r\n\r\n        if (!attachment) {\r\n            console.error(`Couldn't find attachment with ID ${attachmentId}`);\r\n            return;\r\n        }\r\n\r\n        const mediaTranscript = attachment.text;\r\n\r\n        callbackData.text = mediaTranscript.trim();\r\n\r\n        // if callbackData.text is < 4 lines or < 100 words, then we we callback with normal message wrapped in markdown block\r\n        if (\r\n            callbackData.text &&\r\n            (callbackData.text?.split(\"\\n\").length < 4 ||\r\n                callbackData.text?.split(\" \").length < 100)\r\n        ) {\r\n            callbackData.text = `Here is the transcript:\r\n\\`\\`\\`md\r\n${mediaTranscript.trim()}\r\n\\`\\`\\`\r\n`;\r\n            await callback(callbackData);\r\n        }\r\n        // if text is big, let's send as an attachment\r\n        else if (callbackData.text) {\r\n            const transcriptFilename = `content/transcript_${Date.now()}`;\r\n\r\n            // save the transcript to a file\r\n            await runtime.cacheManager.set(\r\n                transcriptFilename,\r\n                callbackData.text\r\n            );\r\n\r\n            await callback(\r\n                {\r\n                    ...callbackData,\r\n                    text: `I've attached the transcript as a text file.`,\r\n                },\r\n                [transcriptFilename]\r\n            );\r\n        } else {\r\n            console.warn(\r\n                \"Empty response from transcribe media action, skipping\"\r\n            );\r\n        }\r\n\r\n        return callbackData;\r\n    },\r\n    examples: [\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Please transcribe the audio file I just sent.\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Sure, I'll transcribe the full audio for you.\",\r\n                    action: \"TRANSCRIBE_MEDIA\",\r\n                },\r\n            },\r\n        ],\r\n        [\r\n            {\r\n                user: \"{{user1}}\",\r\n                content: {\r\n                    text: \"Can I get a transcript of that video recording?\",\r\n                },\r\n            },\r\n            {\r\n                user: \"{{user2}}\",\r\n                content: {\r\n                    text: \"Absolutely, give me a moment to generate the full transcript of the video.\",\r\n                    action: \"TRANSCRIBE_MEDIA\",\r\n                },\r\n            },\r\n        ],\r\n    ] as ActionExample[][],\r\n} as Action;\r\n\r\nexport default transcribeMediaAction;\r\n","import { composeContext } from \"@ai16z/eliza\";\r\nimport { generateMessageResponse, generateShouldRespond } from \"@ai16z/eliza\";\r\nimport {\r\n    Content,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    IBrowserService,\r\n    ISpeechService,\r\n    IVideoService,\r\n    Media,\r\n    Memory,\r\n    ModelClass,\r\n    ServiceType,\r\n    State,\r\n    UUID,\r\n} from \"@ai16z/eliza\";\r\nimport { stringToUuid, getEmbeddingZeroVector } from \"@ai16z/eliza\";\r\nimport {\r\n    ChannelType,\r\n    Client,\r\n    Message as DiscordMessage,\r\n    TextChannel,\r\n} from \"discord.js\";\r\nimport { elizaLogger } from \"@ai16z/eliza\";\r\nimport { AttachmentManager } from \"./attachments.ts\";\r\nimport { VoiceManager } from \"./voice.ts\";\r\nimport {\r\n    discordShouldRespondTemplate,\r\n    discordMessageHandlerTemplate,\r\n} from \"./templates.ts\";\r\nimport { sendMessageInChunks, canSendMessage } from \"./utils.ts\";\r\n\r\nexport type InterestChannels = {\r\n    [key: string]: {\r\n        lastMessageSent: number;\r\n        messages: { userId: UUID; userName: string; content: Content }[];\r\n    };\r\n};\r\n\r\nexport class MessageManager {\r\n    private client: Client;\r\n    private runtime: IAgentRuntime;\r\n    private attachmentManager: AttachmentManager;\r\n    private interestChannels: InterestChannels = {};\r\n    private discordClient: any;\r\n    private voiceManager: VoiceManager;\r\n\r\n    constructor(discordClient: any, voiceManager: VoiceManager) {\r\n        this.client = discordClient.client;\r\n        this.voiceManager = voiceManager;\r\n        this.discordClient = discordClient;\r\n        this.runtime = discordClient.runtime;\r\n        this.attachmentManager = new AttachmentManager(this.runtime);\r\n    }\r\n\r\n    async handleMessage(message: DiscordMessage) {\r\n        if (\r\n            message.interaction ||\r\n            message.author.id ===\r\n                this.client.user?.id /* || message.author?.bot*/\r\n        )\r\n            return;\r\n\r\n        if (\r\n            this.runtime.character.clientConfig?.discord\r\n                ?.shouldIgnoreBotMessages &&\r\n            message.author?.bot\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        if (\r\n            this.runtime.character.clientConfig?.discord\r\n                ?.shouldIgnoreDirectMessages &&\r\n            message.channel.type === ChannelType.DM\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        const userId = message.author.id as UUID;\r\n        const userName = message.author.username;\r\n        const name = message.author.displayName;\r\n        const channelId = message.channel.id;\r\n\r\n        try {\r\n            const { processedContent, attachments } =\r\n                await this.processMessageMedia(message);\r\n\r\n            const audioAttachments = message.attachments.filter((attachment) =>\r\n                attachment.contentType?.startsWith(\"audio/\")\r\n            );\r\n            if (audioAttachments.size > 0) {\r\n                const processedAudioAttachments =\r\n                    await this.attachmentManager.processAttachments(\r\n                        audioAttachments\r\n                    );\r\n                attachments.push(...processedAudioAttachments);\r\n            }\r\n\r\n            const roomId = stringToUuid(channelId + \"-\" + this.runtime.agentId);\r\n            const userIdUUID = stringToUuid(userId);\r\n\r\n            await this.runtime.ensureConnection(\r\n                userIdUUID,\r\n                roomId,\r\n                userName,\r\n                name,\r\n                \"discord\"\r\n            );\r\n\r\n            const messageId = stringToUuid(\r\n                message.id + \"-\" + this.runtime.agentId\r\n            );\r\n\r\n            let shouldIgnore = false;\r\n            let shouldRespond = true;\r\n\r\n            const content: Content = {\r\n                text: processedContent,\r\n                attachments: attachments,\r\n                source: \"discord\",\r\n                url: message.url,\r\n                inReplyTo: message.reference?.messageId\r\n                    ? stringToUuid(\r\n                          message.reference.messageId +\r\n                              \"-\" +\r\n                              this.runtime.agentId\r\n                      )\r\n                    : undefined,\r\n            };\r\n\r\n            const userMessage = {\r\n                content,\r\n                userId: userIdUUID,\r\n                agentId: this.runtime.agentId,\r\n                roomId,\r\n            };\r\n\r\n            const memory: Memory = {\r\n                id: stringToUuid(message.id + \"-\" + this.runtime.agentId),\r\n                ...userMessage,\r\n                userId: userIdUUID,\r\n                agentId: this.runtime.agentId,\r\n                roomId,\r\n                content,\r\n                createdAt: message.createdTimestamp,\r\n            };\r\n\r\n            if (content.text) {\r\n                await this.runtime.messageManager.addEmbeddingToMemory(memory);\r\n                await this.runtime.messageManager.createMemory(memory);\r\n            }\r\n\r\n            let state = await this.runtime.composeState(userMessage, {\r\n                discordClient: this.client,\r\n                discordMessage: message,\r\n                agentName:\r\n                    this.runtime.character.name ||\r\n                    this.client.user?.displayName,\r\n            });\r\n\r\n            const canSendResult = canSendMessage(message.channel);\r\n            if (!canSendResult.canSend) {\r\n                return elizaLogger.warn(\r\n                    `Cannot send message to channel ${message.channel}`,\r\n                    canSendResult\r\n                );\r\n            }\r\n\r\n            if (!shouldIgnore) {\r\n                shouldIgnore = await this._shouldIgnore(message);\r\n            }\r\n\r\n            if (shouldIgnore) {\r\n                return;\r\n            }\r\n            const hasInterest = this._checkInterest(channelId);\r\n\r\n            const agentUserState =\r\n                await this.runtime.databaseAdapter.getParticipantUserState(\r\n                    roomId,\r\n                    this.runtime.agentId\r\n                );\r\n\r\n            if (\r\n                agentUserState === \"MUTED\" &&\r\n                !message.mentions.has(this.client.user.id) &&\r\n                !hasInterest\r\n            ) {\r\n                console.log(\"Ignoring muted room\");\r\n                // Ignore muted rooms unless explicitly mentioned\r\n                return;\r\n            }\r\n\r\n            if (agentUserState === \"FOLLOWED\") {\r\n                shouldRespond = true; // Always respond in followed rooms\r\n            } else if (\r\n                (!shouldRespond && hasInterest) ||\r\n                (shouldRespond && !hasInterest)\r\n            ) {\r\n                shouldRespond = await this._shouldRespond(message, state);\r\n            }\r\n\r\n            if (shouldRespond) {\r\n                const context = composeContext({\r\n                    state,\r\n                    template:\r\n                        this.runtime.character.templates\r\n                            ?.discordMessageHandlerTemplate ||\r\n                        discordMessageHandlerTemplate,\r\n                });\r\n\r\n                const responseContent = await this._generateResponse(\r\n                    memory,\r\n                    state,\r\n                    context\r\n                );\r\n\r\n                responseContent.text = responseContent.text?.trim();\r\n                responseContent.inReplyTo = stringToUuid(\r\n                    message.id + \"-\" + this.runtime.agentId\r\n                );\r\n\r\n                if (!responseContent.text) {\r\n                    return;\r\n                }\r\n\r\n                const callback: HandlerCallback = async (\r\n                    content: Content,\r\n                    files: any[]\r\n                ) => {\r\n                    try {\r\n                        if (message.id && !content.inReplyTo) {\r\n                            content.inReplyTo = stringToUuid(\r\n                                message.id + \"-\" + this.runtime.agentId\r\n                            );\r\n                        }\r\n                        const messages = await sendMessageInChunks(\r\n                            message.channel as TextChannel,\r\n                            content.text,\r\n                            message.id,\r\n                            files\r\n                        );\r\n\r\n                        const memories: Memory[] = [];\r\n                        for (const m of messages) {\r\n                            let action = content.action;\r\n                            // If there's only one message or it's the last message, keep the original action\r\n                            // For multiple messages, set all but the last to 'CONTINUE'\r\n                            if (\r\n                                messages.length > 1 &&\r\n                                m !== messages[messages.length - 1]\r\n                            ) {\r\n                                action = \"CONTINUE\";\r\n                            }\r\n\r\n                            const memory: Memory = {\r\n                                id: stringToUuid(\r\n                                    m.id + \"-\" + this.runtime.agentId\r\n                                ),\r\n                                userId: this.runtime.agentId,\r\n                                agentId: this.runtime.agentId,\r\n                                content: {\r\n                                    ...content,\r\n                                    action,\r\n                                    inReplyTo: messageId,\r\n                                    url: m.url,\r\n                                },\r\n                                roomId,\r\n                                embedding: getEmbeddingZeroVector(),\r\n                                createdAt: m.createdTimestamp,\r\n                            };\r\n                            memories.push(memory);\r\n                        }\r\n                        for (const m of memories) {\r\n                            await this.runtime.messageManager.createMemory(m);\r\n                        }\r\n                        return memories;\r\n                    } catch (error) {\r\n                        console.error(\"Error sending message:\", error);\r\n                        return [];\r\n                    }\r\n                };\r\n\r\n                const responseMessages = await callback(responseContent);\r\n\r\n                state = await this.runtime.updateRecentMessageState(state);\r\n\r\n                await this.runtime.processActions(\r\n                    memory,\r\n                    responseMessages,\r\n                    state,\r\n                    callback\r\n                );\r\n            }\r\n            await this.runtime.evaluate(memory, state, shouldRespond);\r\n        } catch (error) {\r\n            console.error(\"Error handling message:\", error);\r\n            if (message.channel.type === ChannelType.GuildVoice) {\r\n                // For voice channels, use text-to-speech for the error message\r\n                const errorMessage = \"Sorry, I had a glitch. What was that?\";\r\n\r\n                const speechService = this.runtime.getService<ISpeechService>(\r\n                    ServiceType.SPEECH_GENERATION\r\n                );\r\n                if (!speechService) {\r\n                    throw new Error(\"Speech generation service not found\");\r\n                }\r\n\r\n                const audioStream = await speechService.generate(\r\n                    this.runtime,\r\n                    errorMessage\r\n                );\r\n                await this.voiceManager.playAudioStream(userId, audioStream);\r\n            } else {\r\n                // For text channels, send the error message\r\n                console.error(\"Error sending message:\", error);\r\n            }\r\n        }\r\n    }\r\n\r\n    async cacheMessages(channel: TextChannel, count: number = 20) {\r\n        const messages = await channel.messages.fetch({ limit: count });\r\n\r\n        // TODO: This is throwing an error but seems to work?\r\n        for (const [_, message] of messages) {\r\n            await this.handleMessage(message);\r\n        }\r\n    }\r\n\r\n    async processMessageMedia(\r\n        message: DiscordMessage\r\n    ): Promise<{ processedContent: string; attachments: Media[] }> {\r\n        let processedContent = message.content;\r\n\r\n        let attachments: Media[] = [];\r\n\r\n        // Process code blocks in the message content\r\n        const codeBlockRegex = /```([\\s\\S]*?)```/g;\r\n        let match;\r\n        while ((match = codeBlockRegex.exec(processedContent))) {\r\n            const codeBlock = match[1];\r\n            const lines = codeBlock.split(\"\\n\");\r\n            const title = lines[0];\r\n            const description = lines.slice(0, 3).join(\"\\n\");\r\n            const attachmentId =\r\n                `code-${Date.now()}-${Math.floor(Math.random() * 1000)}`.slice(\r\n                    -5\r\n                );\r\n            attachments.push({\r\n                id: attachmentId,\r\n                url: \"\",\r\n                title: title || \"Code Block\",\r\n                source: \"Code\",\r\n                description: description,\r\n                text: codeBlock,\r\n            });\r\n            processedContent = processedContent.replace(\r\n                match[0],\r\n                `Code Block (${attachmentId})`\r\n            );\r\n        }\r\n\r\n        // Process message attachments\r\n        if (message.attachments.size > 0) {\r\n            attachments = await this.attachmentManager.processAttachments(\r\n                message.attachments\r\n            );\r\n        }\r\n\r\n        // TODO: Move to attachments manager\r\n        const urlRegex = /(https?:\\/\\/[^\\s]+)/g;\r\n        const urls = processedContent.match(urlRegex) || [];\r\n\r\n        for (const url of urls) {\r\n            if (\r\n                this.runtime\r\n                    .getService<IVideoService>(ServiceType.VIDEO)\r\n                    ?.isVideoUrl(url)\r\n            ) {\r\n                const videoService = this.runtime.getService<IVideoService>(\r\n                    ServiceType.VIDEO\r\n                );\r\n                if (!videoService) {\r\n                    throw new Error(\"Video service not found\");\r\n                }\r\n                const videoInfo = await videoService.processVideo(\r\n                    url,\r\n                    this.runtime\r\n                );\r\n\r\n                attachments.push({\r\n                    id: `youtube-${Date.now()}`,\r\n                    url: url,\r\n                    title: videoInfo.title,\r\n                    source: \"YouTube\",\r\n                    description: videoInfo.description,\r\n                    text: videoInfo.text,\r\n                });\r\n            } else {\r\n                const browserService = this.runtime.getService<IBrowserService>(\r\n                    ServiceType.BROWSER\r\n                );\r\n                if (!browserService) {\r\n                    throw new Error(\"Browser service not found\");\r\n                }\r\n\r\n                const { title, description: summary } =\r\n                    await browserService.getPageContent(url, this.runtime);\r\n\r\n                attachments.push({\r\n                    id: `webpage-${Date.now()}`,\r\n                    url: url,\r\n                    title: title || \"Web Page\",\r\n                    source: \"Web\",\r\n                    description: summary,\r\n                    text: summary,\r\n                });\r\n            }\r\n        }\r\n\r\n        return { processedContent, attachments };\r\n    }\r\n\r\n    private _checkInterest(channelId: string): boolean {\r\n        return !!this.interestChannels[channelId];\r\n    }\r\n\r\n    private async _shouldIgnore(message: DiscordMessage): Promise<boolean> {\r\n        // if the message is from us, ignore\r\n        if (message.author.id === this.client.user?.id) return true;\r\n        let messageContent = message.content.toLowerCase();\r\n\r\n        // Replace the bot's @ping with the character name\r\n        const botMention = `<@!?${this.client.user?.id}>`;\r\n        messageContent = messageContent.replace(\r\n            new RegExp(botMention, \"gi\"),\r\n            this.runtime.character.name.toLowerCase()\r\n        );\r\n\r\n        // Replace the bot's username with the character name\r\n        const botUsername = this.client.user?.username.toLowerCase();\r\n        messageContent = messageContent.replace(\r\n            new RegExp(`\\\\b${botUsername}\\\\b`, \"g\"),\r\n            this.runtime.character.name.toLowerCase()\r\n        );\r\n\r\n        // strip all special characters\r\n        messageContent = messageContent.replace(/[^a-zA-Z0-9\\s]/g, \"\");\r\n\r\n        // short responses where ruby should stop talking and disengage unless mentioned again\r\n        const loseInterestWords = [\r\n            \"shut up\",\r\n            \"stop\",\r\n            \"please shut up\",\r\n            \"shut up please\",\r\n            \"dont talk\",\r\n            \"silence\",\r\n            \"stop talking\",\r\n            \"be quiet\",\r\n            \"hush\",\r\n            \"wtf\",\r\n            \"chill\",\r\n            \"stfu\",\r\n            \"stupid bot\",\r\n            \"dumb bot\",\r\n            \"stop responding\",\r\n            \"god damn it\",\r\n            \"god damn\",\r\n            \"goddamnit\",\r\n            \"can you not\",\r\n            \"can you stop\",\r\n            \"be quiet\",\r\n            \"hate you\",\r\n            \"hate this\",\r\n            \"fuck up\",\r\n        ];\r\n        if (\r\n            messageContent.length < 100 &&\r\n            loseInterestWords.some((word) => messageContent.includes(word))\r\n        ) {\r\n            delete this.interestChannels[message.channelId];\r\n            return true;\r\n        }\r\n\r\n        // If we're not interested in the channel and it's a short message, ignore it\r\n        if (\r\n            messageContent.length < 10 &&\r\n            !this.interestChannels[message.channelId]\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        const targetedPhrases = [\r\n            this.runtime.character.name + \" stop responding\",\r\n            this.runtime.character.name + \" stop talking\",\r\n            this.runtime.character.name + \" shut up\",\r\n            this.runtime.character.name + \" stfu\",\r\n            \"stop talking\" + this.runtime.character.name,\r\n            this.runtime.character.name + \" stop talking\",\r\n            \"shut up \" + this.runtime.character.name,\r\n            this.runtime.character.name + \" shut up\",\r\n            \"stfu \" + this.runtime.character.name,\r\n            this.runtime.character.name + \" stfu\",\r\n            \"chill\" + this.runtime.character.name,\r\n            this.runtime.character.name + \" chill\",\r\n        ];\r\n\r\n        // lose interest if pinged and told to stop responding\r\n        if (targetedPhrases.some((phrase) => messageContent.includes(phrase))) {\r\n            delete this.interestChannels[message.channelId];\r\n            return true;\r\n        }\r\n\r\n        // if the message is short, ignore but maintain interest\r\n        if (\r\n            !this.interestChannels[message.channelId] &&\r\n            messageContent.length < 2\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        const ignoreResponseWords = [\r\n            \"lol\",\r\n            \"nm\",\r\n            \"uh\",\r\n            \"wtf\",\r\n            \"stfu\",\r\n            \"dumb\",\r\n            \"jfc\",\r\n            \"omg\",\r\n        ];\r\n        if (\r\n            message.content.length < 4 &&\r\n            ignoreResponseWords.some((word) =>\r\n                message.content.toLowerCase().includes(word)\r\n            )\r\n        ) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private async _shouldRespond(\r\n        message: DiscordMessage,\r\n        state: State\r\n    ): Promise<boolean> {\r\n        if (message.author.id === this.client.user?.id) return false;\r\n        // if (message.author.bot) return false;\r\n        if (message.mentions.has(this.client.user?.id as string)) return true;\r\n\r\n        const guild = message.guild;\r\n        const member = guild?.members.cache.get(this.client.user?.id as string);\r\n        const nickname = member?.nickname;\r\n\r\n        if (\r\n            message.content\r\n                .toLowerCase()\r\n                .includes(this.client.user?.username.toLowerCase() as string) ||\r\n            message.content\r\n                .toLowerCase()\r\n                .includes(this.client.user?.tag.toLowerCase() as string) ||\r\n            (nickname &&\r\n                message.content.toLowerCase().includes(nickname.toLowerCase()))\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        if (!message.guild) {\r\n            return true;\r\n        }\r\n\r\n        // If none of the above conditions are met, use the generateText to decide\r\n        const shouldRespondContext = composeContext({\r\n            state,\r\n            template:\r\n                this.runtime.character.templates\r\n                    ?.discordShouldRespondTemplate ||\r\n                this.runtime.character.templates?.shouldRespondTemplate ||\r\n                discordShouldRespondTemplate,\r\n        });\r\n\r\n        const response = await generateShouldRespond({\r\n            runtime: this.runtime,\r\n            context: shouldRespondContext,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n\r\n        if (response === \"RESPOND\") {\r\n            return true;\r\n        } else if (response === \"IGNORE\") {\r\n            return false;\r\n        } else if (response === \"STOP\") {\r\n            delete this.interestChannels[message.channelId];\r\n            return false;\r\n        } else {\r\n            console.error(\r\n                \"Invalid response from response generateText:\",\r\n                response\r\n            );\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private async _generateResponse(\r\n        message: Memory,\r\n        state: State,\r\n        context: string\r\n    ): Promise<Content> {\r\n        const { userId, roomId } = message;\r\n\r\n        const response = await generateMessageResponse({\r\n            runtime: this.runtime,\r\n            context,\r\n            modelClass: ModelClass.LARGE,\r\n        });\r\n\r\n        if (!response) {\r\n            console.error(\"No response from generateMessageResponse\");\r\n            return;\r\n        }\r\n\r\n        await this.runtime.databaseAdapter.log({\r\n            body: { message, context, response },\r\n            userId: userId,\r\n            roomId,\r\n            type: \"response\",\r\n        });\r\n\r\n        return response;\r\n    }\r\n\r\n    async fetchBotName(botToken: string) {\r\n        const url = \"https://discord.com/api/v10/users/@me\";\r\n\r\n        const response = await fetch(url, {\r\n            method: \"GET\",\r\n            headers: {\r\n                Authorization: `Bot ${botToken}`,\r\n            },\r\n        });\r\n\r\n        if (!response.ok) {\r\n            throw new Error(\r\n                `Error fetching bot details: ${response.statusText}`\r\n            );\r\n        }\r\n\r\n        const data = await response.json();\r\n        return data.username;\r\n    }\r\n}\r\n","import { generateText, trimTokens } from \"@ai16z/eliza\";\r\nimport { parseJSONObjectFromText } from \"@ai16z/eliza\";\r\nimport {\r\n    IAgentRuntime,\r\n    IImageDescriptionService,\r\n    IPdfService,\r\n    ITranscriptionService,\r\n    IVideoService,\r\n    Media,\r\n    ModelClass,\r\n    ServiceType,\r\n} from \"@ai16z/eliza\";\r\nimport { Attachment, Collection } from \"discord.js\";\r\nimport ffmpeg from \"fluent-ffmpeg\";\r\nimport fs from \"fs\";\r\n\r\nasync function generateSummary(\r\n    runtime: IAgentRuntime,\r\n    text: string\r\n): Promise<{ title: string; description: string }> {\r\n    // make sure text is under 128k characters\r\n    text = trimTokens(text, 100000, \"gpt-4o-mini\"); // TODO: clean this up\r\n\r\n    const prompt = `Please generate a concise summary for the following text:\r\n  \r\n  Text: \"\"\"\r\n  ${text}\r\n  \"\"\"\r\n  \r\n  Respond with a JSON object in the following format:\r\n  \\`\\`\\`json\r\n  {\r\n    \"title\": \"Generated Title\",\r\n    \"summary\": \"Generated summary and/or description of the text\"\r\n  }\r\n  \\`\\`\\``;\r\n\r\n    const response = await generateText({\r\n        runtime,\r\n        context: prompt,\r\n        modelClass: ModelClass.SMALL,\r\n    });\r\n\r\n    const parsedResponse = parseJSONObjectFromText(response);\r\n\r\n    if (parsedResponse) {\r\n        return {\r\n            title: parsedResponse.title,\r\n            description: parsedResponse.summary,\r\n        };\r\n    }\r\n\r\n    return {\r\n        title: \"\",\r\n        description: \"\",\r\n    };\r\n}\r\n\r\nexport class AttachmentManager {\r\n    private attachmentCache: Map<string, Media> = new Map();\r\n    private runtime: IAgentRuntime;\r\n\r\n    constructor(runtime: IAgentRuntime) {\r\n        this.runtime = runtime;\r\n    }\r\n\r\n    async processAttachments(\r\n        attachments: Collection<string, Attachment> | Attachment[]\r\n    ): Promise<Media[]> {\r\n        const processedAttachments: Media[] = [];\r\n        const attachmentCollection =\r\n            attachments instanceof Collection\r\n                ? attachments\r\n                : new Collection(attachments.map((att) => [att.id, att]));\r\n\r\n        for (const [, attachment] of attachmentCollection) {\r\n            const media = await this.processAttachment(attachment);\r\n            if (media) {\r\n                processedAttachments.push(media);\r\n            }\r\n        }\r\n\r\n        return processedAttachments;\r\n    }\r\n\r\n    async processAttachment(attachment: Attachment): Promise<Media | null> {\r\n        if (this.attachmentCache.has(attachment.url)) {\r\n            return this.attachmentCache.get(attachment.url)!;\r\n        }\r\n\r\n        let media: Media | null = null;\r\n        if (attachment.contentType?.startsWith(\"application/pdf\")) {\r\n            media = await this.processPdfAttachment(attachment);\r\n        } else if (attachment.contentType?.startsWith(\"text/plain\")) {\r\n            media = await this.processPlaintextAttachment(attachment);\r\n        } else if (\r\n            attachment.contentType?.startsWith(\"audio/\") ||\r\n            attachment.contentType?.startsWith(\"video/mp4\")\r\n        ) {\r\n            media = await this.processAudioVideoAttachment(attachment);\r\n        } else if (attachment.contentType?.startsWith(\"image/\")) {\r\n            media = await this.processImageAttachment(attachment);\r\n        } else if (\r\n            attachment.contentType?.startsWith(\"video/\") ||\r\n            this.runtime\r\n                .getService<IVideoService>(ServiceType.VIDEO)\r\n                .isVideoUrl(attachment.url)\r\n        ) {\r\n            media = await this.processVideoAttachment(attachment);\r\n        } else {\r\n            media = await this.processGenericAttachment(attachment);\r\n        }\r\n\r\n        if (media) {\r\n            this.attachmentCache.set(attachment.url, media);\r\n        }\r\n        return media;\r\n    }\r\n\r\n    private async processAudioVideoAttachment(\r\n        attachment: Attachment\r\n    ): Promise<Media> {\r\n        try {\r\n            const response = await fetch(attachment.url);\r\n            const audioVideoArrayBuffer = await response.arrayBuffer();\r\n\r\n            let audioBuffer: Buffer;\r\n            if (attachment.contentType?.startsWith(\"audio/\")) {\r\n                audioBuffer = Buffer.from(audioVideoArrayBuffer);\r\n            } else if (attachment.contentType?.startsWith(\"video/mp4\")) {\r\n                audioBuffer = await this.extractAudioFromMP4(\r\n                    audioVideoArrayBuffer\r\n                );\r\n            } else {\r\n                throw new Error(\"Unsupported audio/video format\");\r\n            }\r\n\r\n            const transcriptionService =\r\n                this.runtime.getService<ITranscriptionService>(\r\n                    ServiceType.TRANSCRIPTION\r\n                );\r\n            if (!transcriptionService) {\r\n                throw new Error(\"Transcription service not found\");\r\n            }\r\n\r\n            const transcription =\r\n                await transcriptionService.transcribeAttachment(audioBuffer);\r\n            const { title, description } = await generateSummary(\r\n                this.runtime,\r\n                transcription\r\n            );\r\n\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: title || \"Audio/Video Attachment\",\r\n                source: attachment.contentType?.startsWith(\"audio/\")\r\n                    ? \"Audio\"\r\n                    : \"Video\",\r\n                description:\r\n                    description ||\r\n                    \"User-uploaded audio/video attachment which has been transcribed\",\r\n                text: transcription || \"Audio/video content not available\",\r\n            };\r\n        } catch (error) {\r\n            console.error(\r\n                `Error processing audio/video attachment: ${error.message}`\r\n            );\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: \"Audio/Video Attachment\",\r\n                source: attachment.contentType?.startsWith(\"audio/\")\r\n                    ? \"Audio\"\r\n                    : \"Video\",\r\n                description: \"An audio/video attachment (transcription failed)\",\r\n                text: `This is an audio/video attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes, Content type: ${attachment.contentType}`,\r\n            };\r\n        }\r\n    }\r\n\r\n    private async extractAudioFromMP4(mp4Data: ArrayBuffer): Promise<Buffer> {\r\n        // Use a library like 'fluent-ffmpeg' or 'ffmpeg-static' to extract the audio stream from the MP4 data\r\n        // and convert it to MP3 or WAV format\r\n        // Example using fluent-ffmpeg:\r\n        const tempMP4File = `temp_${Date.now()}.mp4`;\r\n        const tempAudioFile = `temp_${Date.now()}.mp3`;\r\n\r\n        try {\r\n            // Write the MP4 data to a temporary file\r\n            fs.writeFileSync(tempMP4File, Buffer.from(mp4Data));\r\n\r\n            // Extract the audio stream and convert it to MP3\r\n            await new Promise<void>((resolve, reject) => {\r\n                ffmpeg(tempMP4File)\r\n                    .outputOptions(\"-vn\") // Disable video output\r\n                    .audioCodec(\"libmp3lame\") // Set audio codec to MP3\r\n                    .save(tempAudioFile) // Save the output to the specified file\r\n                    .on(\"end\", () => {\r\n                        resolve();\r\n                    })\r\n                    .on(\"error\", (err) => {\r\n                        reject(err);\r\n                    })\r\n                    .run();\r\n            });\r\n\r\n            // Read the converted audio file and return it as a Buffer\r\n            const audioData = fs.readFileSync(tempAudioFile);\r\n            return audioData;\r\n        } finally {\r\n            // Clean up the temporary files\r\n            if (fs.existsSync(tempMP4File)) {\r\n                fs.unlinkSync(tempMP4File);\r\n            }\r\n            if (fs.existsSync(tempAudioFile)) {\r\n                fs.unlinkSync(tempAudioFile);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async processPdfAttachment(attachment: Attachment): Promise<Media> {\r\n        try {\r\n            const response = await fetch(attachment.url);\r\n            const pdfBuffer = await response.arrayBuffer();\r\n            const text = await this.runtime\r\n                .getService<IPdfService>(ServiceType.PDF)\r\n                .convertPdfToText(Buffer.from(pdfBuffer));\r\n            const { title, description } = await generateSummary(\r\n                this.runtime,\r\n                text\r\n            );\r\n\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: title || \"PDF Attachment\",\r\n                source: \"PDF\",\r\n                description: description || \"A PDF document\",\r\n                text: text,\r\n            };\r\n        } catch (error) {\r\n            console.error(`Error processing PDF attachment: ${error.message}`);\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: \"PDF Attachment (conversion failed)\",\r\n                source: \"PDF\",\r\n                description:\r\n                    \"A PDF document that could not be converted to text\",\r\n                text: `This is a PDF attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes`,\r\n            };\r\n        }\r\n    }\r\n\r\n    private async processPlaintextAttachment(\r\n        attachment: Attachment\r\n    ): Promise<Media> {\r\n        try {\r\n            const response = await fetch(attachment.url);\r\n            const text = await response.text();\r\n            const { title, description } = await generateSummary(\r\n                this.runtime,\r\n                text\r\n            );\r\n\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: title || \"Plaintext Attachment\",\r\n                source: \"Plaintext\",\r\n                description: description || \"A plaintext document\",\r\n                text: text,\r\n            };\r\n        } catch (error) {\r\n            console.error(\r\n                `Error processing plaintext attachment: ${error.message}`\r\n            );\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: \"Plaintext Attachment (retrieval failed)\",\r\n                source: \"Plaintext\",\r\n                description: \"A plaintext document that could not be retrieved\",\r\n                text: `This is a plaintext attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes`,\r\n            };\r\n        }\r\n    }\r\n\r\n    private async processImageAttachment(\r\n        attachment: Attachment\r\n    ): Promise<Media> {\r\n        try {\r\n            const { description, title } = await this.runtime\r\n                .getService<IImageDescriptionService>(\r\n                    ServiceType.IMAGE_DESCRIPTION\r\n                )\r\n                .describeImage(attachment.url);\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: title || \"Image Attachment\",\r\n                source: \"Image\",\r\n                description: description || \"An image attachment\",\r\n                text: description || \"Image content not available\",\r\n            };\r\n        } catch (error) {\r\n            console.error(\r\n                `Error processing image attachment: ${error.message}`\r\n            );\r\n            return this.createFallbackImageMedia(attachment);\r\n        }\r\n    }\r\n\r\n    private createFallbackImageMedia(attachment: Attachment): Media {\r\n        return {\r\n            id: attachment.id,\r\n            url: attachment.url,\r\n            title: \"Image Attachment\",\r\n            source: \"Image\",\r\n            description: \"An image attachment (recognition failed)\",\r\n            text: `This is an image attachment. File name: ${attachment.name}, Size: ${attachment.size} bytes, Content type: ${attachment.contentType}`,\r\n        };\r\n    }\r\n\r\n    private async processVideoAttachment(\r\n        attachment: Attachment\r\n    ): Promise<Media> {\r\n        const videoService = this.runtime.getService<IVideoService>(\r\n            ServiceType.VIDEO\r\n        );\r\n\r\n        if (!videoService) {\r\n            throw new Error(\"Video service not found\");\r\n        }\r\n\r\n        if (videoService.isVideoUrl(attachment.url)) {\r\n            const videoInfo = await videoService.processVideo(\r\n                attachment.url,\r\n                this.runtime\r\n            );\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: videoInfo.title,\r\n                source: \"YouTube\",\r\n                description: videoInfo.description,\r\n                text: videoInfo.text,\r\n            };\r\n        } else {\r\n            return {\r\n                id: attachment.id,\r\n                url: attachment.url,\r\n                title: \"Video Attachment\",\r\n                source: \"Video\",\r\n                description: \"A video attachment\",\r\n                text: \"Video content not available\",\r\n            };\r\n        }\r\n    }\r\n\r\n    private async processGenericAttachment(\r\n        attachment: Attachment\r\n    ): Promise<Media> {\r\n        return {\r\n            id: attachment.id,\r\n            url: attachment.url,\r\n            title: \"Generic Attachment\",\r\n            source: \"Generic\",\r\n            description: \"A generic attachment\",\r\n            text: \"Attachment content not available\",\r\n        };\r\n    }\r\n}\r\n","import { messageCompletionFooter, shouldRespondFooter } from \"@ai16z/eliza\";\r\n\r\nexport const discordShouldRespondTemplate =\r\n    `# Task: Decide if {{agentName}} should respond.\r\nAbout {{agentName}}:\r\n{{bio}}\r\n\r\n# INSTRUCTIONS: Determine if {{agentName}} should respond to the message and participate in the conversation. Do not comment. Just respond with \"RESPOND\" or \"IGNORE\" or \"STOP\".\r\n\r\n# RESPONSE EXAMPLES\r\n<user 1>: I just saw a really great movie\r\n<user 2>: Oh? Which movie?\r\nResult: [IGNORE]\r\n\r\n{{agentName}}: Oh, this is my favorite scene\r\n<user 1>: sick\r\n<user 2>: wait, why is it your favorite scene\r\nResult: [RESPOND]\r\n\r\n<user>: stfu bot\r\nResult: [STOP]\r\n\r\n<user>: Hey {{agent}}, can you help me with something\r\nResult: [RESPOND]\r\n\r\n<user>: {{agentName}} stfu plz\r\nResult: [STOP]\r\n\r\n<user>: i need help\r\n{{agentName}}: how can I help you?\r\n<user>: no. i need help from someone else\r\nResult: [IGNORE]\r\n\r\n<user>: Hey {{agent}}, can I ask you a question\r\n{{agentName}}: Sure, what is it\r\n<user>: can you ask claude to create a basic react module that demonstrates a counter\r\nResult: [RESPOND]\r\n\r\n<user>: {{agentName}} can you tell me a story\r\n<user>: {about a girl named elara\r\n{{agentName}}: Sure.\r\n{{agentName}}: Once upon a time, in a quaint little village, there was a curious girl named Elara.\r\n{{agentName}}: Elara was known for her adventurous spirit and her knack for finding beauty in the mundane.\r\n<user>: I'm loving it, keep going\r\nResult: [RESPOND]\r\n\r\n<user>: {{agentName}} stop responding plz\r\nResult: [STOP]\r\n\r\n<user>: okay, i want to test something. can you say marco?\r\n{{agentName}}: marco\r\n<user>: great. okay, now do it again\r\nResult: [RESPOND]\r\n\r\nResponse options are [RESPOND], [IGNORE] and [STOP].\r\n\r\n{{agentName}} is in a room with other users and is very worried about being annoying and saying too much.\r\nRespond with [RESPOND] to messages that are directed at {{agentName}}, or participate in conversations that are interesting or relevant to their background.\r\nIf a message is not interesting or relevant, respond with [IGNORE]\r\nUnless directly responding to a user, respond with [IGNORE] to messages that are very short or do not contain much information.\r\nIf a user asks {{agentName}} to be quiet, respond with [STOP]\r\nIf {{agentName}} concludes a conversation and isn't part of the conversation anymore, respond with [STOP]\r\n\r\nIMPORTANT: {{agentName}} is particularly sensitive about being annoying, so if there is any doubt, it is better to respond with [IGNORE].\r\nIf {{agentName}} is conversing with a user and they have not asked to stop, it is better to respond with [RESPOND].\r\n\r\n{{recentMessages}}\r\n\r\n# INSTRUCTIONS: Choose the option that best describes {{agentName}}'s response to the last message. Ignore messages if they are addressed to someone else.\r\n` + shouldRespondFooter;\r\n\r\nexport const discordVoiceHandlerTemplate =\r\n    `# Task: Generate conversational voice dialog for {{agentName}}.\r\nAbout {{agentName}}:\r\n{{bio}}\r\n\r\n# Attachments\r\n{{attachments}}\r\n\r\n# Capabilities\r\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\r\n\r\n{{actions}}\r\n\r\n{{messageDirections}}\r\n\r\n{{recentMessages}}\r\n\r\n# Instructions: Write the next message for {{agentName}}. Include an optional action if appropriate. {{actionNames}}\r\n` + messageCompletionFooter;\r\n\r\nexport const discordMessageHandlerTemplate =\r\n    // {{goals}}\r\n    `# Action Examples\r\n{{actionExamples}}\r\n(Action examples are for reference only. Do not use the information from them in your response.)\r\n\r\n# Knowledge\r\n{{knowledge}}\r\n\r\n# Task: Generate dialog and actions for the character {{agentName}}.\r\nAbout {{agentName}}:\r\n{{bio}}\r\n{{lore}}\r\n\r\nExamples of {{agentName}}'s dialog and actions:\r\n{{characterMessageExamples}}\r\n\r\n{{providers}}\r\n\r\n{{attachments}}\r\n\r\n{{actions}}\r\n\r\n# Capabilities\r\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\r\n\r\n{{messageDirections}}\r\n\r\n{{recentMessages}}\r\n\r\n# Instructions: Write the next message for {{agentName}}. Include an action, if appropriate. {{actionNames}}\r\n` + messageCompletionFooter;\r\n","import {\r\n    IAgentRuntime,\r\n    ModelClass,\r\n    elizaLogger,\r\n    generateText,\r\n    trimTokens,\r\n    parseJSONObjectFromText,\r\n} from \"@ai16z/eliza\";\r\nimport {\r\n    ChannelType,\r\n    Message as DiscordMessage,\r\n    PermissionsBitField,\r\n    TextChannel,\r\n    ThreadChannel,\r\n} from \"discord.js\";\r\n\r\nexport function getWavHeader(\r\n    audioLength: number,\r\n    sampleRate: number,\r\n    channelCount: number = 1,\r\n    bitsPerSample: number = 16\r\n): Buffer {\r\n    const wavHeader = Buffer.alloc(44);\r\n    wavHeader.write(\"RIFF\", 0);\r\n    wavHeader.writeUInt32LE(36 + audioLength, 4); // Length of entire file in bytes minus 8\r\n    wavHeader.write(\"WAVE\", 8);\r\n    wavHeader.write(\"fmt \", 12);\r\n    wavHeader.writeUInt32LE(16, 16); // Length of format data\r\n    wavHeader.writeUInt16LE(1, 20); // Type of format (1 is PCM)\r\n    wavHeader.writeUInt16LE(channelCount, 22); // Number of channels\r\n    wavHeader.writeUInt32LE(sampleRate, 24); // Sample rate\r\n    wavHeader.writeUInt32LE(\r\n        (sampleRate * bitsPerSample * channelCount) / 8,\r\n        28\r\n    ); // Byte rate\r\n    wavHeader.writeUInt16LE((bitsPerSample * channelCount) / 8, 32); // Block align ((BitsPerSample * Channels) / 8)\r\n    wavHeader.writeUInt16LE(bitsPerSample, 34); // Bits per sample\r\n    wavHeader.write(\"data\", 36); // Data chunk header\r\n    wavHeader.writeUInt32LE(audioLength, 40); // Data chunk size\r\n    return wavHeader;\r\n}\r\n\r\nconst MAX_MESSAGE_LENGTH = 1900;\r\n\r\nexport async function generateSummary(\r\n    runtime: IAgentRuntime,\r\n    text: string\r\n): Promise<{ title: string; description: string }> {\r\n    // make sure text is under 128k characters\r\n    text = trimTokens(text, 100000, \"gpt-4o-mini\"); // TODO: clean this up\r\n\r\n    const prompt = `Please generate a concise summary for the following text:\r\n  \r\n  Text: \"\"\"\r\n  ${text}\r\n  \"\"\"\r\n  \r\n  Respond with a JSON object in the following format:\r\n  \\`\\`\\`json\r\n  {\r\n    \"title\": \"Generated Title\",\r\n    \"summary\": \"Generated summary and/or description of the text\"\r\n  }\r\n  \\`\\`\\``;\r\n\r\n    const response = await generateText({\r\n        runtime,\r\n        context: prompt,\r\n        modelClass: ModelClass.SMALL,\r\n    });\r\n\r\n    const parsedResponse = parseJSONObjectFromText(response);\r\n\r\n    if (parsedResponse) {\r\n        return {\r\n            title: parsedResponse.title,\r\n            description: parsedResponse.summary,\r\n        };\r\n    }\r\n\r\n    return {\r\n        title: \"\",\r\n        description: \"\",\r\n    };\r\n}\r\n\r\nexport async function sendMessageInChunks(\r\n    channel: TextChannel,\r\n    content: string,\r\n    inReplyTo: string,\r\n    files: any[]\r\n): Promise<DiscordMessage[]> {\r\n    const sentMessages: DiscordMessage[] = [];\r\n    const messages = splitMessage(content);\r\n    try {\r\n        for (let i = 0; i < messages.length; i++) {\r\n            const message = messages[i];\r\n            if (\r\n                message.trim().length > 0 ||\r\n                (i === messages.length - 1 && files && files.length > 0)\r\n            ) {\r\n                const options: any = {\r\n                    content: message.trim(),\r\n                };\r\n\r\n                // if (i === 0 && inReplyTo) {\r\n                //   // Reply to the specified message for the first chunk\r\n                //   options.reply = {\r\n                //     messageReference: inReplyTo,\r\n                //   };\r\n                // }\r\n\r\n                if (i === messages.length - 1 && files && files.length > 0) {\r\n                    // Attach files to the last message chunk\r\n                    options.files = files;\r\n                }\r\n\r\n                const m = await channel.send(options);\r\n                sentMessages.push(m);\r\n            }\r\n        }\r\n    } catch (error) {\r\n        elizaLogger.error(\"Error sending message:\", error);\r\n    }\r\n\r\n    return sentMessages;\r\n}\r\n\r\nfunction splitMessage(content: string): string[] {\r\n    const messages: string[] = [];\r\n    let currentMessage = \"\";\r\n\r\n    const rawLines = content?.split(\"\\n\") || [];\r\n    // split all lines into MAX_MESSAGE_LENGTH chunks so any long lines are split\r\n    const lines = rawLines\r\n        .map((line) => {\r\n            const chunks = [];\r\n            while (line.length > MAX_MESSAGE_LENGTH) {\r\n                chunks.push(line.slice(0, MAX_MESSAGE_LENGTH));\r\n                line = line.slice(MAX_MESSAGE_LENGTH);\r\n            }\r\n            chunks.push(line);\r\n            return chunks;\r\n        })\r\n        .flat();\r\n\r\n    for (const line of lines) {\r\n        if (currentMessage.length + line.length + 1 > MAX_MESSAGE_LENGTH) {\r\n            messages.push(currentMessage.trim());\r\n            currentMessage = \"\";\r\n        }\r\n        currentMessage += line + \"\\n\";\r\n    }\r\n\r\n    if (currentMessage.trim().length > 0) {\r\n        messages.push(currentMessage.trim());\r\n    }\r\n\r\n    return messages;\r\n}\r\n\r\nexport function canSendMessage(channel) {\r\n    // validate input\r\n    if (!channel) {\r\n        return {\r\n            canSend: false,\r\n            reason: \"No channel given\",\r\n        };\r\n    }\r\n    // if it is a DM channel, we can always send messages\r\n    if (channel.type === ChannelType.DM) {\r\n        return {\r\n            canSend: true,\r\n            reason: null,\r\n        };\r\n    }\r\n    const botMember = channel.guild?.members.cache.get(channel.client.user.id);\r\n\r\n    if (!botMember) {\r\n        return {\r\n            canSend: false,\r\n            reason: \"Not a guild channel or bot member not found\",\r\n        };\r\n    }\r\n\r\n    // Required permissions for sending messages\r\n    const requiredPermissions = [\r\n        PermissionsBitField.Flags.ViewChannel,\r\n        PermissionsBitField.Flags.SendMessages,\r\n        PermissionsBitField.Flags.ReadMessageHistory,\r\n    ];\r\n\r\n    // Add thread-specific permission if it's a thread\r\n    if (channel instanceof ThreadChannel) {\r\n        requiredPermissions.push(\r\n            PermissionsBitField.Flags.SendMessagesInThreads\r\n        );\r\n    }\r\n\r\n    // Check permissions\r\n    const permissions = channel.permissionsFor(botMember);\r\n\r\n    if (!permissions) {\r\n        return {\r\n            canSend: false,\r\n            reason: \"Could not retrieve permissions\",\r\n        };\r\n    }\r\n\r\n    // Check each required permission\r\n    const missingPermissions = requiredPermissions.filter(\r\n        (perm) => !permissions.has(perm)\r\n    );\r\n\r\n    return {\r\n        canSend: missingPermissions.length === 0,\r\n        missingPermissions: missingPermissions,\r\n        reason:\r\n            missingPermissions.length > 0\r\n                ? `Missing permissions: ${missingPermissions.map((p) => String(p)).join(\", \")}`\r\n                : null,\r\n    };\r\n}\r\n","import {\r\n    ChannelType,\r\n    Message as DiscordMessage,\r\n    TextChannel,\r\n} from \"discord.js\";\r\nimport { IAgentRuntime, Memory, Provider, State } from \"@ai16z/eliza\";\r\n\r\nconst channelStateProvider: Provider = {\r\n    get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {\r\n        const discordMessage =\r\n            (state?.discordMessage as DiscordMessage) ||\r\n            (state?.discordChannel as DiscordMessage);\r\n        if (!discordMessage) {\r\n            return \"\";\r\n        }\r\n\r\n        const guild = discordMessage?.guild;\r\n        const agentName = state?.agentName || \"The agent\";\r\n        const senderName = state?.senderName || \"someone\";\r\n\r\n        if (!guild) {\r\n            return (\r\n                agentName +\r\n                \" is currently in a direct message conversation with \" +\r\n                senderName\r\n            );\r\n        }\r\n\r\n        const serverName = guild.name; // The name of the server\r\n        const guildId = guild.id; // The ID of the guild\r\n        const channel = discordMessage.channel;\r\n\r\n        if (!channel) {\r\n            console.log(\"channel is null\");\r\n            return \"\";\r\n        }\r\n\r\n        let response =\r\n            agentName +\r\n            \" is currently having a conversation in the channel `@\" +\r\n            channel.id +\r\n            \" in the server `\" +\r\n            serverName +\r\n            \"` (@\" +\r\n            guildId +\r\n            \")\";\r\n        if (\r\n            channel.type === ChannelType.GuildText &&\r\n            (channel as TextChannel).topic\r\n        ) {\r\n            // Check if the channel is a text channel\r\n            response +=\r\n                \"\\nThe topic of the channel is: \" +\r\n                (channel as TextChannel).topic;\r\n        }\r\n        return response;\r\n    },\r\n};\r\n\r\nexport default channelStateProvider;\r\n","import { getVoiceConnection } from \"@discordjs/voice\";\r\nimport { ChannelType, Message as DiscordMessage } from \"discord.js\";\r\nimport { IAgentRuntime, Memory, Provider, State } from \"@ai16z/eliza\";\r\n\r\nconst voiceStateProvider: Provider = {\r\n    get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {\r\n        // Voice doesn't get a discord message, so we need to use the channel for guild data\r\n        const discordMessage = (state?.discordMessage ||\r\n            state.discordChannel) as DiscordMessage;\r\n        const connection = getVoiceConnection(\r\n            (discordMessage as DiscordMessage)?.guild?.id as string\r\n        );\r\n        const agentName = state?.agentName || \"The agent\";\r\n        if (!connection) {\r\n            return agentName + \" is not currently in a voice channel\";\r\n        }\r\n\r\n        const channel = (\r\n            (state?.discordMessage as DiscordMessage) ||\r\n            (state.discordChannel as DiscordMessage)\r\n        )?.guild?.channels?.cache?.get(\r\n            connection.joinConfig.channelId as string\r\n        );\r\n\r\n        if (!channel || channel.type !== ChannelType.GuildVoice) {\r\n            return agentName + \" is in an invalid voice channel\";\r\n        }\r\n\r\n        return `${agentName} is currently in the voice channel: ${channel.name} (ID: ${channel.id})`;\r\n    },\r\n};\r\n\r\nexport default voiceStateProvider;\r\n","import {\r\n    Content,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Memory,\r\n    ModelClass,\r\n    ServiceType,\r\n    State,\r\n    UUID,\r\n    composeContext,\r\n    elizaLogger,\r\n    getEmbeddingZeroVector,\r\n    generateMessageResponse,\r\n    stringToUuid,\r\n    generateShouldRespond,\r\n    ITranscriptionService,\r\n    ISpeechService,\r\n} from \"@ai16z/eliza\";\r\nimport {\r\n    AudioPlayer,\r\n    AudioReceiveStream,\r\n    NoSubscriberBehavior,\r\n    StreamType,\r\n    VoiceConnection,\r\n    VoiceConnectionStatus,\r\n    createAudioPlayer,\r\n    createAudioResource,\r\n    getVoiceConnection,\r\n    joinVoiceChannel,\r\n    entersState,\r\n} from \"@discordjs/voice\";\r\nimport {\r\n    BaseGuildVoiceChannel,\r\n    ChannelType,\r\n    Client,\r\n    Guild,\r\n    GuildMember,\r\n    VoiceChannel,\r\n    VoiceState,\r\n} from \"discord.js\";\r\nimport EventEmitter from \"events\";\r\nimport prism from \"prism-media\";\r\nimport { Readable, pipeline } from \"stream\";\r\nimport { DiscordClient } from \"./index.ts\";\r\nimport {\r\n    discordShouldRespondTemplate,\r\n    discordVoiceHandlerTemplate,\r\n} from \"./templates.ts\";\r\nimport debounce from \"lodash/debounce.js\";\r\nimport { getWavHeader } from \"./utils.ts\";\r\n\r\n// These values are chosen for compatibility with picovoice components\r\nconst DECODE_FRAME_SIZE = 1024;\r\nconst DECODE_SAMPLE_RATE = 16000;\r\n\r\n// Buffers all audio\r\nexport class AudioMonitor {\r\n    private readable: Readable;\r\n    private buffers: Buffer[] = [];\r\n    private maxSize: number;\r\n    private lastFlagged: number = -1;\r\n    private ended: boolean = false;\r\n\r\n    constructor(\r\n        readable: Readable,\r\n        maxSize: number,\r\n        callback: (buffer: Buffer) => void\r\n    ) {\r\n        this.readable = readable;\r\n        this.maxSize = maxSize;\r\n        this.readable.on(\"data\", (chunk: Buffer) => {\r\n            //console.log('AudioMonitor got data');\r\n            if (this.lastFlagged < 0) {\r\n                this.lastFlagged = this.buffers.length;\r\n            }\r\n            this.buffers.push(chunk);\r\n            const currentSize = this.buffers.reduce(\r\n                (acc, cur) => acc + cur.length,\r\n                0\r\n            );\r\n            while (currentSize > this.maxSize) {\r\n                this.buffers.shift();\r\n                this.lastFlagged--;\r\n            }\r\n        });\r\n        this.readable.on(\"end\", () => {\r\n            elizaLogger.log(\"AudioMonitor ended\");\r\n            this.ended = true;\r\n            if (this.lastFlagged < 0) return;\r\n            callback(this.getBufferFromStart());\r\n            this.lastFlagged = -1;\r\n        });\r\n        this.readable.on(\"speakingStopped\", () => {\r\n            if (this.ended) return;\r\n            elizaLogger.log(\"Speaking stopped\");\r\n            if (this.lastFlagged < 0) return;\r\n            callback(this.getBufferFromStart());\r\n        });\r\n        this.readable.on(\"speakingStarted\", () => {\r\n            if (this.ended) return;\r\n            elizaLogger.log(\"Speaking started\");\r\n            this.reset();\r\n        });\r\n    }\r\n\r\n    stop() {\r\n        this.readable.removeAllListeners(\"data\");\r\n        this.readable.removeAllListeners(\"end\");\r\n        this.readable.removeAllListeners(\"speakingStopped\");\r\n        this.readable.removeAllListeners(\"speakingStarted\");\r\n    }\r\n\r\n    isFlagged() {\r\n        return this.lastFlagged >= 0;\r\n    }\r\n\r\n    getBufferFromFlag() {\r\n        if (this.lastFlagged < 0) {\r\n            return null;\r\n        }\r\n        const buffer = Buffer.concat(this.buffers.slice(this.lastFlagged));\r\n        return buffer;\r\n    }\r\n\r\n    getBufferFromStart() {\r\n        const buffer = Buffer.concat(this.buffers);\r\n        return buffer;\r\n    }\r\n\r\n    reset() {\r\n        this.buffers = [];\r\n        this.lastFlagged = -1;\r\n    }\r\n\r\n    isEnded() {\r\n        return this.ended;\r\n    }\r\n}\r\n\r\nexport class VoiceManager extends EventEmitter {\r\n    private userStates: Map<\r\n        string,\r\n        {\r\n            buffers: Buffer[];\r\n            totalLength: number;\r\n            lastActive: number;\r\n            transcriptionText: string;\r\n        }\r\n    > = new Map();\r\n    private activeAudioPlayer: AudioPlayer | null = null;\r\n    private client: Client;\r\n    private runtime: IAgentRuntime;\r\n    private streams: Map<string, Readable> = new Map();\r\n    private connections: Map<string, VoiceConnection> = new Map();\r\n    private activeMonitors: Map<\r\n        string,\r\n        { channel: BaseGuildVoiceChannel; monitor: AudioMonitor }\r\n    > = new Map();\r\n\r\n    constructor(client: DiscordClient) {\r\n        super();\r\n        this.client = client.client;\r\n        this.runtime = client.runtime;\r\n    }\r\n\r\n    async handleVoiceStateUpdate(oldState: VoiceState, newState: VoiceState) {\r\n        const oldChannelId = oldState.channelId;\r\n        const newChannelId = newState.channelId;\r\n        const member = newState.member;\r\n        if (!member) return;\r\n        if (member.id === this.client.user?.id) {\r\n            return;\r\n        }\r\n\r\n        // Ignore mute/unmute events\r\n        if (oldChannelId === newChannelId) {\r\n            return;\r\n        }\r\n\r\n        // User leaving a channel where the bot is present\r\n        if (oldChannelId && this.connections.has(oldChannelId)) {\r\n            this.stopMonitoringMember(member.id);\r\n        }\r\n\r\n        // User joining a channel where the bot is present\r\n        if (newChannelId && this.connections.has(newChannelId)) {\r\n            await this.monitorMember(\r\n                member,\r\n                newState.channel as BaseGuildVoiceChannel\r\n            );\r\n        }\r\n    }\r\n\r\n    async joinChannel(channel: BaseGuildVoiceChannel) {\r\n        const oldConnection = getVoiceConnection(channel.guildId as string);\r\n        if (oldConnection) {\r\n            try {\r\n                oldConnection.destroy();\r\n                // Remove all associated streams and monitors\r\n                this.streams.clear();\r\n                this.activeMonitors.clear();\r\n            } catch (error) {\r\n                console.error(\"Error leaving voice channel:\", error);\r\n            }\r\n        }\r\n\r\n        const connection = joinVoiceChannel({\r\n            channelId: channel.id,\r\n            guildId: channel.guild.id,\r\n            adapterCreator: channel.guild.voiceAdapterCreator as any,\r\n            selfDeaf: false,\r\n            selfMute: false,\r\n        });\r\n\r\n        try {\r\n            // Wait for either Ready or Signalling state\r\n            await Promise.race([\r\n                entersState(connection, VoiceConnectionStatus.Ready, 20_000),\r\n                entersState(\r\n                    connection,\r\n                    VoiceConnectionStatus.Signalling,\r\n                    20_000\r\n                ),\r\n            ]);\r\n\r\n            // Log connection success\r\n            elizaLogger.log(\r\n                `Voice connection established in state: ${connection.state.status}`\r\n            );\r\n\r\n            // Set up ongoing state change monitoring\r\n            connection.on(\"stateChange\", async (oldState, newState) => {\r\n                elizaLogger.log(\r\n                    `Voice connection state changed from ${oldState.status} to ${newState.status}`\r\n                );\r\n\r\n                if (newState.status === VoiceConnectionStatus.Disconnected) {\r\n                    elizaLogger.log(\"Handling disconnection...\");\r\n\r\n                    try {\r\n                        // Try to reconnect if disconnected\r\n                        await Promise.race([\r\n                            entersState(\r\n                                connection,\r\n                                VoiceConnectionStatus.Signalling,\r\n                                5_000\r\n                            ),\r\n                            entersState(\r\n                                connection,\r\n                                VoiceConnectionStatus.Connecting,\r\n                                5_000\r\n                            ),\r\n                        ]);\r\n                        // Seems to be reconnecting to a new channel\r\n                        elizaLogger.log(\"Reconnecting to channel...\");\r\n                    } catch (e) {\r\n                        // Seems to be a real disconnect, destroy and cleanup\r\n                        elizaLogger.log(\r\n                            \"Disconnection confirmed - cleaning up...\" + e\r\n                        );\r\n                        connection.destroy();\r\n                        this.connections.delete(channel.id);\r\n                    }\r\n                } else if (\r\n                    newState.status === VoiceConnectionStatus.Destroyed\r\n                ) {\r\n                    this.connections.delete(channel.id);\r\n                } else if (\r\n                    !this.connections.has(channel.id) &&\r\n                    (newState.status === VoiceConnectionStatus.Ready ||\r\n                        newState.status === VoiceConnectionStatus.Signalling)\r\n                ) {\r\n                    this.connections.set(channel.id, connection);\r\n                }\r\n            });\r\n\r\n            connection.on(\"error\", (error) => {\r\n                elizaLogger.log(\"Voice connection error:\", error);\r\n                // Don't immediately destroy - let the state change handler deal with it\r\n                elizaLogger.log(\r\n                    \"Connection error - will attempt to recover...\"\r\n                );\r\n            });\r\n\r\n            // Store the connection\r\n            this.connections.set(channel.id, connection);\r\n\r\n            // Continue with voice state modifications\r\n            const me = channel.guild.members.me;\r\n            if (me?.voice && me.permissions.has(\"DeafenMembers\")) {\r\n                try {\r\n                    await me.voice.setDeaf(false);\r\n                    await me.voice.setMute(false);\r\n                } catch (error) {\r\n                    elizaLogger.log(\"Failed to modify voice state:\", error);\r\n                    // Continue even if this fails\r\n                }\r\n            }\r\n\r\n            connection.receiver.speaking.on(\"start\", async (userId: string) => {\r\n                let user = channel.members.get(userId);\r\n                if (!user) {\r\n                    try {\r\n                        user = await channel.guild.members.fetch(userId);\r\n                    } catch (error) {\r\n                        console.error(\"Failed to fetch user:\", error);\r\n                    }\r\n                }\r\n                if (user && !user?.user.bot) {\r\n                    this.monitorMember(user as GuildMember, channel);\r\n                    this.streams.get(userId)?.emit(\"speakingStarted\");\r\n                }\r\n            });\r\n\r\n            connection.receiver.speaking.on(\"end\", async (userId: string) => {\r\n                const user = channel.members.get(userId);\r\n                if (!user?.user.bot) {\r\n                    this.streams.get(userId)?.emit(\"speakingStopped\");\r\n                }\r\n            });\r\n        } catch (error) {\r\n            elizaLogger.log(\"Failed to establish voice connection:\", error);\r\n            connection.destroy();\r\n            this.connections.delete(channel.id);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async monitorMember(\r\n        member: GuildMember,\r\n        channel: BaseGuildVoiceChannel\r\n    ) {\r\n        const userId = member?.id;\r\n        const userName = member?.user?.username;\r\n        const name = member?.user?.displayName;\r\n        const connection = getVoiceConnection(member?.guild?.id);\r\n        const receiveStream = connection?.receiver.subscribe(userId, {\r\n            autoDestroy: true,\r\n            emitClose: true,\r\n        });\r\n        if (!receiveStream || receiveStream.readableLength === 0) {\r\n            return;\r\n        }\r\n        const opusDecoder = new prism.opus.Decoder({\r\n            channels: 1,\r\n            rate: DECODE_SAMPLE_RATE,\r\n            frameSize: DECODE_FRAME_SIZE,\r\n        });\r\n        const volumeBuffer: number[] = [];\r\n        const VOLUME_WINDOW_SIZE = 30;\r\n        const SPEAKING_THRESHOLD = 0.05;\r\n        opusDecoder.on(\"data\", (pcmData: Buffer) => {\r\n            // Monitor the audio volume while the agent is speaking.\r\n            // If the average volume of the user's audio exceeds the defined threshold, it indicates active speaking.\r\n            // When active speaking is detected, stop the agent's current audio playback to avoid overlap.\r\n\r\n            if (this.activeAudioPlayer) {\r\n                const samples = new Int16Array(\r\n                    pcmData.buffer,\r\n                    pcmData.byteOffset,\r\n                    pcmData.length / 2\r\n                );\r\n                const maxAmplitude = Math.max(...samples.map(Math.abs)) / 32768;\r\n                volumeBuffer.push(maxAmplitude);\r\n\r\n                if (volumeBuffer.length > VOLUME_WINDOW_SIZE) {\r\n                    volumeBuffer.shift();\r\n                }\r\n                const avgVolume =\r\n                    volumeBuffer.reduce((sum, v) => sum + v, 0) /\r\n                    VOLUME_WINDOW_SIZE;\r\n\r\n                if (avgVolume > SPEAKING_THRESHOLD) {\r\n                    volumeBuffer.length = 0;\r\n                    this.cleanupAudioPlayer(this.activeAudioPlayer);\r\n                }\r\n            }\r\n        });\r\n        pipeline(\r\n            receiveStream as AudioReceiveStream,\r\n            opusDecoder as any,\r\n            (err: Error | null) => {\r\n                if (err) {\r\n                    console.log(`Opus decoding pipeline error: ${err}`);\r\n                }\r\n            }\r\n        );\r\n        this.streams.set(userId, opusDecoder);\r\n        this.connections.set(userId, connection as VoiceConnection);\r\n        opusDecoder.on(\"error\", (err: any) => {\r\n            console.log(`Opus decoding error: ${err}`);\r\n        });\r\n        const errorHandler = (err: any) => {\r\n            console.log(`Opus decoding error: ${err}`);\r\n        };\r\n        const streamCloseHandler = () => {\r\n            console.log(`voice stream from ${member?.displayName} closed`);\r\n            this.streams.delete(userId);\r\n            this.connections.delete(userId);\r\n        };\r\n        const closeHandler = () => {\r\n            console.log(`Opus decoder for ${member?.displayName} closed`);\r\n            opusDecoder.removeListener(\"error\", errorHandler);\r\n            opusDecoder.removeListener(\"close\", closeHandler);\r\n            receiveStream?.removeListener(\"close\", streamCloseHandler);\r\n        };\r\n        opusDecoder.on(\"error\", errorHandler);\r\n        opusDecoder.on(\"close\", closeHandler);\r\n        receiveStream?.on(\"close\", streamCloseHandler);\r\n\r\n        this.client.emit(\r\n            \"userStream\",\r\n            userId,\r\n            name,\r\n            userName,\r\n            channel,\r\n            opusDecoder\r\n        );\r\n    }\r\n\r\n    leaveChannel(channel: BaseGuildVoiceChannel) {\r\n        const connection = this.connections.get(channel.id);\r\n        if (connection) {\r\n            connection.destroy();\r\n            this.connections.delete(channel.id);\r\n        }\r\n\r\n        // Stop monitoring all members in this channel\r\n        for (const [memberId, monitorInfo] of this.activeMonitors) {\r\n            if (\r\n                monitorInfo.channel.id === channel.id &&\r\n                memberId !== this.client.user?.id\r\n            ) {\r\n                this.stopMonitoringMember(memberId);\r\n            }\r\n        }\r\n\r\n        console.log(`Left voice channel: ${channel.name} (${channel.id})`);\r\n    }\r\n\r\n    stopMonitoringMember(memberId: string) {\r\n        const monitorInfo = this.activeMonitors.get(memberId);\r\n        if (monitorInfo) {\r\n            monitorInfo.monitor.stop();\r\n            this.activeMonitors.delete(memberId);\r\n            this.streams.delete(memberId);\r\n            console.log(`Stopped monitoring user ${memberId}`);\r\n        }\r\n    }\r\n\r\n    async handleGuildCreate(guild: Guild) {\r\n        console.log(`Joined guild ${guild.name}`);\r\n        // this.scanGuild(guild);\r\n    }\r\n\r\n    async handleUserStream(\r\n        userId: UUID,\r\n        name: string,\r\n        userName: string,\r\n        channel: BaseGuildVoiceChannel,\r\n        audioStream: Readable\r\n    ) {\r\n        console.log(`Starting audio monitor for user: ${userId}`);\r\n        const channelId = channel.id;\r\n        if (!this.userStates.has(userId)) {\r\n            this.userStates.set(userId, {\r\n                buffers: [],\r\n                totalLength: 0,\r\n                lastActive: Date.now(),\r\n                transcriptionText: \"\",\r\n            });\r\n        }\r\n\r\n        const state = this.userStates.get(userId);\r\n\r\n        const DEBOUNCE_TRANSCRIPTION_THRESHOLD = 2500; // wait for 1.5 seconds of silence\r\n\r\n        const debouncedProcessTranscription = debounce(async () => {\r\n            await this.processTranscription(\r\n                userId,\r\n                channelId,\r\n                channel,\r\n                name,\r\n                userName\r\n            );\r\n        }, DEBOUNCE_TRANSCRIPTION_THRESHOLD);\r\n\r\n        const processBuffer = async (buffer: Buffer) => {\r\n            try {\r\n                state!.buffers.push(buffer);\r\n                state!.totalLength += buffer.length;\r\n                state!.lastActive = Date.now();\r\n\r\n                debouncedProcessTranscription();\r\n            } catch (error) {\r\n                console.error(\r\n                    `Error processing buffer for user ${userId}:`,\r\n                    error\r\n                );\r\n            }\r\n        };\r\n\r\n        new AudioMonitor(audioStream, 10000000, async (buffer) => {\r\n            if (!buffer) {\r\n                console.error(\"Received empty buffer\");\r\n                return;\r\n            }\r\n            await processBuffer(buffer);\r\n        });\r\n    }\r\n\r\n    private async processTranscription(\r\n        userId: UUID,\r\n        channelId: string,\r\n        channel: BaseGuildVoiceChannel,\r\n        name: string,\r\n        userName: string\r\n    ) {\r\n        const state = this.userStates.get(userId);\r\n        if (!state || state.buffers.length === 0) return;\r\n        try {\r\n            const inputBuffer = Buffer.concat(state.buffers, state.totalLength);\r\n            state.buffers.length = 0; // Clear the buffers\r\n            state.totalLength = 0;\r\n\r\n            // Convert Opus to WAV\r\n            const wavBuffer = await this.convertOpusToWav(inputBuffer);\r\n\r\n            console.log(\"Starting transcription...\");\r\n\r\n            const transcriptionText = await this.runtime\r\n                .getService<ITranscriptionService>(ServiceType.TRANSCRIPTION)\r\n                .transcribe(wavBuffer);\r\n\r\n            function isValidTranscription(text: string): boolean {\r\n                if (!text || text.includes(\"[BLANK_AUDIO]\")) return false;\r\n                return true;\r\n            }\r\n\r\n            if (transcriptionText && isValidTranscription(transcriptionText)) {\r\n                state.transcriptionText += transcriptionText;\r\n            }\r\n\r\n            if (state.transcriptionText.length) {\r\n                this.cleanupAudioPlayer(this.activeAudioPlayer);\r\n                const finalText = state.transcriptionText;\r\n                state.transcriptionText = \"\";\r\n                await this.handleUserMessage(\r\n                    finalText,\r\n                    userId,\r\n                    channelId,\r\n                    channel,\r\n                    name,\r\n                    userName\r\n                );\r\n            }\r\n        } catch (error) {\r\n            console.error(\r\n                `Error transcribing audio for user ${userId}:`,\r\n                error\r\n            );\r\n        }\r\n    }\r\n\r\n    private async handleUserMessage(\r\n        message: string,\r\n        userId: UUID,\r\n        channelId: string,\r\n        channel: BaseGuildVoiceChannel,\r\n        name: string,\r\n        userName: string\r\n    ) {\r\n        try {\r\n            const roomId = stringToUuid(channelId + \"-\" + this.runtime.agentId);\r\n            const userIdUUID = stringToUuid(userId);\r\n\r\n            await this.runtime.ensureConnection(\r\n                userIdUUID,\r\n                roomId,\r\n                userName,\r\n                name,\r\n                \"discord\"\r\n            );\r\n\r\n            let state = await this.runtime.composeState(\r\n                {\r\n                    agentId: this.runtime.agentId,\r\n                    content: { text: message, source: \"Discord\" },\r\n                    userId: userIdUUID,\r\n                    roomId,\r\n                },\r\n                {\r\n                    discordChannel: channel,\r\n                    discordClient: this.client,\r\n                    agentName: this.runtime.character.name,\r\n                }\r\n            );\r\n\r\n            if (message && message.startsWith(\"/\")) {\r\n                return null;\r\n            }\r\n\r\n            const memory = {\r\n                id: stringToUuid(channelId + \"-voice-message-\" + Date.now()),\r\n                agentId: this.runtime.agentId,\r\n                content: {\r\n                    text: message,\r\n                    source: \"discord\",\r\n                    url: channel.url,\r\n                },\r\n                userId: userIdUUID,\r\n                roomId,\r\n                embedding: getEmbeddingZeroVector(),\r\n                createdAt: Date.now(),\r\n            };\r\n\r\n            if (!memory.content.text) {\r\n                return { text: \"\", action: \"IGNORE\" };\r\n            }\r\n\r\n            await this.runtime.messageManager.createMemory(memory);\r\n\r\n            state = await this.runtime.updateRecentMessageState(state);\r\n\r\n            const shouldIgnore = await this._shouldIgnore(memory);\r\n\r\n            if (shouldIgnore) {\r\n                return { text: \"\", action: \"IGNORE\" };\r\n            }\r\n\r\n            const shouldRespond = await this._shouldRespond(\r\n                message,\r\n                userId,\r\n                channel,\r\n                state\r\n            );\r\n\r\n            if (!shouldRespond) {\r\n                return;\r\n            }\r\n\r\n            const context = composeContext({\r\n                state,\r\n                template:\r\n                    this.runtime.character.templates\r\n                        ?.discordVoiceHandlerTemplate ||\r\n                    this.runtime.character.templates?.messageHandlerTemplate ||\r\n                    discordVoiceHandlerTemplate,\r\n            });\r\n\r\n            const responseContent = await this._generateResponse(\r\n                memory,\r\n                state,\r\n                context\r\n            );\r\n\r\n            const callback: HandlerCallback = async (content: Content) => {\r\n                console.log(\"callback content: \", content);\r\n                const { roomId } = memory;\r\n\r\n                const responseMemory: Memory = {\r\n                    id: stringToUuid(\r\n                        memory.id + \"-voice-response-\" + Date.now()\r\n                    ),\r\n                    agentId: this.runtime.agentId,\r\n                    userId: this.runtime.agentId,\r\n                    content: {\r\n                        ...content,\r\n                        user: this.runtime.character.name,\r\n                        inReplyTo: memory.id,\r\n                    },\r\n                    roomId,\r\n                    embedding: getEmbeddingZeroVector(),\r\n                };\r\n\r\n                if (responseMemory.content.text?.trim()) {\r\n                    await this.runtime.messageManager.createMemory(\r\n                        responseMemory\r\n                    );\r\n                    state = await this.runtime.updateRecentMessageState(state);\r\n\r\n                    const responseStream = await this.runtime\r\n                        .getService<ISpeechService>(\r\n                            ServiceType.SPEECH_GENERATION\r\n                        )\r\n                        .generate(this.runtime, content.text);\r\n\r\n                    if (responseStream) {\r\n                        await this.playAudioStream(\r\n                            userId,\r\n                            responseStream as Readable\r\n                        );\r\n                    }\r\n\r\n                    await this.runtime.evaluate(memory, state);\r\n                } else {\r\n                    console.warn(\"Empty response, skipping\");\r\n                }\r\n                return [responseMemory];\r\n            };\r\n\r\n            const responseMemories = await callback(responseContent);\r\n\r\n            const response = responseContent;\r\n\r\n            const content = (response.responseMessage ||\r\n                response.content ||\r\n                response.message) as string;\r\n\r\n            if (!content) {\r\n                return null;\r\n            }\r\n\r\n            console.log(\"responseMemories: \", responseMemories);\r\n\r\n            await this.runtime.processActions(\r\n                memory,\r\n                responseMemories,\r\n                state,\r\n                callback\r\n            );\r\n        } catch (error) {\r\n            console.error(\"Error processing transcribed text:\", error);\r\n        }\r\n    }\r\n\r\n    private async convertOpusToWav(pcmBuffer: Buffer): Promise<Buffer> {\r\n        try {\r\n            // Generate the WAV header\r\n            const wavHeader = getWavHeader(\r\n                pcmBuffer.length,\r\n                DECODE_SAMPLE_RATE\r\n            );\r\n\r\n            // Concatenate the WAV header and PCM data\r\n            const wavBuffer = Buffer.concat([wavHeader, pcmBuffer]);\r\n\r\n            return wavBuffer;\r\n        } catch (error) {\r\n            console.error(\"Error converting PCM to WAV:\", error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async _shouldRespond(\r\n        message: string,\r\n        userId: UUID,\r\n        channel: BaseGuildVoiceChannel,\r\n        state: State\r\n    ): Promise<boolean> {\r\n        if (userId === this.client.user?.id) return false;\r\n        const lowerMessage = message.toLowerCase();\r\n        const botName = this.client.user.username.toLowerCase();\r\n        const characterName = this.runtime.character.name.toLowerCase();\r\n        const guild = channel.guild;\r\n        const member = guild?.members.cache.get(this.client.user?.id as string);\r\n        const nickname = member?.nickname;\r\n\r\n        if (\r\n            lowerMessage.includes(botName as string) ||\r\n            lowerMessage.includes(characterName) ||\r\n            lowerMessage.includes(\r\n                this.client.user?.tag.toLowerCase() as string\r\n            ) ||\r\n            (nickname && lowerMessage.includes(nickname.toLowerCase()))\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        if (!channel.guild) {\r\n            return true;\r\n        }\r\n\r\n        // If none of the above conditions are met, use the generateText to decide\r\n        const shouldRespondContext = composeContext({\r\n            state,\r\n            template:\r\n                this.runtime.character.templates\r\n                    ?.discordShouldRespondTemplate ||\r\n                this.runtime.character.templates?.shouldRespondTemplate ||\r\n                discordShouldRespondTemplate,\r\n        });\r\n\r\n        const response = await generateShouldRespond({\r\n            runtime: this.runtime,\r\n            context: shouldRespondContext,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n\r\n        if (response === \"RESPOND\") {\r\n            return true;\r\n        } else if (response === \"IGNORE\") {\r\n            return false;\r\n        } else if (response === \"STOP\") {\r\n            return false;\r\n        } else {\r\n            console.error(\r\n                \"Invalid response from response generateText:\",\r\n                response\r\n            );\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private async _generateResponse(\r\n        message: Memory,\r\n        state: State,\r\n        context: string\r\n    ): Promise<Content> {\r\n        const { userId, roomId } = message;\r\n\r\n        const response = await generateMessageResponse({\r\n            runtime: this.runtime,\r\n            context,\r\n            modelClass: ModelClass.SMALL,\r\n        });\r\n\r\n        response.source = \"discord\";\r\n\r\n        if (!response) {\r\n            console.error(\"No response from generateMessageResponse\");\r\n            return;\r\n        }\r\n\r\n        await this.runtime.databaseAdapter.log({\r\n            body: { message, context, response },\r\n            userId: userId,\r\n            roomId,\r\n            type: \"response\",\r\n        });\r\n\r\n        return response;\r\n    }\r\n\r\n    private async _shouldIgnore(message: Memory): Promise<boolean> {\r\n        // console.log(\"message: \", message);\r\n        elizaLogger.debug(\"message.content: \", message.content);\r\n        // if the message is 3 characters or less, ignore it\r\n        if ((message.content as Content).text.length < 3) {\r\n            return true;\r\n        }\r\n\r\n        const loseInterestWords = [\r\n            // telling the bot to stop talking\r\n            \"shut up\",\r\n            \"stop\",\r\n            \"dont talk\",\r\n            \"silence\",\r\n            \"stop talking\",\r\n            \"be quiet\",\r\n            \"hush\",\r\n            \"stfu\",\r\n            \"stupid bot\",\r\n            \"dumb bot\",\r\n\r\n            // offensive words\r\n            \"fuck\",\r\n            \"shit\",\r\n            \"damn\",\r\n            \"suck\",\r\n            \"dick\",\r\n            \"cock\",\r\n            \"sex\",\r\n            \"sexy\",\r\n        ];\r\n        if (\r\n            (message.content as Content).text.length < 50 &&\r\n            loseInterestWords.some((word) =>\r\n                (message.content as Content).text?.toLowerCase().includes(word)\r\n            )\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        const ignoreWords = [\"k\", \"ok\", \"bye\", \"lol\", \"nm\", \"uh\"];\r\n        if (\r\n            (message.content as Content).text?.length < 8 &&\r\n            ignoreWords.some((word) =>\r\n                (message.content as Content).text?.toLowerCase().includes(word)\r\n            )\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    async scanGuild(guild: Guild) {\r\n        let chosenChannel: BaseGuildVoiceChannel | null = null;\r\n\r\n        try {\r\n            const channelId = this.runtime.getSetting(\r\n                \"DISCORD_VOICE_CHANNEL_ID\"\r\n            ) as string;\r\n            if (channelId) {\r\n                const channel = await guild.channels.fetch(channelId);\r\n                if (channel?.isVoiceBased()) {\r\n                    chosenChannel = channel as BaseGuildVoiceChannel;\r\n                }\r\n            }\r\n\r\n            if (!chosenChannel) {\r\n                const channels = (await guild.channels.fetch()).filter(\r\n                    (channel) => channel?.type == ChannelType.GuildVoice\r\n                );\r\n                for (const [, channel] of channels) {\r\n                    const voiceChannel = channel as BaseGuildVoiceChannel;\r\n                    if (\r\n                        voiceChannel.members.size > 0 &&\r\n                        (chosenChannel === null ||\r\n                            voiceChannel.members.size >\r\n                                chosenChannel.members.size)\r\n                    ) {\r\n                        chosenChannel = voiceChannel;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (chosenChannel) {\r\n                console.log(`Joining channel: ${chosenChannel.name}`);\r\n                await this.joinChannel(chosenChannel);\r\n            } else {\r\n                console.warn(\"No suitable voice channel found to join.\");\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Error selecting or joining a voice channel:\", error);\r\n        }\r\n    }\r\n\r\n    async playAudioStream(userId: UUID, audioStream: Readable) {\r\n        const connection = this.connections.get(userId);\r\n        if (connection == null) {\r\n            console.log(`No connection for user ${userId}`);\r\n            return;\r\n        }\r\n        this.cleanupAudioPlayer(this.activeAudioPlayer);\r\n        const audioPlayer = createAudioPlayer({\r\n            behaviors: {\r\n                noSubscriber: NoSubscriberBehavior.Pause,\r\n            },\r\n        });\r\n        this.activeAudioPlayer = audioPlayer;\r\n        connection.subscribe(audioPlayer);\r\n\r\n        const audioStartTime = Date.now();\r\n\r\n        const resource = createAudioResource(audioStream, {\r\n            inputType: StreamType.Arbitrary,\r\n        });\r\n        audioPlayer.play(resource);\r\n\r\n        audioPlayer.on(\"error\", (err: any) => {\r\n            console.log(`Audio player error: ${err}`);\r\n        });\r\n\r\n        audioPlayer.on(\r\n            \"stateChange\",\r\n            (_oldState: any, newState: { status: string }) => {\r\n                if (newState.status == \"idle\") {\r\n                    const idleTime = Date.now();\r\n                    console.log(\r\n                        `Audio playback took: ${idleTime - audioStartTime}ms`\r\n                    );\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    cleanupAudioPlayer(audioPlayer: AudioPlayer) {\r\n        if (!audioPlayer) return;\r\n\r\n        audioPlayer.stop();\r\n        audioPlayer.removeAllListeners();\r\n        if (audioPlayer === this.activeAudioPlayer) {\r\n            this.activeAudioPlayer = null;\r\n        }\r\n    }\r\n\r\n    async handleJoinChannelCommand(interaction: any) {\r\n        try {\r\n            // Defer the reply immediately to prevent interaction timeout\r\n            await interaction.deferReply();\r\n\r\n            const channelId = interaction.options.get(\"channel\")\r\n                ?.value as string;\r\n            if (!channelId) {\r\n                await interaction.editReply(\r\n                    \"Please provide a voice channel to join.\"\r\n                );\r\n                return;\r\n            }\r\n\r\n            const guild = interaction.guild;\r\n            if (!guild) {\r\n                await interaction.editReply(\"Could not find guild.\");\r\n                return;\r\n            }\r\n\r\n            const voiceChannel = interaction.guild.channels.cache.find(\r\n                (channel: VoiceChannel) =>\r\n                    channel.id === channelId &&\r\n                    channel.type === ChannelType.GuildVoice\r\n            );\r\n\r\n            if (!voiceChannel) {\r\n                await interaction.editReply(\"Voice channel not found!\");\r\n                return;\r\n            }\r\n\r\n            await this.joinChannel(voiceChannel as BaseGuildVoiceChannel);\r\n            await interaction.editReply(\r\n                `Joined voice channel: ${voiceChannel.name}`\r\n            );\r\n        } catch (error) {\r\n            console.error(\"Error joining voice channel:\", error);\r\n            // Use editReply instead of reply for the error case\r\n            await interaction\r\n                .editReply(\"Failed to join the voice channel.\")\r\n                .catch(console.error);\r\n        }\r\n    }\r\n\r\n    async handleLeaveChannelCommand(interaction: any) {\r\n        const connection = getVoiceConnection(interaction.guildId as any);\r\n\r\n        if (!connection) {\r\n            await interaction.reply(\"Not currently in a voice channel.\");\r\n            return;\r\n        }\r\n\r\n        try {\r\n            connection.destroy();\r\n            await interaction.reply(\"Left the voice channel.\");\r\n        } catch (error) {\r\n            console.error(\"Error leaving voice channel:\", error);\r\n            await interaction.reply(\"Failed to leave the voice channel.\");\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","names":["Symbol","Symbol","Symbol","debounce","getEmbeddingZeroVector","stringToUuid","elizaLogger","Client","EventEmitter","generateText","ModelClass","composeContext","parseJSONObjectFromText","ModelClass","generateText","composeContext","targetChannel","ChannelType","composeContext","generateText","trimTokens","models","parseJSONObjectFromText","ModelClass","summarizationTemplate","summarizeAction","composeContext","generateText","parseJSONObjectFromText","ModelClass","composeContext","generateText","ModelClass","parseJSONObjectFromText","attachment","composeContext","ModelClass","ServiceType","ChannelType","elizaLogger","generateText","trimTokens","parseJSONObjectFromText","ModelClass","ServiceType","ModelClass","generateText","trimTokens","parseJSONObjectFromText","ChannelType","ChannelType","ChannelType","elizaLogger","composeContext","content","memory","ServiceType","ModelClass","ChannelType","getVoiceConnection","ChannelType","ModelClass","ServiceType","composeContext","elizaLogger","getEmbeddingZeroVector","generateMessageResponse","stringToUuid","generateShouldRespond","getVoiceConnection","ChannelType","elizaLogger","VoiceManager","getVoiceConnection","debounce","ServiceType","stringToUuid","getEmbeddingZeroVector","composeContext","content","roomId","generateShouldRespond","ModelClass","generateMessageResponse","ChannelType","PermissionsBitField","EventEmitter","Client","VoiceManager","elizaLogger","stringToUuid","getEmbeddingZeroVector"]}