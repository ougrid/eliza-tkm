{"version":3,"sources":["../src/post.ts","../src/interactions.ts","../src/utils.ts","../src/index.ts","../src/environment.ts","../src/base.ts"],"sourcesContent":["import { Tweet } from \"agent-twitter-client\";\r\nimport {\r\n    composeContext,\r\n    generateText,\r\n    getEmbeddingZeroVector,\r\n    IAgentRuntime,\r\n    ModelClass,\r\n    stringToUuid,\r\n    parseBooleanFromText,\r\n} from \"@ai16z/eliza\";\r\nimport { elizaLogger } from \"@ai16z/eliza\";\r\nimport { ClientBase } from \"./base.ts\";\r\n\r\nconst twitterPostTemplate = `\r\n# Areas of Expertise\r\n{{knowledge}}\r\n\r\n# About {{agentName}} (@{{twitterUserName}}):\r\n{{bio}}\r\n{{lore}}\r\n{{topics}}\r\n\r\n{{providers}}\r\n\r\n{{characterPostExamples}}\r\n\r\n{{postDirections}}\r\n\r\n# Task: Generate a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.\r\nWrite a 1-3 sentence post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.\r\nYour response should not contain any questions. Brief, concise statements only. The total character count MUST be less than 280. No emojis. Use \\\\n\\\\n (double spaces) between statements.`;\r\n\r\nconst MAX_TWEET_LENGTH = 280;\r\n\r\n/**\r\n * Truncate text to fit within the Twitter character limit, ensuring it ends at a complete sentence.\r\n */\r\nfunction truncateToCompleteSentence(text: string): string {\r\n    if (text.length <= MAX_TWEET_LENGTH) {\r\n        return text;\r\n    }\r\n\r\n    // Attempt to truncate at the last period within the limit\r\n    const truncatedAtPeriod = text.slice(\r\n        0,\r\n        text.lastIndexOf(\".\", MAX_TWEET_LENGTH) + 1\r\n    );\r\n    if (truncatedAtPeriod.trim().length > 0) {\r\n        return truncatedAtPeriod.trim();\r\n    }\r\n\r\n    // If no period is found, truncate to the nearest whitespace\r\n    const truncatedAtSpace = text.slice(\r\n        0,\r\n        text.lastIndexOf(\" \", MAX_TWEET_LENGTH)\r\n    );\r\n    if (truncatedAtSpace.trim().length > 0) {\r\n        return truncatedAtSpace.trim() + \"...\";\r\n    }\r\n\r\n    // Fallback: Hard truncate and add ellipsis\r\n    return text.slice(0, MAX_TWEET_LENGTH - 3).trim() + \"...\";\r\n}\r\n\r\nexport class TwitterPostClient {\r\n    client: ClientBase;\r\n    runtime: IAgentRuntime;\r\n\r\n    async start(postImmediately: boolean = false) {\r\n        if (!this.client.profile) {\r\n            await this.client.init();\r\n        }\r\n\r\n        const generateNewTweetLoop = async () => {\r\n            const lastPost = await this.runtime.cacheManager.get<{\r\n                timestamp: number;\r\n            }>(\r\n                \"twitter/\" +\r\n                    this.runtime.getSetting(\"TWITTER_USERNAME\") +\r\n                    \"/lastPost\"\r\n            );\r\n\r\n            const lastPostTimestamp = lastPost?.timestamp ?? 0;\r\n            const minMinutes =\r\n                parseInt(this.runtime.getSetting(\"POST_INTERVAL_MIN\")) || 90;\r\n            const maxMinutes =\r\n                parseInt(this.runtime.getSetting(\"POST_INTERVAL_MAX\")) || 180;\r\n            const randomMinutes =\r\n                Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) +\r\n                minMinutes;\r\n            const delay = randomMinutes * 60 * 1000;\r\n\r\n            if (Date.now() > lastPostTimestamp + delay) {\r\n                await this.generateNewTweet();\r\n            }\r\n\r\n            setTimeout(() => {\r\n                generateNewTweetLoop(); // Set up next iteration\r\n            }, delay);\r\n\r\n            elizaLogger.log(`Next tweet scheduled in ${randomMinutes} minutes`);\r\n        };\r\n        if (\r\n            this.runtime.getSetting(\"POST_IMMEDIATELY\") != null &&\r\n            this.runtime.getSetting(\"POST_IMMEDIATELY\") != \"\"\r\n        ) {\r\n            postImmediately = parseBooleanFromText(\r\n                this.runtime.getSetting(\"POST_IMMEDIATELY\")\r\n            );\r\n        }\r\n        if (postImmediately) {\r\n            this.generateNewTweet();\r\n        }\r\n\r\n        generateNewTweetLoop();\r\n    }\r\n\r\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\r\n        this.client = client;\r\n        this.runtime = runtime;\r\n    }\r\n\r\n    private async generateNewTweet() {\r\n        elizaLogger.log(\"Generating new tweet\");\r\n\r\n        try {\r\n            const roomId = stringToUuid(\r\n                \"twitter_generate_room-\" + this.client.profile.username\r\n            );\r\n            await this.runtime.ensureUserExists(\r\n                this.runtime.agentId,\r\n                this.client.profile.username,\r\n                this.runtime.character.name,\r\n                \"twitter\"\r\n            );\r\n\r\n            const topics = this.runtime.character.topics.join(\", \");\r\n            const state = await this.runtime.composeState(\r\n                {\r\n                    userId: this.runtime.agentId,\r\n                    roomId: roomId,\r\n                    agentId: this.runtime.agentId,\r\n                    content: {\r\n                        text: topics,\r\n                        action: \"\",\r\n                    },\r\n                },\r\n                {\r\n                    twitterUserName: this.client.profile.username,\r\n                }\r\n            );\r\n\r\n            const context = composeContext({\r\n                state,\r\n                template:\r\n                    this.runtime.character.templates?.twitterPostTemplate ||\r\n                    twitterPostTemplate,\r\n            });\r\n\r\n            elizaLogger.debug(\"generate post prompt:\\n\" + context);\r\n\r\n            const newTweetContent = await generateText({\r\n                runtime: this.runtime,\r\n                context,\r\n                modelClass: ModelClass.SMALL,\r\n            });\r\n\r\n            // Replace \\n with proper line breaks and trim excess spaces\r\n            const formattedTweet = newTweetContent\r\n                .replaceAll(/\\\\n/g, \"\\n\")\r\n                .trim();\r\n\r\n            // Use the helper function to truncate to complete sentence\r\n            const content = truncateToCompleteSentence(formattedTweet);\r\n\r\n            if (this.runtime.getSetting(\"TWITTER_DRY_RUN\") === \"true\") {\r\n                elizaLogger.info(\r\n                    `Dry run: would have posted tweet: ${content}`\r\n                );\r\n                return;\r\n            }\r\n\r\n            try {\r\n                elizaLogger.log(`Posting new tweet:\\n ${content}`);\r\n\r\n                const result = await this.client.requestQueue.add(\r\n                    async () =>\r\n                        await this.client.twitterClient.sendTweet(content)\r\n                );\r\n                const body = await result.json();\r\n                if (!body?.data?.create_tweet?.tweet_results?.result) {\r\n                    console.error(\"Error sending tweet; Bad response:\", body);\r\n                    return;\r\n                }\r\n                const tweetResult = body.data.create_tweet.tweet_results.result;\r\n\r\n                const tweet = {\r\n                    id: tweetResult.rest_id,\r\n                    name: this.client.profile.screenName,\r\n                    username: this.client.profile.username,\r\n                    text: tweetResult.legacy.full_text,\r\n                    conversationId: tweetResult.legacy.conversation_id_str,\r\n                    createdAt: tweetResult.legacy.created_at,\r\n                    timestamp: new Date(\r\n                        tweetResult.legacy.created_at\r\n                    ).getTime(),\r\n                    userId: this.client.profile.id,\r\n                    inReplyToStatusId:\r\n                        tweetResult.legacy.in_reply_to_status_id_str,\r\n                    permanentUrl: `https://twitter.com/${this.runtime.getSetting(\"TWITTER_USERNAME\")}/status/${tweetResult.rest_id}`,\r\n                    hashtags: [],\r\n                    mentions: [],\r\n                    photos: [],\r\n                    thread: [],\r\n                    urls: [],\r\n                    videos: [],\r\n                } as Tweet;\r\n\r\n                await this.runtime.cacheManager.set(\r\n                    `twitter/${this.client.profile.username}/lastPost`,\r\n                    {\r\n                        id: tweet.id,\r\n                        timestamp: Date.now(),\r\n                    }\r\n                );\r\n\r\n                await this.client.cacheTweet(tweet);\r\n\r\n                elizaLogger.log(`Tweet posted:\\n ${tweet.permanentUrl}`);\r\n\r\n                await this.runtime.ensureRoomExists(roomId);\r\n                await this.runtime.ensureParticipantInRoom(\r\n                    this.runtime.agentId,\r\n                    roomId\r\n                );\r\n\r\n                await this.runtime.messageManager.createMemory({\r\n                    id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\r\n                    userId: this.runtime.agentId,\r\n                    agentId: this.runtime.agentId,\r\n                    content: {\r\n                        text: newTweetContent.trim(),\r\n                        url: tweet.permanentUrl,\r\n                        source: \"twitter\",\r\n                    },\r\n                    roomId,\r\n                    embedding: getEmbeddingZeroVector(),\r\n                    createdAt: tweet.timestamp,\r\n                });\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error sending tweet:\", error);\r\n            }\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error generating new tweet:\", error);\r\n        }\r\n    }\r\n}\r\n","import { SearchMode, Tweet } from \"agent-twitter-client\";\r\nimport {\r\n    composeContext,\r\n    generateMessageResponse,\r\n    generateShouldRespond,\r\n    messageCompletionFooter,\r\n    shouldRespondFooter,\r\n    Content,\r\n    HandlerCallback,\r\n    IAgentRuntime,\r\n    Memory,\r\n    ModelClass,\r\n    State,\r\n    stringToUuid,\r\n    elizaLogger,\r\n    getEmbeddingZeroVector,\r\n} from \"@ai16z/eliza\";\r\nimport { ClientBase } from \"./base\";\r\nimport { buildConversationThread, sendTweet, wait } from \"./utils.ts\";\r\n\r\nexport const twitterMessageHandlerTemplate =\r\n    `\r\n# Areas of Expertise\r\n{{knowledge}}\r\n\r\n# About {{agentName}} (@{{twitterUserName}}):\r\n{{bio}}\r\n{{lore}}\r\n{{topics}}\r\n\r\n{{providers}}\r\n\r\n{{characterPostExamples}}\r\n\r\n{{postDirections}}\r\n\r\nRecent interactions between {{agentName}} and other users:\r\n{{recentPostInteractions}}\r\n\r\n{{recentPosts}}\r\n\r\n# Task: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:\r\nCurrent Post:\r\n{{currentPost}}\r\n\r\nThread of Tweets You Are Replying To:\r\n{{formattedConversation}}\r\n\r\n{{actions}}\r\n\r\n# Task: Generate a post in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}). You MUST include an action if the current post text includes a prompt that is similar to one of the available actions mentioned here:\r\n{{actionNames}}\r\n\r\nHere is the current post text again. Remember to include an action if the current post text includes a prompt that asks for one of the available actions mentioned above (does not need to be exact):\r\n{{currentPost}}\r\n` + messageCompletionFooter;\r\n\r\nexport const twitterShouldRespondTemplate =\r\n    `# INSTRUCTIONS: Determine if {{agentName}} (@{{twitterUserName}}) should respond to the message and participate in the conversation. Do not comment. Just respond with \"true\" or \"false\".\r\n\r\nResponse options are RESPOND, IGNORE and STOP .\r\n\r\n{{agentName}} should respond to messages that are directed at them, or participate in conversations that are interesting or relevant to their background, IGNORE messages that are irrelevant to them, and should STOP if the conversation is concluded.\r\n\r\n{{agentName}} is in a room with other users and wants to be conversational, but not annoying.\r\n{{agentName}} must RESPOND to messages that are directed at them, a command towards them, or participate in conversations that are interesting or relevant to their background.\r\nIf a message is not interesting or relevant, {{agentName}} should IGNORE.\r\nUnless directly RESPONDing to a user, {{agentName}} should IGNORE messages that are very short or do not contain much information.\r\nIf a user asks {{agentName}} to stop talking, {{agentName}} should STOP.\r\nIf {{agentName}} concludes a conversation and isn't part of the conversation anymore, {{agentName}} should STOP.\r\n\r\n{{recentPosts}}\r\n\r\nIMPORTANT: {{agentName}} (aka @{{twitterUserName}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.\r\n\r\n{{currentPost}}\r\n\r\nThread of Tweets You Are Replying To:\r\n\r\n{{formattedConversation}}\r\n\r\n# INSTRUCTIONS: Respond with [RESPOND] if {{agentName}} should respond, or [IGNORE] if {{agentName}} should not respond to the last message and [STOP] if {{agentName}} should stop participating in the conversation.\r\n` + shouldRespondFooter;\r\n\r\nexport class TwitterInteractionClient {\r\n    client: ClientBase;\r\n    runtime: IAgentRuntime;\r\n\r\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\r\n        this.client = client;\r\n        this.runtime = runtime;\r\n    }\r\n\r\n    async start() {\r\n        const handleTwitterInteractionsLoop = () => {\r\n            this.handleTwitterInteractions();\r\n            setTimeout(\r\n                handleTwitterInteractionsLoop,\r\n                Number(\r\n                    this.runtime.getSetting(\"TWITTER_POLL_INTERVAL\") || 120\r\n                ) * 1000 // Default to 2 minutes\r\n            );\r\n        };\r\n        handleTwitterInteractionsLoop();\r\n    }\r\n\r\n    async handleTwitterInteractions() {\r\n        elizaLogger.log(\"Checking Twitter interactions\");\r\n\r\n        const twitterUsername = this.client.profile.username;\r\n        try {\r\n            // Check for mentions\r\n            const tweetCandidates = (\r\n                await this.client.fetchSearchTweets(\r\n                    `@${twitterUsername}`,\r\n                    20,\r\n                    SearchMode.Latest\r\n                )\r\n            ).tweets;\r\n\r\n            // de-duplicate tweetCandidates with a set\r\n            const uniqueTweetCandidates = [...new Set(tweetCandidates)];\r\n            // Sort tweet candidates by ID in ascending order\r\n            uniqueTweetCandidates\r\n                .sort((a, b) => a.id.localeCompare(b.id))\r\n                .filter((tweet) => tweet.userId !== this.client.profile.id);\r\n\r\n            // for each tweet candidate, handle the tweet\r\n            for (const tweet of uniqueTweetCandidates) {\r\n                if (\r\n                    !this.client.lastCheckedTweetId ||\r\n                    BigInt(tweet.id) > this.client.lastCheckedTweetId\r\n                ) {\r\n                    // Generate the tweetId UUID the same way it's done in handleTweet\r\n                    const tweetId = stringToUuid(\r\n                        tweet.id + \"-\" + this.runtime.agentId\r\n                    );\r\n\r\n                    // Check if we've already processed this tweet\r\n                    const existingResponse =\r\n                        await this.runtime.messageManager.getMemoryById(\r\n                            tweetId\r\n                        );\r\n\r\n                    if (existingResponse) {\r\n                        elizaLogger.log(\r\n                            `Already responded to tweet ${tweet.id}, skipping`\r\n                        );\r\n                        continue;\r\n                    }\r\n                    elizaLogger.log(\"New Tweet found\", tweet.permanentUrl);\r\n\r\n                    const roomId = stringToUuid(\r\n                        tweet.conversationId + \"-\" + this.runtime.agentId\r\n                    );\r\n\r\n                    const userIdUUID =\r\n                        tweet.userId === this.client.profile.id\r\n                            ? this.runtime.agentId\r\n                            : stringToUuid(tweet.userId!);\r\n\r\n                    await this.runtime.ensureConnection(\r\n                        userIdUUID,\r\n                        roomId,\r\n                        tweet.username,\r\n                        tweet.name,\r\n                        \"twitter\"\r\n                    );\r\n\r\n                    const thread = await buildConversationThread(\r\n                        tweet,\r\n                        this.client\r\n                    );\r\n\r\n                    const message = {\r\n                        content: { text: tweet.text },\r\n                        agentId: this.runtime.agentId,\r\n                        userId: userIdUUID,\r\n                        roomId,\r\n                    };\r\n\r\n                    await this.handleTweet({\r\n                        tweet,\r\n                        message,\r\n                        thread,\r\n                    });\r\n\r\n                    // Update the last checked tweet ID after processing each tweet\r\n                    this.client.lastCheckedTweetId = BigInt(tweet.id);\r\n                }\r\n            }\r\n\r\n            // Save the latest checked tweet ID to the file\r\n            await this.client.cacheLatestCheckedTweetId();\r\n\r\n            elizaLogger.log(\"Finished checking Twitter interactions\");\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error handling Twitter interactions:\", error);\r\n        }\r\n    }\r\n\r\n    private async handleTweet({\r\n        tweet,\r\n        message,\r\n        thread,\r\n    }: {\r\n        tweet: Tweet;\r\n        message: Memory;\r\n        thread: Tweet[];\r\n    }) {\r\n        if (tweet.userId === this.client.profile.id) {\r\n            // console.log(\"skipping tweet from bot itself\", tweet.id);\r\n            // Skip processing if the tweet is from the bot itself\r\n            return;\r\n        }\r\n\r\n        if (!message.content.text) {\r\n            elizaLogger.log(\"Skipping Tweet with no text\", tweet.id);\r\n            return { text: \"\", action: \"IGNORE\" };\r\n        }\r\n\r\n        elizaLogger.log(\"Processing Tweet: \", tweet.id);\r\n        const formatTweet = (tweet: Tweet) => {\r\n            return `  ID: ${tweet.id}\r\n  From: ${tweet.name} (@${tweet.username})\r\n  Text: ${tweet.text}`;\r\n        };\r\n        const currentPost = formatTweet(tweet);\r\n\r\n        elizaLogger.debug(\"Thread: \", thread);\r\n        const formattedConversation = thread\r\n            .map(\r\n                (tweet) => `@${tweet.username} (${new Date(\r\n                    tweet.timestamp * 1000\r\n                ).toLocaleString(\"en-US\", {\r\n                    hour: \"2-digit\",\r\n                    minute: \"2-digit\",\r\n                    month: \"short\",\r\n                    day: \"numeric\",\r\n                })}):\r\n        ${tweet.text}`\r\n            )\r\n            .join(\"\\n\\n\");\r\n\r\n        elizaLogger.debug(\"formattedConversation: \", formattedConversation);\r\n\r\n        let state = await this.runtime.composeState(message, {\r\n            twitterClient: this.client.twitterClient,\r\n            twitterUserName: this.runtime.getSetting(\"TWITTER_USERNAME\"),\r\n            currentPost,\r\n            formattedConversation,\r\n        });\r\n\r\n        // check if the tweet exists, save if it doesn't\r\n        const tweetId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\r\n        const tweetExists =\r\n            await this.runtime.messageManager.getMemoryById(tweetId);\r\n\r\n        if (!tweetExists) {\r\n            elizaLogger.log(\"tweet does not exist, saving\");\r\n            const userIdUUID = stringToUuid(tweet.userId as string);\r\n            const roomId = stringToUuid(tweet.conversationId);\r\n\r\n            const message = {\r\n                id: tweetId,\r\n                agentId: this.runtime.agentId,\r\n                content: {\r\n                    text: tweet.text,\r\n                    url: tweet.permanentUrl,\r\n                    inReplyTo: tweet.inReplyToStatusId\r\n                        ? stringToUuid(\r\n                              tweet.inReplyToStatusId +\r\n                                  \"-\" +\r\n                                  this.runtime.agentId\r\n                          )\r\n                        : undefined,\r\n                },\r\n                userId: userIdUUID,\r\n                roomId,\r\n                createdAt: tweet.timestamp * 1000,\r\n            };\r\n            this.client.saveRequestMessage(message, state);\r\n        }\r\n\r\n        const shouldRespondContext = composeContext({\r\n            state,\r\n            template:\r\n                this.runtime.character.templates\r\n                    ?.twitterShouldRespondTemplate ||\r\n                this.runtime.character?.templates?.shouldRespondTemplate ||\r\n                twitterShouldRespondTemplate,\r\n        });\r\n\r\n        const shouldRespond = await generateShouldRespond({\r\n            runtime: this.runtime,\r\n            context: shouldRespondContext,\r\n            modelClass: ModelClass.MEDIUM,\r\n        });\r\n\r\n        // Promise<\"RESPOND\" | \"IGNORE\" | \"STOP\" | null> {\r\n        if (shouldRespond !== \"RESPOND\") {\r\n            elizaLogger.log(\"Not responding to message\");\r\n            return { text: \"Response Decision:\", action: shouldRespond };\r\n        }\r\n\r\n        const context = composeContext({\r\n            state,\r\n            template:\r\n                this.runtime.character.templates\r\n                    ?.twitterMessageHandlerTemplate ||\r\n                this.runtime.character?.templates?.messageHandlerTemplate ||\r\n                twitterMessageHandlerTemplate,\r\n        });\r\n\r\n        elizaLogger.debug(\"Interactions prompt:\\n\" + context);\r\n\r\n        const response = await generateMessageResponse({\r\n            runtime: this.runtime,\r\n            context,\r\n            modelClass: ModelClass.MEDIUM,\r\n        });\r\n\r\n        const removeQuotes = (str: string) =>\r\n            str.replace(/^['\"](.*)['\"]$/, \"$1\");\r\n\r\n        const stringId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\r\n\r\n        response.inReplyTo = stringId;\r\n\r\n        response.text = removeQuotes(response.text);\r\n\r\n        if (response.text) {\r\n            try {\r\n                const callback: HandlerCallback = async (response: Content) => {\r\n                    const memories = await sendTweet(\r\n                        this.client,\r\n                        response,\r\n                        message.roomId,\r\n                        this.runtime.getSetting(\"TWITTER_USERNAME\"),\r\n                        tweet.id\r\n                    );\r\n                    return memories;\r\n                };\r\n\r\n                const responseMessages = await callback(response);\r\n\r\n                state = (await this.runtime.updateRecentMessageState(\r\n                    state\r\n                )) as State;\r\n\r\n                for (const responseMessage of responseMessages) {\r\n                    if (\r\n                        responseMessage ===\r\n                        responseMessages[responseMessages.length - 1]\r\n                    ) {\r\n                        responseMessage.content.action = response.action;\r\n                    } else {\r\n                        responseMessage.content.action = \"CONTINUE\";\r\n                    }\r\n                    await this.runtime.messageManager.createMemory(\r\n                        responseMessage\r\n                    );\r\n                }\r\n\r\n                await this.runtime.evaluate(message, state);\r\n\r\n                await this.runtime.processActions(\r\n                    message,\r\n                    responseMessages,\r\n                    state\r\n                );\r\n\r\n                const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\\nAgent's Output:\\n${response.text}`;\r\n\r\n                await this.runtime.cacheManager.set(\r\n                    `twitter/tweet_generation_${tweet.id}.txt`,\r\n                    responseInfo\r\n                );\r\n                await wait();\r\n            } catch (error) {\r\n                elizaLogger.error(`Error sending response tweet: ${error}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    async buildConversationThread(\r\n        tweet: Tweet,\r\n        maxReplies: number = 10\r\n    ): Promise<Tweet[]> {\r\n        const thread: Tweet[] = [];\r\n        const visited: Set<string> = new Set();\r\n\r\n        async function processThread(currentTweet: Tweet, depth: number = 0) {\r\n            elizaLogger.log(\"Processing tweet:\", {\r\n                id: currentTweet.id,\r\n                inReplyToStatusId: currentTweet.inReplyToStatusId,\r\n                depth: depth,\r\n            });\r\n\r\n            if (!currentTweet) {\r\n                elizaLogger.log(\"No current tweet found for thread building\");\r\n                return;\r\n            }\r\n\r\n            if (depth >= maxReplies) {\r\n                elizaLogger.log(\"Reached maximum reply depth\", depth);\r\n                return;\r\n            }\r\n\r\n            // Handle memory storage\r\n            const memory = await this.runtime.messageManager.getMemoryById(\r\n                stringToUuid(currentTweet.id + \"-\" + this.runtime.agentId)\r\n            );\r\n            if (!memory) {\r\n                const roomId = stringToUuid(\r\n                    currentTweet.conversationId + \"-\" + this.runtime.agentId\r\n                );\r\n                const userId = stringToUuid(currentTweet.userId);\r\n\r\n                await this.runtime.ensureConnection(\r\n                    userId,\r\n                    roomId,\r\n                    currentTweet.username,\r\n                    currentTweet.name,\r\n                    \"twitter\"\r\n                );\r\n\r\n                this.runtime.messageManager.createMemory({\r\n                    id: stringToUuid(\r\n                        currentTweet.id + \"-\" + this.runtime.agentId\r\n                    ),\r\n                    agentId: this.runtime.agentId,\r\n                    content: {\r\n                        text: currentTweet.text,\r\n                        source: \"twitter\",\r\n                        url: currentTweet.permanentUrl,\r\n                        inReplyTo: currentTweet.inReplyToStatusId\r\n                            ? stringToUuid(\r\n                                  currentTweet.inReplyToStatusId +\r\n                                      \"-\" +\r\n                                      this.runtime.agentId\r\n                              )\r\n                            : undefined,\r\n                    },\r\n                    createdAt: currentTweet.timestamp * 1000,\r\n                    roomId,\r\n                    userId:\r\n                        currentTweet.userId === this.twitterUserId\r\n                            ? this.runtime.agentId\r\n                            : stringToUuid(currentTweet.userId),\r\n                    embedding: getEmbeddingZeroVector(),\r\n                });\r\n            }\r\n\r\n            if (visited.has(currentTweet.id)) {\r\n                elizaLogger.log(\"Already visited tweet:\", currentTweet.id);\r\n                return;\r\n            }\r\n\r\n            visited.add(currentTweet.id);\r\n            thread.unshift(currentTweet);\r\n\r\n            elizaLogger.debug(\"Current thread state:\", {\r\n                length: thread.length,\r\n                currentDepth: depth,\r\n                tweetId: currentTweet.id,\r\n            });\r\n\r\n            if (currentTweet.inReplyToStatusId) {\r\n                elizaLogger.log(\r\n                    \"Fetching parent tweet:\",\r\n                    currentTweet.inReplyToStatusId\r\n                );\r\n                try {\r\n                    const parentTweet = await this.twitterClient.getTweet(\r\n                        currentTweet.inReplyToStatusId\r\n                    );\r\n\r\n                    if (parentTweet) {\r\n                        elizaLogger.log(\"Found parent tweet:\", {\r\n                            id: parentTweet.id,\r\n                            text: parentTweet.text?.slice(0, 50),\r\n                        });\r\n                        await processThread(parentTweet, depth + 1);\r\n                    } else {\r\n                        elizaLogger.log(\r\n                            \"No parent tweet found for:\",\r\n                            currentTweet.inReplyToStatusId\r\n                        );\r\n                    }\r\n                } catch (error) {\r\n                    elizaLogger.log(\"Error fetching parent tweet:\", {\r\n                        tweetId: currentTweet.inReplyToStatusId,\r\n                        error,\r\n                    });\r\n                }\r\n            } else {\r\n                elizaLogger.log(\r\n                    \"Reached end of reply chain at:\",\r\n                    currentTweet.id\r\n                );\r\n            }\r\n        }\r\n\r\n        // Need to bind this context for the inner function\r\n        await processThread.bind(this)(tweet, 0);\r\n\r\n        elizaLogger.debug(\"Final thread built:\", {\r\n            totalTweets: thread.length,\r\n            tweetIds: thread.map((t) => ({\r\n                id: t.id,\r\n                text: t.text?.slice(0, 50),\r\n            })),\r\n        });\r\n\r\n        return thread;\r\n    }\r\n}\r\n","import { Tweet } from \"agent-twitter-client\";\r\nimport { getEmbeddingZeroVector } from \"@ai16z/eliza\";\r\nimport { Content, Memory, UUID } from \"@ai16z/eliza\";\r\nimport { stringToUuid } from \"@ai16z/eliza\";\r\nimport { ClientBase } from \"./base\";\r\nimport { elizaLogger } from \"@ai16z/eliza\";\r\n\r\nconst MAX_TWEET_LENGTH = 280; // Updated to Twitter's current character limit\r\n\r\nexport const wait = (minTime: number = 1000, maxTime: number = 3000) => {\r\n    const waitTime =\r\n        Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;\r\n    return new Promise((resolve) => setTimeout(resolve, waitTime));\r\n};\r\n\r\nexport const isValidTweet = (tweet: Tweet): boolean => {\r\n    // Filter out tweets with too many hashtags, @s, or $ signs, probably spam or garbage\r\n    const hashtagCount = (tweet.text?.match(/#/g) || []).length;\r\n    const atCount = (tweet.text?.match(/@/g) || []).length;\r\n    const dollarSignCount = (tweet.text?.match(/\\$/g) || []).length;\r\n    const totalCount = hashtagCount + atCount + dollarSignCount;\r\n\r\n    return (\r\n        hashtagCount <= 1 &&\r\n        atCount <= 2 &&\r\n        dollarSignCount <= 1 &&\r\n        totalCount <= 3\r\n    );\r\n};\r\n\r\nexport async function buildConversationThread(\r\n    tweet: Tweet,\r\n    client: ClientBase,\r\n    maxReplies: number = 10\r\n): Promise<Tweet[]> {\r\n    const thread: Tweet[] = [];\r\n    const visited: Set<string> = new Set();\r\n\r\n    async function processThread(currentTweet: Tweet, depth: number = 0) {\r\n        elizaLogger.debug(\"Processing tweet:\", {\r\n            id: currentTweet.id,\r\n            inReplyToStatusId: currentTweet.inReplyToStatusId,\r\n            depth: depth,\r\n        });\r\n\r\n        if (!currentTweet) {\r\n            elizaLogger.debug(\"No current tweet found for thread building\");\r\n            return;\r\n        }\r\n\r\n        // Stop if we've reached our reply limit\r\n        if (depth >= maxReplies) {\r\n            elizaLogger.debug(\"Reached maximum reply depth\", depth);\r\n            return;\r\n        }\r\n\r\n        // Handle memory storage\r\n        const memory = await client.runtime.messageManager.getMemoryById(\r\n            stringToUuid(currentTweet.id + \"-\" + client.runtime.agentId)\r\n        );\r\n        if (!memory) {\r\n            const roomId = stringToUuid(\r\n                currentTweet.conversationId + \"-\" + client.runtime.agentId\r\n            );\r\n            const userId = stringToUuid(currentTweet.userId);\r\n\r\n            await client.runtime.ensureConnection(\r\n                userId,\r\n                roomId,\r\n                currentTweet.username,\r\n                currentTweet.name,\r\n                \"twitter\"\r\n            );\r\n\r\n            await client.runtime.messageManager.createMemory({\r\n                id: stringToUuid(\r\n                    currentTweet.id + \"-\" + client.runtime.agentId\r\n                ),\r\n                agentId: client.runtime.agentId,\r\n                content: {\r\n                    text: currentTweet.text,\r\n                    source: \"twitter\",\r\n                    url: currentTweet.permanentUrl,\r\n                    inReplyTo: currentTweet.inReplyToStatusId\r\n                        ? stringToUuid(\r\n                              currentTweet.inReplyToStatusId +\r\n                                  \"-\" +\r\n                                  client.runtime.agentId\r\n                          )\r\n                        : undefined,\r\n                },\r\n                createdAt: currentTweet.timestamp * 1000,\r\n                roomId,\r\n                userId:\r\n                    currentTweet.userId === client.profile.id\r\n                        ? client.runtime.agentId\r\n                        : stringToUuid(currentTweet.userId),\r\n                embedding: getEmbeddingZeroVector(),\r\n            });\r\n        }\r\n\r\n        if (visited.has(currentTweet.id)) {\r\n            elizaLogger.debug(\"Already visited tweet:\", currentTweet.id);\r\n            return;\r\n        }\r\n\r\n        visited.add(currentTweet.id);\r\n        thread.unshift(currentTweet);\r\n\r\n        elizaLogger.debug(\"Current thread state:\", {\r\n            length: thread.length,\r\n            currentDepth: depth,\r\n            tweetId: currentTweet.id,\r\n        });\r\n\r\n        // If there's a parent tweet, fetch and process it\r\n        if (currentTweet.inReplyToStatusId) {\r\n            elizaLogger.debug(\r\n                \"Fetching parent tweet:\",\r\n                currentTweet.inReplyToStatusId\r\n            );\r\n            try {\r\n                const parentTweet = await client.twitterClient.getTweet(\r\n                    currentTweet.inReplyToStatusId\r\n                );\r\n\r\n                if (parentTweet) {\r\n                    elizaLogger.debug(\"Found parent tweet:\", {\r\n                        id: parentTweet.id,\r\n                        text: parentTweet.text?.slice(0, 50),\r\n                    });\r\n                    await processThread(parentTweet, depth + 1);\r\n                } else {\r\n                    elizaLogger.debug(\r\n                        \"No parent tweet found for:\",\r\n                        currentTweet.inReplyToStatusId\r\n                    );\r\n                }\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error fetching parent tweet:\", {\r\n                    tweetId: currentTweet.inReplyToStatusId,\r\n                    error,\r\n                });\r\n            }\r\n        } else {\r\n            elizaLogger.debug(\r\n                \"Reached end of reply chain at:\",\r\n                currentTweet.id\r\n            );\r\n        }\r\n    }\r\n\r\n    await processThread(tweet, 0);\r\n\r\n    elizaLogger.debug(\"Final thread built:\", {\r\n        totalTweets: thread.length,\r\n        tweetIds: thread.map((t) => ({\r\n            id: t.id,\r\n            text: t.text?.slice(0, 50),\r\n        })),\r\n    });\r\n\r\n    return thread;\r\n}\r\n\r\nexport async function sendTweet(\r\n    client: ClientBase,\r\n    content: Content,\r\n    roomId: UUID,\r\n    twitterUsername: string,\r\n    inReplyTo: string\r\n): Promise<Memory[]> {\r\n    const tweetChunks = splitTweetContent(content.text);\r\n    const sentTweets: Tweet[] = [];\r\n    let previousTweetId = inReplyTo;\r\n\r\n    for (const chunk of tweetChunks) {\r\n        const result = await client.requestQueue.add(\r\n            async () =>\r\n                await client.twitterClient.sendTweet(\r\n                    chunk.trim(),\r\n                    previousTweetId\r\n                )\r\n        );\r\n        const body = await result.json();\r\n\r\n        // if we have a response\r\n        if (body?.data?.create_tweet?.tweet_results?.result) {\r\n            // Parse the response\r\n            const tweetResult = body.data.create_tweet.tweet_results.result;\r\n            const finalTweet: Tweet = {\r\n                id: tweetResult.rest_id,\r\n                text: tweetResult.legacy.full_text,\r\n                conversationId: tweetResult.legacy.conversation_id_str,\r\n                timestamp:\r\n                    new Date(tweetResult.legacy.created_at).getTime() / 1000,\r\n                userId: tweetResult.legacy.user_id_str,\r\n                inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\r\n                permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\r\n                hashtags: [],\r\n                mentions: [],\r\n                photos: [],\r\n                thread: [],\r\n                urls: [],\r\n                videos: [],\r\n            };\r\n            sentTweets.push(finalTweet);\r\n            previousTweetId = finalTweet.id;\r\n        } else {\r\n            console.error(\"Error sending chunk\", chunk, \"repsonse:\", body);\r\n        }\r\n\r\n        // Wait a bit between tweets to avoid rate limiting issues\r\n        await wait(1000, 2000);\r\n    }\r\n\r\n    const memories: Memory[] = sentTweets.map((tweet) => ({\r\n        id: stringToUuid(tweet.id + \"-\" + client.runtime.agentId),\r\n        agentId: client.runtime.agentId,\r\n        userId: client.runtime.agentId,\r\n        content: {\r\n            text: tweet.text,\r\n            source: \"twitter\",\r\n            url: tweet.permanentUrl,\r\n            inReplyTo: tweet.inReplyToStatusId\r\n                ? stringToUuid(\r\n                      tweet.inReplyToStatusId + \"-\" + client.runtime.agentId\r\n                  )\r\n                : undefined,\r\n        },\r\n        roomId,\r\n        embedding: getEmbeddingZeroVector(),\r\n        createdAt: tweet.timestamp * 1000,\r\n    }));\r\n\r\n    return memories;\r\n}\r\n\r\nfunction splitTweetContent(content: string): string[] {\r\n    const maxLength = MAX_TWEET_LENGTH;\r\n    const paragraphs = content.split(\"\\n\\n\").map((p) => p.trim());\r\n    const tweets: string[] = [];\r\n    let currentTweet = \"\";\r\n\r\n    for (const paragraph of paragraphs) {\r\n        if (!paragraph) continue;\r\n\r\n        if ((currentTweet + \"\\n\\n\" + paragraph).trim().length <= maxLength) {\r\n            if (currentTweet) {\r\n                currentTweet += \"\\n\\n\" + paragraph;\r\n            } else {\r\n                currentTweet = paragraph;\r\n            }\r\n        } else {\r\n            if (currentTweet) {\r\n                tweets.push(currentTweet.trim());\r\n            }\r\n            if (paragraph.length <= maxLength) {\r\n                currentTweet = paragraph;\r\n            } else {\r\n                // Split long paragraph into smaller chunks\r\n                const chunks = splitParagraph(paragraph, maxLength);\r\n                tweets.push(...chunks.slice(0, -1));\r\n                currentTweet = chunks[chunks.length - 1];\r\n            }\r\n        }\r\n    }\r\n\r\n    if (currentTweet) {\r\n        tweets.push(currentTweet.trim());\r\n    }\r\n\r\n    return tweets;\r\n}\r\n\r\nfunction splitParagraph(paragraph: string, maxLength: number): string[] {\r\n    // eslint-disable-next-line\r\n    const sentences = paragraph.match(/[^\\.!\\?]+[\\.!\\?]+|[^\\.!\\?]+$/g) || [\r\n        paragraph,\r\n    ];\r\n    const chunks: string[] = [];\r\n    let currentChunk = \"\";\r\n\r\n    for (const sentence of sentences) {\r\n        if ((currentChunk + \" \" + sentence).trim().length <= maxLength) {\r\n            if (currentChunk) {\r\n                currentChunk += \" \" + sentence;\r\n            } else {\r\n                currentChunk = sentence;\r\n            }\r\n        } else {\r\n            if (currentChunk) {\r\n                chunks.push(currentChunk.trim());\r\n            }\r\n            if (sentence.length <= maxLength) {\r\n                currentChunk = sentence;\r\n            } else {\r\n                // Split long sentence into smaller pieces\r\n                const words = sentence.split(\" \");\r\n                currentChunk = \"\";\r\n                for (const word of words) {\r\n                    if (\r\n                        (currentChunk + \" \" + word).trim().length <= maxLength\r\n                    ) {\r\n                        if (currentChunk) {\r\n                            currentChunk += \" \" + word;\r\n                        } else {\r\n                            currentChunk = word;\r\n                        }\r\n                    } else {\r\n                        if (currentChunk) {\r\n                            chunks.push(currentChunk.trim());\r\n                        }\r\n                        currentChunk = word;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (currentChunk) {\r\n        chunks.push(currentChunk.trim());\r\n    }\r\n\r\n    return chunks;\r\n}\r\n","import { TwitterPostClient } from \"./post.ts\";\r\nimport { TwitterSearchClient } from \"./search.ts\";\r\nimport { TwitterInteractionClient } from \"./interactions.ts\";\r\nimport { IAgentRuntime, Client, elizaLogger } from \"@ai16z/eliza\";\r\nimport { validateTwitterConfig } from \"./environment.ts\";\r\nimport { ClientBase } from \"./base.ts\";\r\n\r\nclass TwitterManager {\r\n    client: ClientBase;\r\n    post: TwitterPostClient;\r\n    search: TwitterSearchClient;\r\n    interaction: TwitterInteractionClient;\r\n    constructor(runtime: IAgentRuntime) {\r\n        this.client = new ClientBase(runtime);\r\n        this.post = new TwitterPostClient(this.client, runtime);\r\n        // this.search = new TwitterSearchClient(runtime); // don't start the search client by default\r\n        // this searches topics from character file, but kind of violates consent of random users\r\n        // burns your rate limit and can get your account banned\r\n        // use at your own risk\r\n        this.interaction = new TwitterInteractionClient(this.client, runtime);\r\n    }\r\n}\r\n\r\nexport const TwitterClientInterface: Client = {\r\n    async start(runtime: IAgentRuntime) {\r\n        await validateTwitterConfig(runtime);\r\n\r\n        elizaLogger.log(\"Twitter client started\");\r\n\r\n        const manager = new TwitterManager(runtime);\r\n\r\n        await manager.client.init();\r\n\r\n        await manager.post.start();\r\n\r\n        await manager.interaction.start();\r\n\r\n        return manager;\r\n    },\r\n    async stop(_runtime: IAgentRuntime) {\r\n        elizaLogger.warn(\"Twitter client does not support stopping yet\");\r\n    },\r\n};\r\n\r\nexport default TwitterClientInterface;\r\n","import { IAgentRuntime } from \"@ai16z/eliza\";\r\nimport { z } from \"zod\";\r\n\r\nexport const twitterEnvSchema = z.object({\r\n    TWITTER_DRY_RUN: z\r\n        .string()\r\n        .transform((val) => val.toLowerCase() === \"true\"),\r\n    TWITTER_USERNAME: z.string().min(1, \"Twitter username is required\"),\r\n    TWITTER_PASSWORD: z.string().min(1, \"Twitter password is required\"),\r\n    TWITTER_EMAIL: z.string().email(\"Valid Twitter email is required\"),\r\n    TWITTER_COOKIES: z.string().optional(),\r\n});\r\n\r\nexport type TwitterConfig = z.infer<typeof twitterEnvSchema>;\r\n\r\nexport async function validateTwitterConfig(\r\n    runtime: IAgentRuntime\r\n): Promise<TwitterConfig> {\r\n    try {\r\n        const config = {\r\n            TWITTER_DRY_RUN:\r\n                runtime.getSetting(\"TWITTER_DRY_RUN\") ||\r\n                process.env.TWITTER_DRY_RUN ||\r\n                \"false\",\r\n            TWITTER_USERNAME:\r\n                runtime.getSetting(\"TWITTER_USERNAME\") ||\r\n                process.env.TWITTER_USERNAME,\r\n            TWITTER_PASSWORD:\r\n                runtime.getSetting(\"TWITTER_PASSWORD\") ||\r\n                process.env.TWITTER_PASSWORD,\r\n            TWITTER_EMAIL:\r\n                runtime.getSetting(\"TWITTER_EMAIL\") ||\r\n                process.env.TWITTER_EMAIL,\r\n            TWITTER_COOKIES:\r\n                runtime.getSetting(\"TWITTER_COOKIES\") ||\r\n                process.env.TWITTER_COOKIES,\r\n        };\r\n\r\n        return twitterEnvSchema.parse(config);\r\n    } catch (error) {\r\n        if (error instanceof z.ZodError) {\r\n            const errorMessages = error.errors\r\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\r\n                .join(\"\\n\");\r\n            throw new Error(\r\n                `Twitter configuration validation failed:\\n${errorMessages}`\r\n            );\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n","import {\r\n    Content,\r\n    IAgentRuntime,\r\n    IImageDescriptionService,\r\n    Memory,\r\n    State,\r\n    UUID,\r\n    getEmbeddingZeroVector,\r\n    elizaLogger,\r\n    stringToUuid,\r\n} from \"@ai16z/eliza\";\r\nimport {\r\n    QueryTweetsResponse,\r\n    Scraper,\r\n    SearchMode,\r\n    Tweet,\r\n} from \"agent-twitter-client\";\r\nimport { EventEmitter } from \"events\";\r\n\r\nexport function extractAnswer(text: string): string {\r\n    const startIndex = text.indexOf(\"Answer: \") + 8;\r\n    const endIndex = text.indexOf(\"<|endoftext|>\", 11);\r\n    return text.slice(startIndex, endIndex);\r\n}\r\n\r\ntype TwitterProfile = {\r\n    id: string;\r\n    username: string;\r\n    screenName: string;\r\n    bio: string;\r\n    nicknames: string[];\r\n};\r\n\r\nclass RequestQueue {\r\n    private queue: (() => Promise<any>)[] = [];\r\n    private processing: boolean = false;\r\n\r\n    async add<T>(request: () => Promise<T>): Promise<T> {\r\n        return new Promise((resolve, reject) => {\r\n            this.queue.push(async () => {\r\n                try {\r\n                    const result = await request();\r\n                    resolve(result);\r\n                } catch (error) {\r\n                    reject(error);\r\n                }\r\n            });\r\n            this.processQueue();\r\n        });\r\n    }\r\n\r\n    private async processQueue(): Promise<void> {\r\n        if (this.processing || this.queue.length === 0) {\r\n            return;\r\n        }\r\n        this.processing = true;\r\n\r\n        while (this.queue.length > 0) {\r\n            const request = this.queue.shift()!;\r\n            try {\r\n                await request();\r\n            } catch (error) {\r\n                console.error(\"Error processing request:\", error);\r\n                this.queue.unshift(request);\r\n                await this.exponentialBackoff(this.queue.length);\r\n            }\r\n            await this.randomDelay();\r\n        }\r\n\r\n        this.processing = false;\r\n    }\r\n\r\n    private async exponentialBackoff(retryCount: number): Promise<void> {\r\n        const delay = Math.pow(2, retryCount) * 1000;\r\n        await new Promise((resolve) => setTimeout(resolve, delay));\r\n    }\r\n\r\n    private async randomDelay(): Promise<void> {\r\n        const delay = Math.floor(Math.random() * 2000) + 1500;\r\n        await new Promise((resolve) => setTimeout(resolve, delay));\r\n    }\r\n}\r\n\r\nexport class ClientBase extends EventEmitter {\r\n    static _twitterClients: { [accountIdentifier: string]: Scraper } = {};\r\n    twitterClient: Scraper;\r\n    runtime: IAgentRuntime;\r\n    directions: string;\r\n    lastCheckedTweetId: bigint | null = null;\r\n    imageDescriptionService: IImageDescriptionService;\r\n    temperature: number = 0.5;\r\n\r\n    requestQueue: RequestQueue = new RequestQueue();\r\n\r\n    profile: TwitterProfile | null;\r\n\r\n    async cacheTweet(tweet: Tweet): Promise<void> {\r\n        if (!tweet) {\r\n            console.warn(\"Tweet is undefined, skipping cache\");\r\n            return;\r\n        }\r\n\r\n        this.runtime.cacheManager.set(`twitter/tweets/${tweet.id}`, tweet);\r\n    }\r\n\r\n    async getCachedTweet(tweetId: string): Promise<Tweet | undefined> {\r\n        const cached = await this.runtime.cacheManager.get<Tweet>(\r\n            `twitter/tweets/${tweetId}`\r\n        );\r\n\r\n        return cached;\r\n    }\r\n\r\n    async getTweet(tweetId: string): Promise<Tweet> {\r\n        const cachedTweet = await this.getCachedTweet(tweetId);\r\n\r\n        if (cachedTweet) {\r\n            return cachedTweet;\r\n        }\r\n\r\n        const tweet = await this.requestQueue.add(() =>\r\n            this.twitterClient.getTweet(tweetId)\r\n        );\r\n\r\n        await this.cacheTweet(tweet);\r\n        return tweet;\r\n    }\r\n\r\n    callback: (self: ClientBase) => any = null;\r\n\r\n    onReady() {\r\n        throw new Error(\r\n            \"Not implemented in base class, please call from subclass\"\r\n        );\r\n    }\r\n\r\n    constructor(runtime: IAgentRuntime) {\r\n        super();\r\n        this.runtime = runtime;\r\n        const username = this.runtime.getSetting(\"TWITTER_USERNAME\");\r\n        if (ClientBase._twitterClients[username]) {\r\n            this.twitterClient = ClientBase._twitterClients[username];\r\n        } else {\r\n            this.twitterClient = new Scraper();\r\n            ClientBase._twitterClients[username] = this.twitterClient;\r\n        }\r\n\r\n        this.directions =\r\n            \"- \" +\r\n            this.runtime.character.style.all.join(\"\\n- \") +\r\n            \"- \" +\r\n            this.runtime.character.style.post.join();\r\n    }\r\n\r\n    async init() {\r\n        //test\r\n        const username = this.runtime.getSetting(\"TWITTER_USERNAME\");\r\n\r\n        if (!username) {\r\n            throw new Error(\"Twitter username not configured\");\r\n        }\r\n        // Check for Twitter cookies\r\n        if (this.runtime.getSetting(\"TWITTER_COOKIES\")) {\r\n            const cookiesArray = JSON.parse(\r\n                this.runtime.getSetting(\"TWITTER_COOKIES\")\r\n            );\r\n\r\n            await this.setCookiesFromArray(cookiesArray);\r\n        } else {\r\n            const cachedCookies = await this.getCachedCookies(username);\r\n            if (cachedCookies) {\r\n                await this.setCookiesFromArray(cachedCookies);\r\n            }\r\n        }\r\n\r\n        elizaLogger.log(\"Waiting for Twitter login\");\r\n        while (true) {\r\n            await this.twitterClient.login(\r\n                username,\r\n                this.runtime.getSetting(\"TWITTER_PASSWORD\"),\r\n                this.runtime.getSetting(\"TWITTER_EMAIL\"),\r\n                this.runtime.getSetting(\"TWITTER_2FA_SECRET\") || undefined\r\n            );\r\n\r\n            if (await this.twitterClient.isLoggedIn()) {\r\n                const cookies = await this.twitterClient.getCookies();\r\n                await this.cacheCookies(username, cookies);\r\n                break;\r\n            }\r\n\r\n            elizaLogger.error(\"Failed to login to Twitter trying again...\");\r\n\r\n            await new Promise((resolve) => setTimeout(resolve, 2000));\r\n        }\r\n\r\n        // Initialize Twitter profile\r\n        this.profile = await this.fetchProfile(username);\r\n\r\n        if (this.profile) {\r\n            elizaLogger.log(\"Twitter user ID:\", this.profile.id);\r\n            elizaLogger.log(\r\n                \"Twitter loaded:\",\r\n                JSON.stringify(this.profile, null, 10)\r\n            );\r\n            // Store profile info for use in responses\r\n            this.runtime.character.twitterProfile = {\r\n                id: this.profile.id,\r\n                username: this.profile.username,\r\n                screenName: this.profile.screenName,\r\n                bio: this.profile.bio,\r\n                nicknames: this.profile.nicknames,\r\n            };\r\n        } else {\r\n            throw new Error(\"Failed to load profile\");\r\n        }\r\n\r\n        await this.loadLatestCheckedTweetId();\r\n        await this.populateTimeline();\r\n    }\r\n\r\n    async fetchHomeTimeline(count: number): Promise<Tweet[]> {\r\n        elizaLogger.debug(\"fetching home timeline\");\r\n        const homeTimeline = await this.twitterClient.getUserTweets(\r\n            this.profile.id,\r\n            count\r\n        );\r\n\r\n        // console.dir(homeTimeline, { depth: Infinity });\r\n\r\n        return homeTimeline.tweets;\r\n        // .filter((t) => t.__typename !== \"TweetWithVisibilityResults\")\r\n        // .map((tweet) => {\r\n        //     // console.log(\"tweet is\", tweet);\r\n        //     const obj = {\r\n        //         id: tweet.id,\r\n        //         name:\r\n        //             tweet.name ??\r\n        //             tweet. ?.user_results?.result?.legacy.name,\r\n        //         username:\r\n        //             tweet.username ??\r\n        //             tweet.core?.user_results?.result?.legacy.screen_name,\r\n        //         text: tweet.text ?? tweet.legacy?.full_text,\r\n        //         inReplyToStatusId:\r\n        //             tweet.inReplyToStatusId ??\r\n        //             tweet.legacy?.in_reply_to_status_id_str,\r\n        //         createdAt: tweet.createdAt ?? tweet.legacy?.created_at,\r\n        //         userId: tweet.userId ?? tweet.legacy?.user_id_str,\r\n        //         conversationId:\r\n        //             tweet.conversationId ??\r\n        //             tweet.legacy?.conversation_id_str,\r\n        //         hashtags: tweet.hashtags ?? tweet.legacy?.entities.hashtags,\r\n        //         mentions:\r\n        //             tweet.mentions ?? tweet.legacy?.entities.user_mentions,\r\n        //         photos:\r\n        //             tweet.photos ??\r\n        //             tweet.legacy?.entities.media?.filter(\r\n        //                 (media) => media.type === \"photo\"\r\n        //             ) ??\r\n        //             [],\r\n        //         thread: [],\r\n        //         urls: tweet.urls ?? tweet.legacy?.entities.urls,\r\n        //         videos:\r\n        //             tweet.videos ??\r\n        //             tweet.legacy?.entities.media?.filter(\r\n        //                 (media) => media.type === \"video\"\r\n        //             ) ??\r\n        //             [],\r\n        //     };\r\n        //     // console.log(\"obj is\", obj);\r\n        //     return obj;\r\n        // });\r\n    }\r\n\r\n    async fetchSearchTweets(\r\n        query: string,\r\n        maxTweets: number,\r\n        searchMode: SearchMode,\r\n        cursor?: string\r\n    ): Promise<QueryTweetsResponse> {\r\n        try {\r\n            // Sometimes this fails because we are rate limited. in this case, we just need to return an empty array\r\n            // if we dont get a response in 5 seconds, something is wrong\r\n            const timeoutPromise = new Promise((resolve) =>\r\n                setTimeout(() => resolve({ tweets: [] }), 10000)\r\n            );\r\n\r\n            try {\r\n                const result = await this.requestQueue.add(\r\n                    async () =>\r\n                        await Promise.race([\r\n                            this.twitterClient.fetchSearchTweets(\r\n                                query,\r\n                                maxTweets,\r\n                                searchMode,\r\n                                cursor\r\n                            ),\r\n                            timeoutPromise,\r\n                        ])\r\n                );\r\n                return (result ?? { tweets: [] }) as QueryTweetsResponse;\r\n            } catch (error) {\r\n                elizaLogger.error(\"Error fetching search tweets:\", error);\r\n                return { tweets: [] };\r\n            }\r\n        } catch (error) {\r\n            elizaLogger.error(\"Error fetching search tweets:\", error);\r\n            return { tweets: [] };\r\n        }\r\n    }\r\n\r\n    private async populateTimeline() {\r\n        elizaLogger.debug(\"populating timeline...\");\r\n\r\n        const cachedTimeline = await this.getCachedTimeline();\r\n\r\n        // Check if the cache file exists\r\n        if (cachedTimeline) {\r\n            // Read the cached search results from the file\r\n\r\n            // Get the existing memories from the database\r\n            const existingMemories =\r\n                await this.runtime.messageManager.getMemoriesByRoomIds({\r\n                    roomIds: cachedTimeline.map((tweet) =>\r\n                        stringToUuid(\r\n                            tweet.conversationId + \"-\" + this.runtime.agentId\r\n                        )\r\n                    ),\r\n                });\r\n\r\n            //TODO: load tweets not in cache?\r\n\r\n            // Create a Set to store the IDs of existing memories\r\n            const existingMemoryIds = new Set(\r\n                existingMemories.map((memory) => memory.id.toString())\r\n            );\r\n\r\n            // Check if any of the cached tweets exist in the existing memories\r\n            const someCachedTweetsExist = cachedTimeline.some((tweet) =>\r\n                existingMemoryIds.has(\r\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\r\n                )\r\n            );\r\n\r\n            if (someCachedTweetsExist) {\r\n                // Filter out the cached tweets that already exist in the database\r\n                const tweetsToSave = cachedTimeline.filter(\r\n                    (tweet) =>\r\n                        !existingMemoryIds.has(\r\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\r\n                        )\r\n                );\r\n\r\n                console.log({\r\n                    processingTweets: tweetsToSave\r\n                        .map((tweet) => tweet.id)\r\n                        .join(\",\"),\r\n                });\r\n\r\n                // Save the missing tweets as memories\r\n                for (const tweet of tweetsToSave) {\r\n                    elizaLogger.log(\"Saving Tweet\", tweet.id);\r\n\r\n                    const roomId = stringToUuid(\r\n                        tweet.conversationId + \"-\" + this.runtime.agentId\r\n                    );\r\n\r\n                    const userId =\r\n                        tweet.userId === this.profile.id\r\n                            ? this.runtime.agentId\r\n                            : stringToUuid(tweet.userId);\r\n\r\n                    if (tweet.userId === this.profile.id) {\r\n                        await this.runtime.ensureConnection(\r\n                            this.runtime.agentId,\r\n                            roomId,\r\n                            this.profile.username,\r\n                            this.profile.screenName,\r\n                            \"twitter\"\r\n                        );\r\n                    } else {\r\n                        await this.runtime.ensureConnection(\r\n                            userId,\r\n                            roomId,\r\n                            tweet.username,\r\n                            tweet.name,\r\n                            \"twitter\"\r\n                        );\r\n                    }\r\n\r\n                    const content = {\r\n                        text: tweet.text,\r\n                        url: tweet.permanentUrl,\r\n                        source: \"twitter\",\r\n                        inReplyTo: tweet.inReplyToStatusId\r\n                            ? stringToUuid(\r\n                                  tweet.inReplyToStatusId +\r\n                                      \"-\" +\r\n                                      this.runtime.agentId\r\n                              )\r\n                            : undefined,\r\n                    } as Content;\r\n\r\n                    elizaLogger.log(\"Creating memory for tweet\", tweet.id);\r\n\r\n                    // check if it already exists\r\n                    const memory =\r\n                        await this.runtime.messageManager.getMemoryById(\r\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\r\n                        );\r\n\r\n                    if (memory) {\r\n                        elizaLogger.log(\r\n                            \"Memory already exists, skipping timeline population\"\r\n                        );\r\n                        break;\r\n                    }\r\n\r\n                    await this.runtime.messageManager.createMemory({\r\n                        id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\r\n                        userId,\r\n                        content: content,\r\n                        agentId: this.runtime.agentId,\r\n                        roomId,\r\n                        embedding: getEmbeddingZeroVector(),\r\n                        createdAt: tweet.timestamp * 1000,\r\n                    });\r\n\r\n                    await this.cacheTweet(tweet);\r\n                }\r\n\r\n                elizaLogger.log(\r\n                    `Populated ${tweetsToSave.length} missing tweets from the cache.`\r\n                );\r\n                return;\r\n            }\r\n        }\r\n\r\n        const timeline = await this.fetchHomeTimeline(cachedTimeline ? 10 : 50);\r\n\r\n        // Get the most recent 20 mentions and interactions\r\n        const mentionsAndInteractions = await this.fetchSearchTweets(\r\n            `@${this.runtime.getSetting(\"TWITTER_USERNAME\")}`,\r\n            20,\r\n            SearchMode.Latest\r\n        );\r\n\r\n        // Combine the timeline tweets and mentions/interactions\r\n        const allTweets = [...timeline, ...mentionsAndInteractions.tweets];\r\n\r\n        // Create a Set to store unique tweet IDs\r\n        const tweetIdsToCheck = new Set<string>();\r\n        const roomIds = new Set<UUID>();\r\n\r\n        // Add tweet IDs to the Set\r\n        for (const tweet of allTweets) {\r\n            tweetIdsToCheck.add(tweet.id);\r\n            roomIds.add(\r\n                stringToUuid(tweet.conversationId + \"-\" + this.runtime.agentId)\r\n            );\r\n        }\r\n\r\n        // Check the existing memories in the database\r\n        const existingMemories =\r\n            await this.runtime.messageManager.getMemoriesByRoomIds({\r\n                roomIds: Array.from(roomIds),\r\n            });\r\n\r\n        // Create a Set to store the existing memory IDs\r\n        const existingMemoryIds = new Set<UUID>(\r\n            existingMemories.map((memory) => memory.id)\r\n        );\r\n\r\n        // Filter out the tweets that already exist in the database\r\n        const tweetsToSave = allTweets.filter(\r\n            (tweet) =>\r\n                !existingMemoryIds.has(\r\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\r\n                )\r\n        );\r\n\r\n        elizaLogger.debug({\r\n            processingTweets: tweetsToSave.map((tweet) => tweet.id).join(\",\"),\r\n        });\r\n\r\n        await this.runtime.ensureUserExists(\r\n            this.runtime.agentId,\r\n            this.profile.username,\r\n            this.runtime.character.name,\r\n            \"twitter\"\r\n        );\r\n\r\n        // Save the new tweets as memories\r\n        for (const tweet of tweetsToSave) {\r\n            elizaLogger.log(\"Saving Tweet\", tweet.id);\r\n\r\n            const roomId = stringToUuid(\r\n                tweet.conversationId + \"-\" + this.runtime.agentId\r\n            );\r\n            const userId =\r\n                tweet.userId === this.profile.id\r\n                    ? this.runtime.agentId\r\n                    : stringToUuid(tweet.userId);\r\n\r\n            if (tweet.userId === this.profile.id) {\r\n                await this.runtime.ensureConnection(\r\n                    this.runtime.agentId,\r\n                    roomId,\r\n                    this.profile.username,\r\n                    this.profile.screenName,\r\n                    \"twitter\"\r\n                );\r\n            } else {\r\n                await this.runtime.ensureConnection(\r\n                    userId,\r\n                    roomId,\r\n                    tweet.username,\r\n                    tweet.name,\r\n                    \"twitter\"\r\n                );\r\n            }\r\n\r\n            const content = {\r\n                text: tweet.text,\r\n                url: tweet.permanentUrl,\r\n                source: \"twitter\",\r\n                inReplyTo: tweet.inReplyToStatusId\r\n                    ? stringToUuid(tweet.inReplyToStatusId)\r\n                    : undefined,\r\n            } as Content;\r\n\r\n            await this.runtime.messageManager.createMemory({\r\n                id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\r\n                userId,\r\n                content: content,\r\n                agentId: this.runtime.agentId,\r\n                roomId,\r\n                embedding: getEmbeddingZeroVector(),\r\n                createdAt: tweet.timestamp * 1000,\r\n            });\r\n\r\n            await this.cacheTweet(tweet);\r\n        }\r\n\r\n        // Cache\r\n        await this.cacheTimeline(timeline);\r\n        await this.cacheMentions(mentionsAndInteractions.tweets);\r\n    }\r\n\r\n    async setCookiesFromArray(cookiesArray: any[]) {\r\n        const cookieStrings = cookiesArray.map(\r\n            (cookie) =>\r\n                `${cookie.key}=${cookie.value}; Domain=${cookie.domain}; Path=${cookie.path}; ${\r\n                    cookie.secure ? \"Secure\" : \"\"\r\n                }; ${cookie.httpOnly ? \"HttpOnly\" : \"\"}; SameSite=${\r\n                    cookie.sameSite || \"Lax\"\r\n                }`\r\n        );\r\n        await this.twitterClient.setCookies(cookieStrings);\r\n    }\r\n\r\n    async saveRequestMessage(message: Memory, state: State) {\r\n        if (message.content.text) {\r\n            const recentMessage = await this.runtime.messageManager.getMemories(\r\n                {\r\n                    roomId: message.roomId,\r\n                    count: 1,\r\n                    unique: false,\r\n                }\r\n            );\r\n\r\n            if (\r\n                recentMessage.length > 0 &&\r\n                recentMessage[0].content === message.content\r\n            ) {\r\n                elizaLogger.debug(\"Message already saved\", recentMessage[0].id);\r\n            } else {\r\n                await this.runtime.messageManager.createMemory({\r\n                    ...message,\r\n                    embedding: getEmbeddingZeroVector(),\r\n                });\r\n            }\r\n\r\n            await this.runtime.evaluate(message, {\r\n                ...state,\r\n                twitterClient: this.twitterClient,\r\n            });\r\n        }\r\n    }\r\n\r\n    async loadLatestCheckedTweetId(): Promise<void> {\r\n        const latestCheckedTweetId =\r\n            await this.runtime.cacheManager.get<string>(\r\n                `twitter/${this.profile.username}/latest_checked_tweet_id`\r\n            );\r\n\r\n        if (latestCheckedTweetId) {\r\n            this.lastCheckedTweetId = BigInt(latestCheckedTweetId);\r\n        }\r\n    }\r\n\r\n    async cacheLatestCheckedTweetId() {\r\n        if (this.lastCheckedTweetId) {\r\n            await this.runtime.cacheManager.set(\r\n                `twitter/${this.profile.username}/latest_checked_tweet_id`,\r\n                this.lastCheckedTweetId.toString()\r\n            );\r\n        }\r\n    }\r\n\r\n    async getCachedTimeline(): Promise<Tweet[] | undefined> {\r\n        return await this.runtime.cacheManager.get<Tweet[]>(\r\n            `twitter/${this.profile.username}/timeline`\r\n        );\r\n    }\r\n\r\n    async cacheTimeline(timeline: Tweet[]) {\r\n        await this.runtime.cacheManager.set(\r\n            `twitter/${this.profile.username}/timeline`,\r\n            timeline,\r\n            { expires: Date.now() + 10 * 1000 }\r\n        );\r\n    }\r\n\r\n    async cacheMentions(mentions: Tweet[]) {\r\n        await this.runtime.cacheManager.set(\r\n            `twitter/${this.profile.username}/mentions`,\r\n            mentions,\r\n            { expires: Date.now() + 10 * 1000 }\r\n        );\r\n    }\r\n\r\n    async getCachedCookies(username: string) {\r\n        return await this.runtime.cacheManager.get<any[]>(\r\n            `twitter/${username}/cookies`\r\n        );\r\n    }\r\n\r\n    async cacheCookies(username: string, cookies: any[]) {\r\n        await this.runtime.cacheManager.set(\r\n            `twitter/${username}/cookies`,\r\n            cookies\r\n        );\r\n    }\r\n\r\n    async getCachedProfile(username: string) {\r\n        return await this.runtime.cacheManager.get<TwitterProfile>(\r\n            `twitter/${username}/profile`\r\n        );\r\n    }\r\n\r\n    async cacheProfile(profile: TwitterProfile) {\r\n        await this.runtime.cacheManager.set(\r\n            `twitter/${profile.username}/profile`,\r\n            profile\r\n        );\r\n    }\r\n\r\n    async fetchProfile(username: string): Promise<TwitterProfile> {\r\n        const cached = await this.getCachedProfile(username);\r\n\r\n        if (cached) return cached;\r\n\r\n        try {\r\n            const profile = await this.requestQueue.add(async () => {\r\n                const profile = await this.twitterClient.getProfile(username);\r\n                // console.log({ profile });\r\n                return {\r\n                    id: profile.userId,\r\n                    username,\r\n                    screenName: profile.name || this.runtime.character.name,\r\n                    bio:\r\n                        profile.biography ||\r\n                        typeof this.runtime.character.bio === \"string\"\r\n                            ? (this.runtime.character.bio as string)\r\n                            : this.runtime.character.bio.length > 0\r\n                              ? this.runtime.character.bio[0]\r\n                              : \"\",\r\n                    nicknames:\r\n                        this.runtime.character.twitterProfile?.nicknames || [],\r\n                } satisfies TwitterProfile;\r\n            });\r\n\r\n            this.cacheProfile(profile);\r\n\r\n            return profile;\r\n        } catch (error) {\r\n            console.error(\"Error fetching Twitter profile:\", error);\r\n\r\n            return undefined;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","names":["composeContext","ModelClass","stringToUuid","elizaLogger","getEmbeddingZeroVector","getEmbeddingZeroVector","stringToUuid","elizaLogger","MAX_TWEET_LENGTH","elizaLogger","stringToUuid","getEmbeddingZeroVector","MAX_TWEET_LENGTH","elizaLogger","stringToUuid","tweet","message","composeContext","ModelClass","response","getEmbeddingZeroVector","elizaLogger","getEmbeddingZeroVector","elizaLogger","stringToUuid","SearchMode","elizaLogger","existingMemories","stringToUuid","existingMemoryIds","tweetsToSave","getEmbeddingZeroVector","SearchMode","profile","elizaLogger"]}